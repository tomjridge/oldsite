<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
</head>
<body>
<pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(*</span>

<span class="co">In order to showing that the test coverage is 100%, we mark with</span>
<span class="co">special comments the lines that are irrelevant and unreachable.</span>

<span class="co">Legend:</span>
<span class="co">    coverage:unused</span>
<span class="co">       lines that are meant to not be tested for now;</span>
<span class="co">     coverage:linux:irrelevant</span>
<span class="co">     coverage:mac_os_x:irrelevant</span>
<span class="co">       lines that become irrelevant when the spec is</span>
<span class="co">       initialised with a different architecture;</span>
<span class="co">    coverage:impossible</span>
<span class="co">       lines that we know cannot be reached (e.g. impossible cases of the spec);</span>
<span class="co">    coverage:fixme</span>
<span class="co">       lines that should be reached, but there are not test cases for them yet.</span>
<span class="co">*)</span>


<span class="ot">open</span> import <span class="dt">Bool</span> <span class="dt">Maybe</span> <span class="dt">Maybe_extra</span> <span class="dt">Basic_classes</span> <span class="dt">Tuple</span> <span class="dt">Num</span> <span class="dt">Set</span> <span class="dt">List</span> <span class="dt">List_extra</span> <span class="dt">Word</span> <span class="dt">Either</span> <span class="dt">Assert_extra</span> <span class="dt">String</span> <span class="dt">Function</span>
<span class="ot">open</span> import <span class="dt">T_list_array</span> <span class="dt">T_fs_prelude</span>
<span class="ot">open</span> import {ocaml} <span class="dt">`Lem_support</span>`
<span class="ot">open</span> import {ocaml} <span class="dt">`Sexplib</span>.<span class="dt">Std</span>` 
<span class="ot">open</span> import {ocaml} <span class="dt">`Sexplib</span>.<span class="dt">Conv</span>`




<span class="co">(******************************************************************************)</span>
<span class="co">(* Fs_types                                                                   *)</span>
<span class="co">(*                                                                            *)</span>
<span class="co">(* Types common to all implementations of the basic operations                *)</span>
<span class="co">(******************************************************************************)</span>

<span class="ot">module</span> Fs_types = <span class="kw">struct</span>

  <span class="ot">open</span> T_fs_prelude
  
  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* miscellaneous types           *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">type</span> ty_bytes = T_list_array<span class="kw">.</span>t <span class="co">(*o with sexp o*)</span> <span class="co">(* FIXME may want to change this to string? or parameterize? FIXME also want option of null pointer; FIXME also there are bytes passed in by user and bytes used to store file data, and these are probably not the same *)</span>

  <span class="kw">type</span> file_contents = ty_bytes <span class="co">(*o with sexp_of o*)</span> <span class="co">(* really a map from index to ... *)</span>
  <span class="kw">type</span> name = <span class="dt">string</span> <span class="co">(*o with sexp o*)</span> <span class="co">(* shortest component of a filename - doesn&#39;t include /; may be empty; may be . or .. *)</span>
<span class="co">(*  type ty_dirname = list string</span>
<span class="co">  type ty_filename = list string (* non-empty *) *)</span>

  <span class="kw">type</span> size_t = nat <span class="co">(*o with sexp o*)</span> <span class="co">(* unsigned integer of at least 16 bits http://stackoverflow.com/questions/2550774/what-is-size-t-in-c *)</span> <span class="co">(* FIXME note that these parameters are never added to, or subtracted, or otherwise operated on in this spec, they are only supplied by user, or returned e.g. as result of a read; thus we don&#39;t need to worry about the fact that they may use a finite number of bits *)</span>

  <span class="kw">type</span> off_t = <span class="dt">int</span> <span class="co">(*o with sexp o*)</span> <span class="co">(* singed integer type; FIXME cross reference this with posix *)</span>

  <span class="kw">type</span> float_t = <span class="dt">Float</span> <span class="kw">of</span> nat <span class="co">(*o with sexp o*)</span> <span class="co">(* FIXME *)</span>


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* cstring                       *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">type</span> cstring = <span class="dt">CS_Null</span> | <span class="dt">CS_Some</span> <span class="kw">of</span> <span class="dt">string</span> <span class="co">(*o with sexp o*)</span>

  <span class="kw">val</span> string_of_cstring : cstring -&gt; <span class="dt">string</span>
  <span class="kw">let</span> string_of_cstring cs = <span class="kw">match</span> cs <span class="kw">with</span>
    | <span class="dt">CS_Null</span> -&gt; <span class="st">&quot;&quot;</span> <span class="co">(* coverage:unused *)</span>
    | <span class="dt">CS_Some</span> s -&gt; s <span class="co">(* coverage:unused *)</span>
  <span class="kw">end</span>

  <span class="kw">val</span> bytes_of_cstring : cstring -&gt; ty_bytes
  <span class="kw">let</span> bytes_of_cstring cs = (<span class="kw">match</span> cs <span class="kw">with</span>
    | <span class="dt">CS_Null</span> -&gt; (T_list_array<span class="kw">.</span>of_string <span class="st">&quot;&quot;</span>)
    | <span class="dt">CS_Some</span> s -&gt; (T_list_array<span class="kw">.</span>of_string s) 
  end)

  <span class="kw">val</span> cstring_of_bytes : ty_bytes -&gt; cstring
  <span class="kw">let</span> cstring_of_bytes bs = (<span class="dt">CS_Some</span> (T_list_array<span class="kw">.</span>to_string bs))

  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* File descriptors, per process *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">type</span> ty_fd = <span class="dt">FD</span> <span class="kw">of</span> nat <span class="co">(*o with sexp o*)</span>
  <span class="kw">let</span> ty_fd_compare (<span class="dt">FD</span> n0) (<span class="dt">FD</span> n1) = compare n0 n1

  instance ( <span class="dt">SetType</span> ty_fd ) 
    <span class="kw">let</span> setElemCompare = ty_fd_compare
  end

  <span class="kw">val</span> dest_FD : ty_fd -&gt; nat
  <span class="kw">let</span> dest_FD x = (<span class="kw">match</span> x <span class="kw">with</span> <span class="dt">FD</span> n -&gt; n end)


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* directory handles, per process*)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">type</span> ty_dh = <span class="dt">DH</span> <span class="kw">of</span> nat <span class="co">(*o with sexp o*)</span>
  <span class="kw">let</span> ty_dh_compare (<span class="dt">DH</span> n0) (<span class="dt">DH</span> n1) = compare n0 n1
  instance ( <span class="dt">SetType</span> ty_dh ) 
    <span class="kw">let</span> setElemCompare = ty_dh_compare
  end

  <span class="kw">val</span> dest_DH : ty_dh -&gt; nat
  <span class="kw">let</span> dest_DH x = (<span class="kw">match</span> x <span class="kw">with</span> <span class="dt">DH</span> n -&gt; n end)


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Inodes                        *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">type</span> inode = <span class="dt">Inode</span> <span class="kw">of</span> nat <span class="co">(*o with sexp o*)</span>
  <span class="kw">let</span> inode_compare (<span class="dt">Inode</span> n0) (<span class="dt">Inode</span> n1) = compare n0 n1

  instance ( <span class="dt">SetType</span> inode ) 
    <span class="kw">let</span> setElemCompare = inode_compare
  end

  <span class="kw">val</span> dest_Inode : inode -&gt; nat
  <span class="kw">let</span> dest_Inode x = (<span class="kw">match</span> x <span class="kw">with</span> <span class="dt">Inode</span> n -&gt; n end)


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Errors                        *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* the following note discusses modeling of errors: posix/base_definitions/errno.h.txt *)</span>
  <span class="kw">type</span> error =
      <span class="dt">E2BIG</span>
    | <span class="dt">EACCES</span>
    | <span class="dt">EAGAIN</span>
    | <span class="dt">EBADF</span>
    | <span class="dt">EBUSY</span>
    | <span class="dt">ECHILD</span>
    | <span class="dt">EDEADLK</span>
    | <span class="dt">EDOM</span>
    | <span class="dt">EEXIST</span>
    | <span class="dt">EFAULT</span>
    | <span class="dt">EFBIG</span>
    | <span class="dt">EINTR</span>
    | <span class="dt">EINVAL</span>
    | <span class="dt">EIO</span>
    | <span class="dt">EISDIR</span>
    | <span class="dt">EMFILE</span>
    | <span class="dt">EMLINK</span>
    | <span class="dt">ENAMETOOLONG</span>
    | <span class="dt">ENFILE</span>
    | <span class="dt">ENODEV</span>
    | <span class="dt">ENOENT</span>
    | <span class="dt">ENOEXEC</span>
    | <span class="dt">ENOLCK</span>
    | <span class="dt">ENOMEM</span>
    | <span class="dt">ENOSPC</span>
    | <span class="dt">ENOSYS</span>
    | <span class="dt">ENOTDIR</span>
    | <span class="dt">ENOTEMPTY</span>
    | <span class="dt">ENOTTY</span>
    | <span class="dt">ENXIO</span>
    | <span class="dt">EPERM</span>
    | <span class="dt">EPIPE</span>
    | <span class="dt">ERANGE</span>
    | <span class="dt">EROFS</span>
    | <span class="dt">ESPIPE</span>
    | <span class="dt">ESRCH</span>
    | <span class="dt">EXDEV</span>
    | <span class="dt">EWOULDBLOCK</span>
    | <span class="dt">EINPROGRESS</span>
    | <span class="dt">EALREADY</span>
    | <span class="dt">ENOTSOCK</span>
    | <span class="dt">EDESTADDRREQ</span>
    | <span class="dt">EMSGSIZE</span>
    | <span class="dt">EPROTOTYPE</span>
    | <span class="dt">ENOPROTOOPT</span>
    | <span class="dt">EPROTONOSUPPORT</span>
    | <span class="dt">ESOCKTNOSUPPORT</span>
    | <span class="dt">EOPNOTSUPP</span>
    | <span class="dt">EPFNOSUPPORT</span>
    | <span class="dt">EAFNOSUPPORT</span>
    | <span class="dt">EADDRINUSE</span>
    | <span class="dt">EADDRNOTAVAIL</span>
    | <span class="dt">ENETDOWN</span>
    | <span class="dt">ENETUNREACH</span>
    | <span class="dt">ENETRESET</span>
    | <span class="dt">ECONNABORTED</span>
    | <span class="dt">ECONNRESET</span>
    | <span class="dt">ENOBUFS</span>
    | <span class="dt">EISCONN</span>
    | <span class="dt">ENOTCONN</span>
    | <span class="dt">ESHUTDOWN</span>
    | <span class="dt">ETOOMANYREFS</span>
    | <span class="dt">ETIMEDOUT</span>
    | <span class="dt">ECONNREFUSED</span>
    | <span class="dt">EHOSTDOWN</span>
    | <span class="dt">EHOSTUNREACH</span>
    | <span class="dt">ELOOP</span>
    | <span class="dt">EOVERFLOW</span>
    | <span class="dt">EUNKNOWNERR</span> <span class="kw">of</span> <span class="dt">int</span> <span class="co">(*o with sexp o*)</span>

  instance (<span class="dt">Eq</span> error)
    <span class="kw">let</span> (=) = unsafe_structural_equality
    <span class="kw">let</span> (&lt;&gt;) = unsafe_structural_inequality
  end


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Errors or Values              *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">type</span> error_or_value &#39;a = <span class="dt">Error</span> <span class="kw">of</span> error | <span class="dt">Value</span> <span class="kw">of</span> &#39;a <span class="co">(*o with sexp o*)</span>

  <span class="kw">val</span> error_or_valueEqual : forall &#39;a. <span class="dt">Eq</span> &#39;a =&gt; error_or_value &#39;a -&gt; error_or_value &#39;a -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> error_or_valueEqual eov1 eov2 = (<span class="kw">match</span> (eov1, eov2) <span class="kw">with</span>
    | (<span class="dt">Error</span> e1, <span class="dt">Error</span> e2) -&gt; (e1 = e2)
    | (<span class="dt">Value</span> v1, <span class="dt">Value</span> v2) -&gt; (v1 = v2)
    | (_, _) -&gt; <span class="kw">false</span> <span class="co">(* coverage:fixme -this case is covered only if the checker finds discrepancies with the posix results *)</span>
  end)
  <span class="kw">let</span> inline {hol;isabelle} error_or_valueEqual = unsafe_structural_equality

  instance forall &#39;a. <span class="dt">Eq</span> &#39;a =&gt; (<span class="dt">Eq</span> (error_or_value &#39;a))
    <span class="kw">let</span> (=) = error_or_valueEqual
    <span class="kw">let</span> (&lt;&gt;) x y = not (error_or_valueEqual x y)
  end

  <span class="kw">val</span> is_Error : forall &#39;a. error_or_value &#39;a -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> is_Error x = (<span class="kw">match</span> x <span class="kw">with</span> | <span class="dt">Error</span> _ -&gt; <span class="kw">true</span> | _ -&gt; <span class="kw">false</span> end)

  <span class="kw">val</span> is_Value : forall &#39;a. error_or_value &#39;a -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> is_Value x = (<span class="kw">match</span> x <span class="kw">with</span> | <span class="dt">Value</span> _ -&gt; <span class="kw">true</span> | _ -&gt; <span class="kw">false</span> end)


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Open flags                    *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">type</span> int_open_flags = int32 <span class="co">(*o with sexp o*)</span>

  <span class="co">(* from unix.mli *)</span>
  <span class="co">(* FIXME extend these to use open flags listed here http://pubs.opengroup.org/onlinepubs/9699919799/ *)</span>
  <span class="kw">type</span> open_flag =
    | <span class="dt">O_EXEC</span>
    | <span class="dt">O_RDONLY</span>                    <span class="co">(** Open for reading *)</span>
    | <span class="dt">O_RDWR</span>                      <span class="co">(** Open for reading and writing *)</span>
    | <span class="dt">O_SEARCH</span>
    | <span class="dt">O_WRONLY</span>                    <span class="co">(** Open for writing *)</span>
    | <span class="dt">O_APPEND</span>                    <span class="co">(** Open for append *)</span>
    | <span class="dt">O_CLOEXEC</span>
    | <span class="dt">O_CREAT</span>                     <span class="co">(** Create if nonexistent *)</span>
    | <span class="dt">O_DIRECTORY</span>
    | <span class="dt">O_DSYNC</span>                     <span class="co">(** Writes complete as Synchronised I/O data integrity completion *)</span>
    | <span class="dt">O_EXCL</span>                      <span class="co">(** Fail if existing *)</span>
    | <span class="dt">O_NOCTTY</span>                    <span class="co">(** Don&#39;t make this dev a controlling tty *)</span>
    | <span class="dt">O_NOFOLLOW</span>
    | <span class="dt">O_NONBLOCK</span>                  <span class="co">(** Open in non-blocking mode *)</span>
    | <span class="dt">O_RSYNC</span>                     <span class="co">(** Reads complete as writes (depending on</span>
<span class="co">                                      O_SYNC/O_DSYNC) *)</span>
    | <span class="dt">O_SYNC</span>                      <span class="co">(** Writes complete as Synchronised I/O file</span>
<span class="co">                                      integrity completion *)</span>
    | <span class="dt">O_TRUNC</span>                     <span class="co">(** Truncate to 0 length if existing *)</span>
    | <span class="dt">O_TTY_INIT</span> <span class="co">(*o with sexp_of o*)</span>

  instance (<span class="dt">Eq</span> open_flag)
    <span class="kw">let</span> (=) = unsafe_structural_equality
    <span class="kw">let</span> (&lt;&gt;) = unsafe_structural_inequality
  end

  <span class="co">(* N.B. this should be the complete set of flags *)</span>
  <span class="kw">val</span> open_flags : finset open_flag
  <span class="kw">let</span> open_flags = (finset_from_list [
    <span class="dt">O_EXEC</span>;
    <span class="dt">O_RDONLY</span>;
    <span class="dt">O_RDWR</span>;
    <span class="dt">O_SEARCH</span>;
    <span class="dt">O_WRONLY</span>;
    <span class="dt">O_APPEND</span>;
    <span class="dt">O_CLOEXEC</span>;
    <span class="dt">O_CREAT</span>;
    <span class="dt">O_DIRECTORY</span>;
    <span class="dt">O_DSYNC</span>;
    <span class="dt">O_EXCL</span>;
    <span class="dt">O_NOCTTY</span>;
    <span class="dt">O_NOFOLLOW</span>;
    <span class="dt">O_NONBLOCK</span>;
    <span class="dt">O_RSYNC</span>;
    <span class="dt">O_SYNC</span>;
    <span class="dt">O_TRUNC</span>;
    <span class="dt">O_TTY_INIT</span>;
  ])

  <span class="co">(* a subset of the flags; exactly one must be provided for an open call *)</span>
  <span class="kw">val</span> access_mode_flags : finset open_flag
  <span class="kw">let</span> access_mode_flags = (finset_from_list [<span class="dt">O_EXEC</span>;<span class="dt">O_RDONLY</span>;<span class="dt">O_RDWR</span>;<span class="dt">O_SEARCH</span>;<span class="dt">O_WRONLY</span>])

  <span class="co">(* [open_flag_set_access_mode_ok] checks that a finite set of</span>
<span class="co">     open-flags contains exactly one access-mode flag *)</span>
  <span class="kw">val</span> open_flag_set_access_mode_ok : finset open_flag -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> open_flag_set_access_mode_ok oflags = <span class="co">(* coverage:linux:irrelevant *)</span>
    <span class="kw">let</span> acc_flgs = finset_filter (<span class="kw">fun</span> flag -&gt; finset_mem flag access_mode_flags) oflags <span class="kw">in</span> <span class="co">(* coverage:linux:irrelevant *)</span>
    finset_size acc_flgs = <span class="dv">1</span> <span class="co">(* coverage:linux:irrelevant *)</span>


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* File permissions              *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">type</span> file_perm = <span class="dt">File_perm</span> <span class="kw">of</span> int32 <span class="co">(*o with sexp o*)</span> <span class="co">(* TODO: actually only 12 bit, perhaps change *)</span>

  <span class="kw">val</span> dest_file_perm : file_perm -&gt; int32
  <span class="kw">let</span> dest_file_perm (<span class="dt">File_perm</span> p) = p


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Seek commands for lseek       *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">type</span> int_seek_command = <span class="dt">int</span> <span class="co">(*o with sexp o*)</span>

  <span class="co">(* from unix.mli *)</span>
  <span class="kw">type</span> seek_command =
      <span class="dt">SEEK_SET</span> <span class="co">(** indicates positions relative to the beginning of the file *)</span>
    | <span class="dt">SEEK_CUR</span> <span class="co">(** indicates positions relative to the current position *)</span>
    | <span class="dt">SEEK_END</span> <span class="co">(** indicates positions relative to the end of the file *)</span>
    | <span class="dt">SEEK_DATA</span> <span class="co">(** indicates positions relative to the current position that contain data *)</span>
    | <span class="dt">SEEK_HOLE</span> <span class="co">(*o with sexp_of o*)</span> <span class="co">(** indicates positions relative to the current positions that do not contain data *)</span>

  instance (<span class="dt">Eq</span> seek_command)
    <span class="kw">let</span> (=) = unsafe_structural_equality
    <span class="kw">let</span> (&lt;&gt;) = unsafe_structural_inequality
  end


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Kinds of files                *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">type</span> file_kind = 
    <span class="dt">S_IFBLK</span>  <span class="co">(* block special *)</span>     <span class="co">(* not handled in this spec *)</span>
  | <span class="dt">S_IFCHR</span>  <span class="co">(* character special *)</span> <span class="co">(* not handled in this spec *)</span>
  | <span class="dt">S_IFIFO</span>  <span class="co">(* FIFO special *)</span>      <span class="co">(* not handled in this spec *)</span>
  | <span class="dt">S_IFREG</span>  <span class="co">(* regular *)</span>
  | <span class="dt">S_IFDIR</span>  <span class="co">(* directory *)</span>
  | <span class="dt">S_IFLNK</span>  <span class="co">(* symbolic link *)</span>
  | <span class="dt">S_IFSOCK</span> <span class="co">(*o with sexp o*)</span> <span class="co">(* socket *)</span>            <span class="co">(* not handled in this spec *)</span>

  instance (<span class="dt">Eq</span> file_kind)
    <span class="kw">let</span> (=) = unsafe_structural_equality
    <span class="kw">let</span> (&lt;&gt;) = unsafe_structural_inequality
  end

  
  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* User and group ids            *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">type</span> uid = <span class="dt">User_id</span> <span class="kw">of</span> nat <span class="co">(*o with sexp o*)</span>
  <span class="kw">let</span> uid_compare (<span class="dt">User_id</span> n0) (<span class="dt">User_id</span> n1) = compare n0 n1 <span class="co">(* coverage:unused *)</span>
  instance ( <span class="dt">SetType</span> uid ) 
    <span class="kw">let</span> setElemCompare = uid_compare
  end
  instance (<span class="dt">Eq</span> uid)
    <span class="kw">let</span> (=) = unsafe_structural_equality
    <span class="kw">let</span> (&lt;&gt;) = unsafe_structural_inequality
  end
  <span class="kw">let</span> root_uid : uid = <span class="dt">User_id</span> <span class="dv">0</span> 

  <span class="kw">type</span> gid = <span class="dt">Group_id</span> <span class="kw">of</span> nat <span class="co">(*o with sexp o*)</span>
  <span class="kw">let</span> gid_compare (<span class="dt">Group_id</span> n0) (<span class="dt">Group_id</span> n1) = compare n0 n1
  instance ( <span class="dt">SetType</span> gid ) 
    <span class="kw">let</span> setElemCompare = gid_compare
  end

  <span class="kw">let</span> root_gid : gid = <span class="dt">Group_id</span> <span class="dv">0</span>


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* result record for stat        *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* from ocaml source unix.mli *)</span>
  <span class="kw">type</span> ty_stats = 
      &lt;| st_dev : <span class="dt">int</span>;               <span class="co">(** Device number *)</span>
         st_ino : inode;             <span class="co">(** Inode number *)</span>
         st_kind : file_kind;        <span class="co">(** Kind of the file *)</span>
         st_perm : file_perm;        <span class="co">(** Access rights *)</span>
         st_nlink : <span class="dt">int</span>;             <span class="co">(** Number of links *)</span>
         st_uid : uid;               <span class="co">(** User id of the owner *)</span>
         st_gid : gid;               <span class="co">(** Group ID of the file&#39;s group *)</span>
         st_rdev : <span class="dt">int</span>;              <span class="co">(** Device minor number *)</span>
         st_size : int64;            <span class="co">(** Size in bytes; no sensible meaning for directories *)</span>
         st_atime : float_t;           <span class="co">(** Last access time *)</span>
         st_mtime : float_t;           <span class="co">(** Last modification time *)</span>
         st_ctime : float_t;           <span class="co">(** Last status change time *)</span>
      |&gt; <span class="co">(*o with sexp o*)</span>


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Return values                 *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">type</span> ret_value = 
      <span class="dt">RV_none</span> 
    | <span class="dt">RV_num</span> <span class="kw">of</span> nat <span class="co">(* FIXME int? or change constructor name*)</span> 
    | <span class="dt">RV_bytes</span> <span class="kw">of</span> ty_bytes <span class="co">(* FIXME add init return type *)</span> 
    | <span class="dt">RV_names</span> <span class="kw">of</span> <span class="dt">list</span> name
    | <span class="dt">RV_stats</span> <span class="kw">of</span> ty_stats 
    | <span class="dt">RV_file_perm</span> <span class="kw">of</span> file_perm <span class="co">(*o with sexp o*)</span>

  instance (<span class="dt">Eq</span> ret_value)
    <span class="kw">let</span> (=) = unsafe_structural_equality
    <span class="kw">let</span> (&lt;&gt;) = unsafe_structural_inequality
  end

  <span class="kw">val</span> dest_RV_bytes : ret_value -&gt; ty_bytes
  <span class="kw">let</span> dest_RV_bytes (<span class="dt">RV_bytes</span> bs) = bs

  <span class="co">(* a dummy value, that is expected to never matter *)</span>
  <span class="kw">val</span> dummy_return_value : ret_value
  <span class="kw">let</span> dummy_return_value = <span class="dt">RV_none</span>  


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Entries                       *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* We want to distinguish explicitly between directories and other files. Posix uses inodes</span>
<span class="co">     to point to these. Here we use abstract dir_ref for directories and file_refs for all</span>
<span class="co">     other files. Notice, that the Posix standard considers a directory to be a special file. </span>
<span class="co">     In the following we differ from that notation. *)</span>     
  <span class="kw">type</span> entry &#39;dir_ref &#39;file_ref = <span class="dt">Dir_ref_entry</span> <span class="kw">of</span> &#39;dir_ref | <span class="dt">File_ref_entry</span> <span class="kw">of</span> &#39;file_ref <span class="co">(*o with sexp_of o*)</span>

  <span class="kw">val</span> is_dir_ref_entry : forall &#39;dir_ref &#39;file_ref. entry &#39;dir_ref &#39;file_ref -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> is_dir_ref_entry e =
    <span class="kw">match</span> e <span class="kw">with</span>
    | <span class="dt">Dir_ref_entry</span> _ -&gt; <span class="kw">true</span> <span class="co">(* coverage:impossible -is_dir_ref_entry is only used in pwrite, and the case in which this is called on a directory is impossoble *)</span>
    | <span class="dt">File_ref_entry</span> _ -&gt; <span class="kw">false</span> end

  <span class="kw">val</span> is_file_ref_entry : forall &#39;dir_ref &#39;file_ref. entry &#39;dir_ref &#39;file_ref -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> is_file_ref_entry e =
    <span class="kw">match</span> e <span class="kw">with</span>
    | <span class="dt">Dir_ref_entry</span> _ -&gt; <span class="kw">false</span> <span class="co">(* coverage:unused *)</span>
    | <span class="dt">File_ref_entry</span> _ -&gt; <span class="kw">true</span> end <span class="co">(* coverage:unused *)</span>

  <span class="kw">val</span> dest_dir_ref_entry : forall &#39;dir_ref &#39;file_ref. entry &#39;dir_ref &#39;file_ref -&gt; &#39;dir_ref
  <span class="kw">let</span> dest_dir_ref_entry (<span class="dt">Dir_ref_entry</span> dr) = dr <span class="co">(* coverage:unused *)</span>

  <span class="kw">val</span> dest_file_ref_entry : forall &#39;dir_ref &#39;file_ref. entry &#39;dir_ref &#39;file_ref -&gt; &#39;file_ref
  <span class="kw">let</span> dest_file_ref_entry (<span class="dt">File_ref_entry</span> ir) = ir <span class="co">(* coverage:unused *)</span>


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Non empty lists of names      *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* A non-empty list of names. </span>
<span class="co">     From split_path_string, the following appears to hold: </span>
<span class="co">     &quot;/&quot; ~ Name_list(&quot;&quot;,[&quot;&quot;]); </span>
<span class="co">     &quot;&quot; ~ Name_list(&quot;&quot;,[]) </span>
<span class="co">  *)</span>
  <span class="kw">type</span> ty_name_list = <span class="dt">Name_list</span> <span class="kw">of</span> (name * <span class="dt">list</span> name) <span class="co">(*o with sexp_of o*)</span>

  <span class="kw">val</span> ty_name_list_to_list : ty_name_list -&gt; <span class="dt">list</span> name
  <span class="kw">let</span> ty_name_list_to_list (tnl : ty_name_list) : <span class="dt">list</span> name =
    <span class="kw">match</span> tnl <span class="kw">with</span>
     | <span class="dt">Name_list</span> (n, nl) -&gt; n :: nl 
    end

  <span class="co">(* invariant nl not empty *)</span>
  <span class="kw">val</span> make_ty_name_list : <span class="dt">list</span> name -&gt; ty_name_list
  <span class="kw">let</span> make_ty_name_list (nl : <span class="dt">list</span> name) : ty_name_list = 
    <span class="kw">match</span> nl <span class="kw">with</span>
      | [] -&gt; failwith <span class="st">&quot;invariant name&lt;&gt; [] broken&quot;</span> <span class="co">(* coverage:impossible *)</span>
      | (n :: nl&#39;) -&gt; <span class="dt">Name_list</span> (n, nl&#39;)
    end

  <span class="co">(* let nl_ends_with_slash nl = (last nl = &quot;&quot;) *)</span>
  <span class="kw">val</span> nl_starts_with_slash : ty_name_list -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> nl_starts_with_slash nl = (<span class="kw">match</span> nl <span class="kw">with</span>
    | <span class="dt">Name_list</span> (<span class="st">&quot;&quot;</span>,[]) -&gt; <span class="kw">false</span>
    | <span class="dt">Name_list</span> (x, _) -&gt; (x = <span class="st">&quot;&quot;</span>)
  end)

  <span class="kw">val</span> nl_only_slash : ty_name_list -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> nl_only_slash nl = (<span class="kw">match</span> nl <span class="kw">with</span>
    | <span class="dt">Name_list</span> (<span class="st">&quot;&quot;</span>, [<span class="st">&quot;&quot;</span>]) -&gt; (<span class="kw">true</span>)  <span class="co">(* coverage:unused *)</span>
    | _ -&gt; <span class="kw">false</span>  <span class="co">(* coverage:unused *)</span>
  end)

  <span class="kw">val</span> name_list_ends_with_slash : <span class="dt">list</span> name -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> name_list_ends_with_slash (nl : <span class="dt">list</span> name) : <span class="dt">bool</span> = (nl &lt;&gt; [<span class="st">&quot;&quot;</span>] &amp;&amp; last nl = <span class="st">&quot;&quot;</span>)


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Predicates for paths seen as  *)</span>
  <span class="co">(* lists of names                *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* check whether a path is an absolute one by counting the number of slashes stripped *)</span>
  <span class="kw">let</span> <span class="kw">rec</span> is_absolute_path_aux (c : nat) p =
  <span class="kw">match</span> p <span class="kw">with</span>
    | (<span class="st">&quot;&quot;</span> :: ns) -&gt; is_absolute_path_aux (c+<span class="dv">1</span>) ns  <span class="co">(* coverage:unused *)</span>
    | _ -&gt; (c &gt; <span class="dv">0</span>) &amp;&amp; not (c = <span class="dv">2</span>) <span class="co">(* coverage:unused *)</span>
  end
  declare termination_argument is_absolute_path_aux = automatic

  <span class="kw">val</span> is_absolute_path : <span class="dt">list</span> name -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> is_absolute_path p = is_absolute_path_aux <span class="dv">0</span> p <span class="co">(* coverage:unused *)</span>

  <span class="kw">val</span> is_root_path : <span class="dt">list</span> name -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> is_root_path p = ((List<span class="kw">.</span>all (<span class="kw">fun</span> n -&gt; (n = <span class="st">&quot;&quot;</span>)) p) &amp;&amp; (List<span class="kw">.</span>length p &gt; <span class="dv">0</span>) &amp;&amp; (not (List<span class="kw">.</span>length p = <span class="dv">2</span>))) <span class="co">(* coverage:unused *)</span>

  <span class="kw">val</span> is_simple_path : <span class="dt">list</span> name -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> is_simple_path p = List<span class="kw">.</span>all (<span class="kw">fun</span> n -&gt; not ((n = <span class="st">&quot;&quot;</span>) || (n = <span class="st">&quot;.&quot;</span>) || (n = <span class="st">&quot;..&quot;</span>))) p <span class="co">(* coverage:unused *)</span>

  <span class="co">(* check that a path is a simple, absolute path. It is so, if it starts with a _single_ slash and containing no</span>
<span class="co">     &quot;.&quot;, &quot;..&quot; or &quot;//&quot;. *)</span>
  <span class="kw">val</span> is_simple_absolute_path : <span class="dt">list</span> name -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> is_simple_absolute_path p =
    (<span class="kw">match</span> p <span class="kw">with</span>
      | (<span class="st">&quot;&quot;</span> :: ns) -&gt; is_simple_path ns <span class="co">(* coverage:unused *)</span>
      | _ -&gt; <span class="kw">false</span> <span class="co">(* coverage:unused *)</span>
    end)


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Results of path resolution    *)</span>
  <span class="co">(* (real paths)                  *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* store the result of processing a path in a record, we then have a type encoding either</span>
<span class="co">     successful name resolution or an error *)</span>
  <span class="kw">type</span> ty_realpath_rec &#39;dir_ref = &lt;|
    rp_cwd: &#39;dir_ref;    <span class="co">(* cwd for process *)</span>
    rp_nl: ty_name_list; <span class="co">(* the original input for resolution *)</span>
    rp_ns: <span class="dt">list</span> name;    <span class="co">(* the realpath of the entry, this is a simple, absolute path, i.e.</span>
<span class="co">         not []; not [&quot;&quot;]; [&quot;&quot;;&quot;&quot;] ~ &quot;/&quot;; first entry is empty; no . and .. entries; no further empty entries (absolute paths) *)</span>
  |&gt; <span class="co">(*o with sexp_of o*)</span>
  <span class="kw">type</span> ty_realpath &#39;dir_ref &#39;file_ref = <span class="dt">RP_ok</span> <span class="kw">of</span> ty_realpath_rec &#39;dir_ref | <span class="dt">RP_err</span> <span class="kw">of</span> (error * ty_name_list) <span class="co">(*o with sexp_of o*)</span>
    
  <span class="kw">val</span> wf_ty_realpath_rec : forall &#39;dir_ref. ty_realpath_rec &#39;dir_ref -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> wf_ty_realpath_rec rp = is_simple_absolute_path rp.rp_ns <span class="co">(* coverage:unused *)</span>

  <span class="co">(* check wellformedness of ty_realpath *)</span>
  <span class="kw">val</span> wf_ty_realpath : forall &#39;dir_ref &#39;file_ref. ty_realpath &#39;dir_ref &#39;file_ref -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> wf_ty_realpath rp = <span class="kw">match</span> rp <span class="kw">with</span>
    | <span class="dt">RP_ok</span> rp&#39; -&gt; wf_ty_realpath_rec rp&#39; <span class="co">(* coverage:unused *)</span>
    | <span class="dt">RP_err</span> _ -&gt; <span class="kw">true</span> <span class="co">(* coverage:unused *)</span>
  end
                   
  <span class="kw">val</span> realpath_proper_subdir : forall &#39;dir_ref. ty_realpath_rec &#39;dir_ref -&gt; ty_realpath_rec &#39;dir_ref -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> realpath_proper_subdir s d = 
    s.rp_ns &lt;&gt; d.rp_ns 
    &amp;&amp; (<span class="kw">match</span> s.rp_ns <span class="kw">with</span>
        | [<span class="st">&quot;&quot;</span>;<span class="st">&quot;&quot;</span>] -&gt; <span class="kw">true</span>  <span class="co">(* special case for root *)</span>
        | _ -&gt; isPrefixOf s.rp_ns d.rp_ns end)


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Resolved names                *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">type</span> rn_error_extra &#39;dir_ref &#39;file_ref = &lt;|
    re_cwd: &#39;dir_ref;
    re_nl: maybe ty_name_list; <span class="co">(* the name list that was being resolved, needed for raising errors with respect to trailing slashes *)</span>
    re_rn: maybe (res_name &#39;dir_ref &#39;file_ref) <span class="co">(* the resolved name (an RN_file) if we ignore trailing slashes *)</span>
  |&gt; 

  <span class="kw">and</span> res_name &#39;dir_ref &#39;file_ref  = 
    <span class="dt">RN_dir</span> <span class="kw">of</span> (&#39;dir_ref * ty_realpath_rec &#39;dir_ref )  <span class="co">(* rp used for subdir check *)</span>
  | <span class="dt">RN_file</span> <span class="kw">of</span> (&#39;dir_ref * name * &#39;file_ref * ty_realpath_rec &#39;dir_ref)
  | <span class="dt">RN_none</span> <span class="kw">of</span> (&#39;dir_ref * name * ty_realpath_rec &#39;dir_ref)
  | <span class="dt">RN_error</span> <span class="kw">of</span> (error * rn_error_extra &#39;dir_ref &#39;file_ref) 
  <span class="co">(*o with sexp_of o*)</span> 
  <span class="co">(* invariant: if RN_file ns, then not (ns.ends_with_slash2) *)</span>
  <span class="co">(* invariant: if RN_error then ns.ends_with_slash2 TT: I don&#39;t understand this invariant. Does it really hold?*)</span>
  <span class="co">(* invariant: iff RN_error (_, {re_nl=Just nl, re_rn=Just X}) then X = RN_file and nl ends in slash *)</span>

  <span class="kw">val</span> is_RN_dir  : forall &#39;dir_ref &#39;file_ref. res_name &#39;dir_ref &#39;file_ref -&gt; <span class="dt">bool</span>
  <span class="kw">val</span> is_RN_file : forall &#39;dir_ref &#39;file_ref. res_name &#39;dir_ref &#39;file_ref -&gt; <span class="dt">bool</span>
  <span class="kw">val</span> is_RN_none     : forall &#39;dir_ref &#39;file_ref. res_name &#39;dir_ref &#39;file_ref -&gt; <span class="dt">bool</span>
  <span class="kw">val</span> is_RN_error    : forall &#39;dir_ref &#39;file_ref. res_name &#39;dir_ref &#39;file_ref -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> is_RN_dir  x = (<span class="kw">match</span> x <span class="kw">with</span> | <span class="dt">RN_dir</span>  _ -&gt; <span class="kw">true</span> | _ -&gt; <span class="kw">false</span> end)
  <span class="kw">let</span> is_RN_file x = (<span class="kw">match</span> x <span class="kw">with</span> | <span class="dt">RN_file</span> _ -&gt; <span class="kw">true</span> | _ -&gt; <span class="kw">false</span> end)
  <span class="kw">let</span> is_RN_none     x = (<span class="kw">match</span> x <span class="kw">with</span> | <span class="dt">RN_none</span>     _ -&gt; <span class="kw">true</span> | _ -&gt; <span class="kw">false</span> end)
  <span class="kw">let</span> is_RN_error    x = (<span class="kw">match</span> x <span class="kw">with</span> | <span class="dt">RN_error</span>    _ -&gt; <span class="kw">true</span> | _ -&gt; <span class="kw">false</span> end)

  <span class="co">(* check wellformedness of res_name *)</span>
  <span class="kw">val</span> wf_res_name : forall &#39;dir_ref &#39;file_ref. res_name &#39;dir_ref &#39;file_ref -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> wf_res_name rn = <span class="kw">match</span> rn <span class="kw">with</span>
    <span class="dt">RN_dir</span> (_, rp) -&gt; wf_ty_realpath_rec rp <span class="co">(* coverage:unused *)</span>
  | <span class="dt">RN_file</span> (_, _, _, rp) -&gt; wf_ty_realpath_rec rp &amp;&amp; (not (name_list_ends_with_slash rp.rp_ns)) <span class="co">(* coverage:unused *)</span>
  | <span class="dt">RN_none</span> (_, _, rp) -&gt; wf_ty_realpath_rec rp <span class="co">(* coverage:unused *)</span>
  | <span class="dt">RN_error</span> (_, &lt;| re_nl=<span class="dt">Just</span> nl|&gt;) -&gt; (name_list_ends_with_slash (ty_name_list_to_list nl)) <span class="co">(* TT: and not the root directory ? *)</span> <span class="co">(* coverage:unused *)</span>
  | <span class="dt">RN_error</span> (_, &lt;| re_nl=<span class="dt">Nothing</span> |&gt;) -&gt; <span class="kw">true</span> <span class="co">(* coverage:unused *)</span>
  end

  <span class="kw">val</span> name_list_of_res_name : forall &#39;dir_ref &#39;file_ref. res_name &#39;dir_ref &#39;file_ref -&gt; maybe ty_name_list
  <span class="kw">let</span> name_list_of_res_name n = (<span class="kw">match</span> n <span class="kw">with</span> 
    | <span class="dt">RN_dir</span> (_,rp) -&gt; <span class="dt">Just</span> rp.rp_nl
    | <span class="dt">RN_file</span> (_,_,_,rp) -&gt; <span class="dt">Just</span> rp.rp_nl
    | <span class="dt">RN_none</span> (_,_,rp) -&gt; <span class="dt">Just</span> rp.rp_nl
    | <span class="dt">RN_error</span> (_,&lt;|re_nl=nl|&gt;) -&gt; nl
  end)

  <span class="kw">val</span> rn_ends_with_slash : forall &#39;dir_ref &#39;file_ref.
      res_name &#39;dir_ref &#39;file_ref -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> rn_ends_with_slash rn = (
    (<span class="kw">match</span> name_list_of_res_name rn <span class="kw">with</span> 
    | <span class="dt">Nothing</span> -&gt; <span class="kw">false</span> <span class="co">(* coverage:impossible -rn_ends_with_slash is never called on an RN_error, so this line is unreachable *)</span>
    | <span class="dt">Just</span> nl -&gt; (name_list_ends_with_slash (ty_name_list_to_list nl)) end))


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Sysconfig values              *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* see description of sysconf *)</span>
  <span class="kw">type</span> sysconf_value =
    | <span class="dt">SC_SYMLOOP_MAX</span> <span class="co">(*o with sexp_of o*)</span>
<span class="co">(* The following values are not used so far. They are commented out in order to keep track of</span>
<span class="co">   which values are actually used. </span>

<span class="co">    | SC_AIO_LISTIO_MAX</span>
<span class="co">    | SC_AIO_MAX</span>
<span class="co">    | SC_AIO_PRIO_DELTA_MAX</span>
<span class="co">    | SC_ARG_MAX</span>
<span class="co">    | SC_ATEXIT_MAX</span>
<span class="co">    | SC_BC_BASE_MAX</span>
<span class="co">    | SC_BC_DIM_MAX</span>
<span class="co">    | SC_BC_SCALE_MAX</span>
<span class="co">    | SC_BC_STRING_MAX</span>
<span class="co">    | SC_CHILD_MAX</span>
<span class="co">    | SC_CLK_TCK</span>
<span class="co">    | SC_COLL_WEIGHTS_MAX</span>
<span class="co">    | SC_DELAYTIMER_MAX</span>
<span class="co">    | SC_EXPR_NEST_MAX</span>
<span class="co">    | SC_HOST_NAME_MAX</span>
<span class="co">    | SC_IOV_MAX</span>
<span class="co">    | SC_LINE_MAX</span>
<span class="co">    | SC_LOGIN_NAME_MAX</span>
<span class="co">    | SC_NGROUPS_MAX</span>
<span class="co">    | SC_GETGR_R_SIZE_MAX</span>
<span class="co">    | SC_GETPW_R_SIZE_MAX</span>
<span class="co">    | SC_MQ_OPEN_MAX</span>
<span class="co">    | SC_MQ_PRIO_MAX</span>
<span class="co">    | SC_OPEN_MAX</span>
<span class="co">    | SC_ADVISORY_INFO</span>
<span class="co">    | SC_BARRIERS</span>
<span class="co">    | SC_ASYNCHRONOUS_IO</span>
<span class="co">    | SC_CLOCK_SELECTION</span>
<span class="co">    | SC_CPUTIME</span>
<span class="co">    | SC_FSYNC</span>
<span class="co">    | SC_IPV6</span>
<span class="co">    | SC_JOB_CONTROL</span>
<span class="co">    | SC_MAPPED_FILES</span>
<span class="co">    | SC_MEMLOCK</span>
<span class="co">    | SC_MEMLOCK_RANGE</span>
<span class="co">    | SC_MEMORY_PROTECTION</span>
<span class="co">    | SC_MESSAGE_PASSING</span>
<span class="co">    | SC_MONOTONIC_CLOCK</span>
<span class="co">    | SC_PRIORITIZED_IO</span>
<span class="co">    | SC_PRIORITY_SCHEDULING</span>
<span class="co">    | SC_RAW_SOCKETS</span>
<span class="co">    | SC_READER_WRITER_LOCKS</span>
<span class="co">    | SC_REALTIME_SIGNALS</span>
<span class="co">    | SC_REGEXP</span>
<span class="co">    | SC_SAVED_IDS</span>
<span class="co">    | SC_SEMAPHORES</span>
<span class="co">    | SC_SHARED_MEMORY_OBJECTS</span>
<span class="co">    | SC_SHELL</span>
<span class="co">    | SC_SPAWN</span>
<span class="co">    | SC_SPIN_LOCKS</span>
<span class="co">    | SC_SPORADIC_SERVER</span>
<span class="co">    | SC_SS_REPL_MAX</span>
<span class="co">    | SC_SYNCHRONIZED_IO</span>
<span class="co">    | SC_THREAD_ATTR_STACKADDR</span>
<span class="co">    | SC_THREAD_ATTR_STACKSIZE</span>
<span class="co">    | SC_THREAD_CPUTIME</span>
<span class="co">    | SC_THREAD_PRIO_INHERIT</span>
<span class="co">    | SC_THREAD_PRIO_PROTECT</span>
<span class="co">    | SC_THREAD_PRIORITY_SCHEDULING</span>
<span class="co">    | SC_THREAD_PROCESS_SHARED</span>
<span class="co">    | SC_THREAD_ROBUST_PRIO_INHERIT</span>
<span class="co">    | SC_THREAD_ROBUST_PRIO_PROTECT</span>
<span class="co">    | SC_THREAD_SAFE_FUNCTIONS</span>
<span class="co">    | SC_THREAD_SPORADIC_SERVER</span>
<span class="co">    | SC_THREADS</span>
<span class="co">    | SC_TIMEOUTS</span>
<span class="co">    | SC_TIMERS</span>
<span class="co">    | SC_TRACE</span>
<span class="co">    | SC_TRACE_EVENT_FILTER</span>
<span class="co">    | SC_TRACE_EVENT_NAME_MAX</span>
<span class="co">    | SC_TRACE_INHERIT</span>
<span class="co">    | SC_TRACE_LOG</span>
<span class="co">    | SC_TRACE_NAME_MAX</span>
<span class="co">    | SC_TRACE_SYS_MAX</span>
<span class="co">    | SC_TRACE_USER_EVENT_MAX</span>
<span class="co">    | SC_TYPED_MEMORY_OBJECTS</span>
<span class="co">    | SC_VERSION</span>
<span class="co">    | SC_V7_ILP32_OFF32</span>
<span class="co">    | SC_V7_ILP32_OFFBIG</span>
<span class="co">    | SC_V7_LP64_OFF64</span>
<span class="co">    | SC_V7_LPBIG_OFFBIG</span>
<span class="co">    | SC_V6_ILP32_OFF32</span>
<span class="co">    | SC_V6_ILP32_OFFBIG</span>
<span class="co">    | SC_V6_LP64_OFF64</span>
<span class="co">    | SC_V6_LPBIG_OFFBIG </span>
<span class="co">    | SC_2_C_BIND</span>
<span class="co">    | SC_2_C_DEV</span>
<span class="co">    | SC_2_CHAR_TERM</span>
<span class="co">    | SC_2_FORT_DEV</span>
<span class="co">    | SC_2_FORT_RUN</span>
<span class="co">    | SC_2_LOCALEDEF</span>
<span class="co">    | SC_2_PBS</span>
<span class="co">    | SC_2_PBS_ACCOUNTING</span>
<span class="co">    | SC_2_PBS_CHECKPOINT</span>
<span class="co">    | SC_2_PBS_LOCATE</span>
<span class="co">    | SC_2_PBS_MESSAGE</span>
<span class="co">    | SC_2_PBS_TRACK</span>
<span class="co">    | SC_2_SW_DEV</span>
<span class="co">    | SC_2_UPE</span>
<span class="co">    | SC_2_VERSION</span>
<span class="co">    | SC_PAGE_SIZE</span>
<span class="co">    | SC_PAGESIZE</span>
<span class="co">    | SC_THREAD_DESTRUCTOR_ITERATIONS</span>
<span class="co">    | SC_THREAD_KEYS_MAX</span>
<span class="co">    | SC_THREAD_STACK_MIN</span>
<span class="co">    | SC_THREAD_THREADS_MAX</span>
<span class="co">    | SC_RE_DUP_MAX</span>
<span class="co">    | SC_RTSIG_MAX</span>
<span class="co">    | SC_SEM_NSEMS_MAX</span>
<span class="co">    | SC_SEM_VALUE_MAX</span>
<span class="co">    | SC_SIGQUEUE_MAX</span>
<span class="co">    | SC_STREAM_MAX</span>
<span class="co">    | SC_TIMER_MAX</span>
<span class="co">    | SC_TTY_NAME_MAX</span>
<span class="co">    | SC_TZNAME_MAX</span>
<span class="co">    | SC_XOPEN_CRYPT</span>
<span class="co">    | SC_XOPEN_ENH_I18N</span>
<span class="co">    | SC_XOPEN_REALTIME</span>
<span class="co">    | SC_XOPEN_REALTIME_THREADS</span>
<span class="co">    | SC_XOPEN_SHM</span>
<span class="co">    | SC_XOPEN_STREAMS</span>
<span class="co">    | SC_XOPEN_UNIX</span>
<span class="co">    | SC_XOPEN_UUCP</span>
<span class="co">    | SC_XOPEN_VERSION</span>
<span class="co">*)</span>

  instance ( <span class="dt">SetType</span> sysconf_value ) 
    <span class="kw">let</span> setElemCompare = defaultCompare
  end

  <span class="co">(* Some default values. It is documented for each entry, where the</span>
<span class="co">     value comes from. If no other value could be found, I used the one</span>
<span class="co">     on my machine running Ubuntu 12.04 64 bit on x86. *)</span>
  <span class="kw">let</span> sysconf_default = <span class="kw">function</span>
     <span class="dt">SC_SYMLOOP_MAX</span> -&gt; (<span class="dv">40</span> : nat) <span class="co">(* Ubuntu has value unbound, but my filesystem complains after 40,</span>
<span class="co">       Posix demands a minimum of POSIX_SYMLOOP_MAX, which seems to be 8. *)</span>
  end


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* FS-commands                   *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* commands that do not mirror the original posix-commands,</span>
<span class="co">     but others, which might be useful for e.g. testing *)</span>
  <span class="kw">type</span> ty_fs_ext_command &#39;dir_ref &#39;file_ref = 
    | <span class="dt">FS_PREAD</span> <span class="kw">of</span> (res_name &#39;dir_ref &#39;file_ref * size_t * off_t) 
        <span class="co">(* reading and writing is supported by posix only at the OS level, since </span>
<span class="co">           file-descriptors are used. This version is a wrapper that uses resolved-names instead.</span>
<span class="co">           [FS_PREAD (entry, len, ofs)] tries to read [len] bytes from</span>
<span class="co">           entry [entry] at offset [ofs] (from beginning of file).</span>
<span class="co">        *)</span>        
    | <span class="dt">FS_PWRITE</span> <span class="kw">of</span> (res_name &#39;dir_ref &#39;file_ref * ty_bytes * size_t * off_t) 
        <span class="co">(* This is the write version of [FS_PREAD]. See above. *)</span>
    | <span class="dt">FS_OPEN_CLOSE</span> <span class="kw">of</span> (res_name &#39;dir_ref &#39;file_ref * int_open_flags * maybe file_perm) <span class="co">(*o with sexp_of o*)</span>
        <span class="co">(* operation at fs level - perform an open with side-effects and then discard any resulting info; </span>
<span class="co">           similar to an open followed by an immediate close on the fd at os level *)</span>


  <span class="co">(* this interface represents that part of the spec that makes sense</span>
<span class="co">     at the fs level (eg without file descriptors) *)</span>
  <span class="kw">type</span> ty_fs_command &#39;dir_ref &#39;file_ref = 
      <span class="dt">FS_LINK</span> <span class="kw">of</span> (res_name &#39;dir_ref &#39;file_ref * res_name &#39;dir_ref &#39;file_ref)
    | <span class="dt">FS_MKDIR</span> <span class="kw">of</span> (res_name &#39;dir_ref &#39;file_ref * file_perm)
    | <span class="dt">FS_READLINK</span> <span class="kw">of</span> res_name &#39;dir_ref &#39;file_ref
    | <span class="dt">FS_RENAME</span> <span class="kw">of</span> (res_name &#39;dir_ref &#39;file_ref * res_name &#39;dir_ref &#39;file_ref)
    | <span class="dt">FS_RMDIR</span> <span class="kw">of</span> res_name &#39;dir_ref &#39;file_ref
    | <span class="dt">FS_STAT</span> <span class="kw">of</span> res_name &#39;dir_ref &#39;file_ref
    | <span class="dt">FS_LSTAT</span> <span class="kw">of</span> res_name &#39;dir_ref &#39;file_ref
    | <span class="dt">FS_SYMLINK</span> <span class="kw">of</span> (ty_bytes * res_name &#39;dir_ref &#39;file_ref)
    | <span class="dt">FS_TRUNCATE</span> <span class="kw">of</span> (res_name &#39;dir_ref &#39;file_ref * off_t)
    | <span class="dt">FS_UNLINK</span> <span class="kw">of</span> res_name &#39;dir_ref &#39;file_ref
    | <span class="dt">FS_CHMOD</span> <span class="kw">of</span> (res_name &#39;dir_ref &#39;file_ref * file_perm)
    | <span class="dt">FS_CHOWN</span> <span class="kw">of</span> (res_name &#39;dir_ref &#39;file_ref * uid * gid)
    | <span class="dt">FS_EXTENDED_CMD</span> <span class="kw">of</span> ty_fs_ext_command &#39;dir_ref &#39;file_ref <span class="co">(*o with sexp_of o*)</span>


  <span class="kw">val</span> res_names_of_ty_fs_command : forall &#39;dir_ref &#39;file_ref. 
     ty_fs_command &#39;dir_ref &#39;file_ref -&gt; <span class="dt">list</span> (res_name &#39;dir_ref &#39;file_ref)
  <span class="kw">let</span> res_names_of_ty_fs_command cmd = (<span class="kw">match</span> cmd <span class="kw">with</span>
    | <span class="dt">FS_LINK</span> (s,d)                               -&gt; [s;d]  <span class="co">(* coverage:unused *)</span>
    | <span class="dt">FS_MKDIR</span> (s,p)                              -&gt; [s]  <span class="co">(* coverage:unused *)</span>
    | <span class="dt">FS_READLINK</span> p                               -&gt; [p]  <span class="co">(* coverage:unused *)</span>
    | <span class="dt">FS_RENAME</span> (s,d)                             -&gt; [s;d]  <span class="co">(* coverage:unused *)</span>
    | <span class="dt">FS_RMDIR</span> p                                  -&gt; [p]  <span class="co">(* coverage:unused *)</span>
    | <span class="dt">FS_STAT</span> p                                   -&gt; [p]  <span class="co">(* coverage:unused *)</span>
    | <span class="dt">FS_LSTAT</span> p                                  -&gt; [p]  <span class="co">(* coverage:unused *)</span>
    | <span class="dt">FS_SYMLINK</span> (s,d)                            -&gt; [d]  <span class="co">(* coverage:unused *)</span>
    | <span class="dt">FS_TRUNCATE</span> (p,l)                           -&gt; [p]  <span class="co">(* coverage:unused *)</span>
    | <span class="dt">FS_UNLINK</span> p                                 -&gt; [p]  <span class="co">(* coverage:unused *)</span>
    | <span class="dt">FS_CHMOD</span> (s, p)                             -&gt; [s]  <span class="co">(* coverage:unused *)</span>
    | <span class="dt">FS_CHOWN</span> (s, u, g)                          -&gt; [s]  <span class="co">(* coverage:unused *)</span>
    | <span class="dt">FS_EXTENDED_CMD</span> (<span class="dt">FS_OPEN_CLOSE</span> (p,fs,mo))   -&gt; [p]  <span class="co">(* coverage:unused *)</span>
    | <span class="dt">FS_EXTENDED_CMD</span> (<span class="dt">FS_PREAD</span> (p,len_,ofs))     -&gt; [p]  <span class="co">(* coverage:unused *)</span>
    | <span class="dt">FS_EXTENDED_CMD</span> (<span class="dt">FS_PWRITE</span> (p,bs,len_,ofs)) -&gt; [p]  <span class="co">(* coverage:unused *)</span>
  end)

  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* OS commands                   *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* an extended version of [ty_os_command]. It does not mirror the original posix-commands,</span>
<span class="co">     but slightly extended versions, which might be useful for e.g. testing *)</span>
  <span class="kw">type</span> ty_os_ext_command = 
    | <span class="dt">OS_OPEN_CLOSE</span> <span class="kw">of</span> (cstring * int_open_flags * maybe file_perm) <span class="co">(* see FS_OPEN_CLOSE *)</span>
    | <span class="dt">OS_ADD_USER_TO_GROUP</span> <span class="kw">of</span> (uid * gid)
    | <span class="dt">OS_DET_PREAD</span> <span class="kw">of</span> (ty_fd * size_t * off_t) <span class="co">(* deterministic version of pread *)</span>
    | <span class="dt">OS_DET_READ</span> <span class="kw">of</span> (ty_fd * size_t) <span class="co">(* deterministic version of read *)</span>
    | <span class="dt">OS_DET_PWRITE</span> <span class="kw">of</span> (ty_fd * ty_bytes * size_t * off_t) <span class="co">(* deterministic version of pwrite *)</span>
    | <span class="dt">OS_DET_WRITE</span> <span class="kw">of</span> (ty_fd * ty_bytes * size_t) <span class="co">(*o with sexp o*)</span> <span class="co">(* deterministic version of write *)</span>

  <span class="kw">val</span> paths_of_ty_os_ext_command : ty_os_ext_command -&gt; <span class="dt">list</span> cstring
  <span class="kw">let</span> paths_of_ty_os_ext_command cmd = (<span class="kw">match</span> cmd <span class="kw">with</span>
    | <span class="dt">OS_OPEN_CLOSE</span> (p,fs,mo) -&gt; [p]
    | <span class="dt">OS_ADD_USER_TO_GROUP</span> (u, g) -&gt; []
    | <span class="dt">OS_DET_PREAD</span> (fd,sz,ofs) -&gt; []
    | <span class="dt">OS_DET_PWRITE</span> (fd,bs,sz,ofs) -&gt; []
    | <span class="dt">OS_DET_WRITE</span> (fd,bs,sz) -&gt; []
    | <span class="dt">OS_DET_READ</span> (fd,sz) -&gt; []
  end)

  <span class="co">(* top-level labels, intended to mirror the syscalls, but with functional interface;  *)</span>
  <span class="kw">type</span> ty_os_command = 
    | <span class="dt">OS_CLOSE</span> <span class="kw">of</span> ty_fd
    | <span class="dt">OS_LINK</span> <span class="kw">of</span> (cstring * cstring)
    | <span class="dt">OS_MKDIR</span> <span class="kw">of</span> (cstring * file_perm)
    | <span class="dt">OS_OPEN</span> <span class="kw">of</span> (cstring * int_open_flags * maybe file_perm)
    | <span class="dt">OS_PREAD</span> <span class="kw">of</span> (ty_fd * size_t * off_t) 
    | <span class="dt">OS_READ</span> <span class="kw">of</span> (ty_fd * size_t) 
    | <span class="dt">OS_READDIR</span> <span class="kw">of</span> ty_dh
    | <span class="dt">OS_OPENDIR</span> <span class="kw">of</span> cstring
    | <span class="dt">OS_REWINDDIR</span> <span class="kw">of</span> ty_dh
    | <span class="dt">OS_CLOSEDIR</span> <span class="kw">of</span> ty_dh
    | <span class="dt">OS_READLINK</span> <span class="kw">of</span> cstring
    | <span class="dt">OS_RENAME</span> <span class="kw">of</span> (cstring * cstring)
    | <span class="dt">OS_RMDIR</span> <span class="kw">of</span> cstring
    | <span class="dt">OS_STAT</span> <span class="kw">of</span> cstring
    | <span class="dt">OS_LSTAT</span> <span class="kw">of</span> cstring
    | <span class="dt">OS_SYMLINK</span> <span class="kw">of</span> (cstring * cstring) 
    | <span class="dt">OS_TRUNCATE</span> <span class="kw">of</span> (cstring * off_t)
    | <span class="dt">OS_UNLINK</span> <span class="kw">of</span> cstring
    | <span class="dt">OS_PWRITE</span> <span class="kw">of</span> (ty_fd * ty_bytes * size_t * off_t)
    | <span class="dt">OS_WRITE</span> <span class="kw">of</span> (ty_fd * ty_bytes * size_t) 
    | <span class="dt">OS_UMASK</span> <span class="kw">of</span> file_perm
    | <span class="dt">OS_CHMOD</span> <span class="kw">of</span> (cstring * file_perm)
    | <span class="dt">OS_CHOWN</span> <span class="kw">of</span> (cstring * uid * gid)
    | <span class="dt">OS_CHDIR</span> <span class="kw">of</span> cstring
    | <span class="dt">OS_LSEEK</span> <span class="kw">of</span> (ty_fd * off_t * int_seek_command)
    | <span class="dt">OS_EXTENDED_CMD</span> <span class="kw">of</span> ty_os_ext_command <span class="co">(*o with sexp o*)</span>
   

  <span class="kw">val</span> paths_of_ty_os_command : ty_os_command -&gt; <span class="dt">list</span> cstring
  <span class="kw">let</span> paths_of_ty_os_command cmd = (<span class="kw">match</span> cmd <span class="kw">with</span>
      | <span class="dt">OS_CLOSE</span> fd -&gt; []
      | <span class="dt">OS_LINK</span> (s,d) -&gt; [s;d]
      | <span class="dt">OS_MKDIR</span> (s,p) -&gt; [s]
      | <span class="dt">OS_OPEN</span> (p,fs,mo) -&gt; [p]
      | <span class="dt">OS_PREAD</span> (fd,sz,ofs) -&gt; []
      | <span class="dt">OS_PWRITE</span> (fd,bs,sz,ofs) -&gt; []
      | <span class="dt">OS_WRITE</span> (fd,bs,sz) -&gt; []
      | <span class="dt">OS_READ</span> (fd,sz) -&gt; []
      | <span class="dt">OS_READDIR</span> dh -&gt; []
      | <span class="dt">OS_CLOSEDIR</span> dh -&gt; []
      | <span class="dt">OS_REWINDDIR</span> dh -&gt; []
      | <span class="dt">OS_OPENDIR</span> p -&gt; [p]
      | <span class="dt">OS_READLINK</span> p -&gt; [p]
      | <span class="dt">OS_RENAME</span> (s,d) -&gt; [s;d]
      | <span class="dt">OS_RMDIR</span> p -&gt; [p]
      | <span class="dt">OS_STAT</span> p -&gt; [p]
      | <span class="dt">OS_LSTAT</span> p -&gt;[p]
      | <span class="dt">OS_SYMLINK</span> (s,d) -&gt; [s;d]
      | <span class="dt">OS_TRUNCATE</span> (p,l) -&gt; [p]
      | <span class="dt">OS_UNLINK</span> p -&gt; [p]
      | <span class="dt">OS_UMASK</span> p -&gt; []
      | <span class="dt">OS_CHMOD</span> (s, p) -&gt; [s]
      | <span class="dt">OS_CHOWN</span> (s, u, g) -&gt; [s]
      | <span class="dt">OS_CHDIR</span> s -&gt; [s]
      | <span class="dt">OS_LSEEK</span> (fd,ofs,c) -&gt; []
      | <span class="dt">OS_EXTENDED_CMD</span> cmd&#39; -&gt; paths_of_ty_os_ext_command cmd&#39;
  end)



  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Architecture                  *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* a representation of the available architectures *)</span>
  <span class="kw">type</span> ty_arch = <span class="dt">ARCH_LINUX</span> | <span class="dt">ARCH_POSIX</span> | <span class="dt">ARCH_MAC_OS_X</span> <span class="co">(*o with sexp_of o*)</span>
  instance (<span class="dt">Eq</span> ty_arch)
    <span class="kw">let</span> (=) = unsafe_structural_equality
    <span class="kw">let</span> (&lt;&gt;) = unsafe_structural_inequality
  end

  <span class="co">(* the spec is parameterized by various traits, combined to form an &quot;architecture&quot; *)</span>
  <span class="kw">type</span> architecture = &lt;|
    arch_abs_path_slash_slash: <span class="dt">bool</span>; <span class="co">(* whether an absolute path can start with a double slash - POSIX has maybe implementation defined *)</span>
    arch_linux_non_posix: <span class="dt">bool</span>; <span class="co">(* Linux specific behaviour that is not POSIX compliant *)</span>
    arch_link_directories: <span class="dt">bool</span>; <span class="co">(* whether the implementation allows links on dirs; not supported in this spec *)</span>
    arch_open_flags_of_int: int_open_flags -&gt; finset open_flag  <span class="co">(*o sexp_opaque o*)</span>;
    arch_int_of_open_flags: finset open_flag -&gt; int_open_flags  <span class="co">(*o sexp_opaque o*)</span>;
    arch_seek_command_of_int : int_seek_command -&gt; maybe seek_command <span class="co">(*o sexp_opaque o*)</span>;
    arch_int_of_seek_command : seek_command -&gt; int_seek_command  <span class="co">(*o sexp_opaque o*)</span>;

    arch_allows_dir_read : <span class="dt">bool</span>; <span class="co">(* allow reading from a directory? If set to false, reading a directory needs readdir command instead of read. *)</span>
    arch_group_from_parent_dir: <span class="dt">bool</span>; <span class="co">(* Should new directories inherit the group of their parent dir? If set false, they use</span>
<span class="co">      the effective group id of the process instead. *)</span>
    arch_allows_removing_from_protected_dir_if_writeable : <span class="dt">bool</span> <span class="co">(* Allow deleting files and directories from protected directories, if the file or dir</span>
<span class="co">      is writeable? see posix/dir_protect.md *)</span>
  |&gt;<span class="co">(*o with sexp_of o*)</span>

  <span class="kw">type</span> ignore_j5f <span class="co">(* to force trailing comment above, see lem issue #174 *)</span>
<span class="ot">#ifdef aspect_perms</span>

  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Permission operations         *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* Operations concerned with permissions. This includes ownership of files and directories as well as</span>
<span class="co">     and group membership operations. *)</span>
  <span class="kw">type</span> perm_ops &#39;dir_ref &#39;file_ref &#39;jimpl = &lt;|
    pops_set_perm_file : &#39;jimpl -&gt; file_perm -&gt; &#39;file_ref -&gt; &#39;jimpl;
    pops_set_perm_dir : &#39;jimpl -&gt; file_perm -&gt; &#39;dir_ref -&gt; &#39;jimpl;

    pops_chown_file: &#39;jimpl -&gt; (uid * gid) -&gt; &#39;file_ref -&gt; &#39;jimpl;
    pops_chown_dir: &#39;jimpl -&gt; (uid * gid) -&gt; &#39;dir_ref -&gt; &#39;jimpl;

    pops_uid_is_superuser : &#39;jimpl -&gt; uid -&gt; <span class="dt">bool</span>
  |&gt; <span class="co">(* sexp_opaque with sexp *)</span>


  <span class="co">(* a dummy implementation of perm_ops with no-ops everywhere *)</span>
  <span class="kw">val</span> perm_ops_noops : forall &#39;dir_ref &#39;file_ref &#39;impl. <span class="dt">unit</span> -&gt; perm_ops &#39;dir_ref &#39;file_ref &#39;impl
  <span class="kw">let</span> perm_ops_noops () = &lt;| <span class="co">(* coverage:unused *)</span>
    pops_set_perm_file = (<span class="kw">fun</span> s0 _ _ -&gt; s0); <span class="co">(* coverage:unused *)</span>
    pops_set_perm_dir = (<span class="kw">fun</span> s0 _ _ -&gt; s0); <span class="co">(* coverage:unused *)</span>
    pops_chown_file = (<span class="kw">fun</span> s0 _ _ -&gt; s0); <span class="co">(* coverage:unused *)</span>
    pops_chown_dir = (<span class="kw">fun</span> s0 _ _ -&gt; s0); <span class="co">(* coverage:unused *)</span>
    pops_uid_is_superuser = (<span class="kw">fun</span> _ uid -&gt; uid = root_uid) <span class="co">(* coverage:unused *)</span>
  |&gt;



  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Checking permissions          *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">type</span> check_permissions &#39;dir_ref &#39;file_ref &#39;jimpl = &lt;|
     <span class="co">(* get the umask and default user and group of new files *)</span>
     cp_get_umask : &#39;jimpl -&gt; file_perm;
     cp_get_euid : <span class="dt">unit</span> -&gt; uid;
     cp_get_egid : <span class="dt">unit</span> -&gt; gid;

     <span class="co">(* has the current process certain permissions on a directory ? *)</span>
     cp_has_dir_search_permission   : &#39;jimpl -&gt; &#39;dir_ref  -&gt; <span class="dt">bool</span>;
     cp_has_dir_read_permission     : &#39;jimpl -&gt; &#39;dir_ref  -&gt; <span class="dt">bool</span>;
     cp_has_dir_write_permission    : &#39;jimpl -&gt; &#39;dir_ref  -&gt; <span class="dt">bool</span>;
     cp_has_dir_chmod_permission    : &#39;jimpl -&gt; &#39;dir_ref  -&gt; <span class="dt">bool</span>;
     cp_has_dir_chown_permission    : &#39;jimpl -&gt; &#39;dir_ref  -&gt; <span class="dt">bool</span>;


     <span class="co">(* has the current process certain permissions on a file ? *)</span>
     cp_has_file_execute_permission : &#39;jimpl -&gt; &#39;file_ref -&gt; <span class="dt">bool</span>;
     cp_has_file_read_permission    : &#39;jimpl -&gt; &#39;file_ref -&gt; <span class="dt">bool</span>;
     cp_has_file_write_permission   : &#39;jimpl -&gt; &#39;file_ref -&gt; <span class="dt">bool</span>;
     cp_has_file_chmod_permission   : &#39;jimpl -&gt; &#39;file_ref  -&gt; <span class="dt">bool</span>;
     cp_has_file_chown_permission   : &#39;jimpl -&gt; &#39;file_ref  -&gt; <span class="dt">bool</span>;


     <span class="co">(* special stuff ? *)</span>
     cp_has_dir_link_create_privilege : &#39;jimpl -&gt; &#39;dir_ref -&gt; <span class="dt">bool</span>; <span class="co">(* posix/link.md EPERM:1 *)</span>

     <span class="co">(* can the dir or file be deleted, if it&#39;s parent directory has the restricted deletion flag set? </span>
<span class="co">        Depending on the architecture this access is given for files with write permission. *)</span>
     cp_has_dir_restricted_delete_privilege  : <span class="co">(* allow for files with write perm? *)</span> <span class="dt">bool</span> -&gt; 
       &#39;jimpl -&gt; <span class="co">(* parent dir *)</span> &#39;dir_ref -&gt; &#39;dir_ref  -&gt; <span class="dt">bool</span>; 
     cp_has_file_restricted_delete_privilege : <span class="dt">bool</span> -&gt; &#39;jimpl -&gt; <span class="co">(* parent dir *)</span> &#39;dir_ref -&gt; &#39;file_ref -&gt; <span class="dt">bool</span>; 

  |&gt;
<span class="ot">#endif</span>


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Observing directories         *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* For operations like readdir it is important to keep track of </span>
<span class="co">     the changes to a directory between different calls. For this</span>
<span class="co">     one can register for observing a directory via</span>
<span class="co">     [fops_observe_dir_register]. This returns a handle, which can be used</span>
<span class="co">     via [fops_observe_dir] to get the changes since the last call.</span>
<span class="co">     Finally [fops_observe_dir_unregister] is used to clear the handle. </span>
<span class="co">     These functions are part of the [fs_ops] record defined below.</span>
<span class="co">     Here only a few auxiliary datatypes are defined.*)</span>

  <span class="kw">type</span> ty_od_handle &#39;dir_ref = <span class="dt">OD_handle</span> <span class="kw">of</span> (nat * &#39;dir_ref) <span class="co">(*o with sexp_of o*)</span> <span class="co">(* todo: perhaps make it a type variable *)</span>
  
  <span class="kw">type</span> ty_od_entry = <span class="dt">OD_removed</span> <span class="kw">of</span> name
                   | <span class="dt">OD_added</span> <span class="kw">of</span> name <span class="co">(*o with sexp_of o*)</span>

  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Filesystem operations         *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">type</span> fs_ops &#39;dir_ref &#39;file_ref &#39;jimpl = &lt;|
    fops_get_init_state: <span class="dt">unit</span> -&gt; &#39;jimpl;
    fops_get_parent: &#39;jimpl -&gt; &#39;dir_ref -&gt; maybe (&#39;dir_ref * name); <span class="co">(* if root, parent is none; possibly disconnected dirs can also have no parent *)</span>
    fops_get_root: &#39;jimpl -&gt; maybe &#39;dir_ref;
    fops_dest_dir_ref: &#39;jimpl -&gt; &#39;dir_ref -&gt; inode;
    fops_dest_file_ref: &#39;jimpl -&gt; &#39;file_ref -&gt; inode; 
    fops_file_ref_eq : &#39;jimpl -&gt; &#39;file_ref -&gt; &#39;file_ref -&gt; <span class="dt">bool</span>; <span class="co">(* equality check on file-refs *)</span>
    fops_dir_ref_eq : &#39;jimpl -&gt; &#39;dir_ref -&gt; &#39;dir_ref -&gt; <span class="dt">bool</span>; <span class="co">(* equality check on dir-refs *)</span>
    fops_link_file: &#39;jimpl -&gt; &#39;file_ref -&gt; &#39;dir_ref -&gt; name -&gt; &#39;jimpl;
    fops_unlink: &#39;jimpl -&gt; &#39;dir_ref -&gt; name -&gt; &#39;jimpl;
    fops_mkdir: &#39;jimpl -&gt; &#39;dir_ref -&gt; name -&gt; (&#39;jimpl * &#39;dir_ref);
    fops_mvfile: &#39;jimpl -&gt; &#39;dir_ref -&gt; name -&gt; &#39;dir_ref -&gt; name -&gt; &#39;jimpl;
    fops_mvdir: &#39;jimpl -&gt; &#39;dir_ref -&gt; name -&gt; &#39;dir_ref -&gt; name -&gt; &#39;jimpl;
    fops_read: &#39;jimpl -&gt; &#39;file_ref -&gt; (&#39;jimpl * ret_value); <span class="co">(* FIXME return value should be bytes? *)</span>
    fops_readdir: &#39;jimpl -&gt; &#39;dir_ref -&gt; (&#39;jimpl * <span class="dt">list</span> name); <span class="co">(* don&#39;t return . and .. entries *)</span>
    fops_resolve: &#39;jimpl -&gt; &#39;dir_ref -&gt; name -&gt; maybe (entry &#39;dir_ref &#39;file_ref); <span class="co">(* resolves normal entries; use get_parent for .. *)</span>
    fops_lookup_sysconf: &#39;jimpl -&gt; sysconf_value -&gt; nat;
    fops_write: &#39;jimpl -&gt; &#39;file_ref -&gt; ty_bytes -&gt; &#39;jimpl;
    fops_mkfile: &#39;jimpl -&gt; &#39;dir_ref -&gt; name -&gt; &#39;jimpl * &#39;file_ref; <span class="co">(* FIXME prefer this to touch *)</span>
    fops_readlink: &#39;jimpl -&gt; &#39;file_ref -&gt; ty_bytes; <span class="co">(* internal *)</span>
    fops_symlink: &#39;jimpl -&gt; &#39;dir_ref -&gt; name -&gt; ty_bytes -&gt; &#39;jimpl;    
    fops_stat_file: &#39;jimpl -&gt; &#39;file_ref -&gt; ty_stats; <span class="co">(* this is internal - doesn&#39;t expect to update times etc *)</span>
    fops_stat_dir: &#39;jimpl -&gt; &#39;dir_ref -&gt; ty_stats; <span class="co">(* this is internal - doesn&#39;t expect to update times etc *)</span>
    fops_lstat: &#39;jimpl -&gt; &#39;file_ref -&gt; ty_stats; <span class="co">(* this is internal -doesn&#39;t expect to update times etc *)</span>

    fops_observe_dir_register : &#39;jimpl -&gt; &#39;dir_ref -&gt; (&#39;jimpl * ty_od_handle &#39;dir_ref);
    fops_observe_dir : &#39;jimpl -&gt; ty_od_handle &#39;dir_ref -&gt; (&#39;jimpl * <span class="dt">list</span> ty_od_entry);
    fops_observe_dir_unregister : &#39;jimpl -&gt; ty_od_handle &#39;dir_ref -&gt; &#39;jimpl;
  |&gt;


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Environments                  *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">type</span> environment &#39;dir_ref &#39;file_ref &#39;jimpl = &lt;|
    env_ops: fs_ops &#39;dir_ref &#39;file_ref &#39;jimpl  <span class="co">(*o sexp_opaque o*)</span>;
    env_arch: ty_arch;
<span class="ot">#ifdef aspect_perms</span>
    env_prms : check_permissions &#39;dir_ref &#39;file_ref &#39;jimpl  <span class="co">(*o sexp_opaque o*)</span>;
    env_perm_ops: perm_ops &#39;dir_ref &#39;file_ref &#39;jimpl  <span class="co">(*o sexp_opaque o*)</span>;
<span class="ot">#endif</span>
  |&gt; <span class="co">(*o with sexp_of o*)</span>


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Process ids                   *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">type</span> ty_pid = <span class="dt">Pid</span> <span class="kw">of</span> nat <span class="co">(*o with sexp o*)</span>
  <span class="kw">let</span> ty_pid_compare (<span class="dt">Pid</span> n0) (<span class="dt">Pid</span> n1) = compare n0 n1
  instance ( <span class="dt">SetType</span> ty_pid ) 
    <span class="kw">let</span> setElemCompare = ty_pid_compare
  end

  instance (<span class="dt">Eq</span> ty_pid)
    <span class="kw">let</span> (=) = unsafe_structural_equality
    <span class="kw">let</span> (&lt;&gt;) = unsafe_structural_inequality
  end

  <span class="kw">val</span> dest_PID : ty_pid -&gt; nat
  <span class="kw">let</span> dest_PID x = (<span class="kw">match</span> x <span class="kw">with</span> <span class="dt">Pid</span> n -&gt; n end) <span class="co">(* coverage:unused *)</span>

  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* OS_labels                     *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* a process can only make a single call into OS (so, no threads); process is blocked until return *)</span>
  <span class="kw">type</span> os_label =  
      <span class="dt">OS_CALL</span> <span class="kw">of</span> (ty_pid * ty_os_command)
    | <span class="dt">OS_RETURN</span> <span class="kw">of</span> (ty_pid * error_or_value ret_value)
    | <span class="dt">OS_CREATE</span> <span class="kw">of</span> (ty_pid * uid * gid)
    | <span class="dt">OS_DESTROY</span> <span class="kw">of</span> ty_pid
    | <span class="dt">OS_TAU</span> <span class="co">(*o with sexp o*)</span>


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* file descriptor ids           *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* open file descriptions, per host *)</span>
  <span class="kw">type</span> ty_fid = <span class="dt">FID</span> <span class="kw">of</span> nat <span class="co">(*o with sexp_of o*)</span>
  <span class="kw">let</span> ty_fid_compare (<span class="dt">FID</span> n0) (<span class="dt">FID</span> n1) = compare n0 n1

  instance ( <span class="dt">SetType</span> ty_fid ) 
    <span class="kw">let</span> setElemCompare = ty_fid_compare
  end

  <span class="kw">val</span> dest_FID : ty_fid -&gt; nat
  <span class="kw">let</span> dest_FID x = (<span class="kw">match</span> x <span class="kw">with</span> <span class="dt">FID</span> n -&gt; n end) <span class="co">(* coverage:unused *)</span>


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* directory handle state        *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">type</span> dh_state &#39;dir_ref = &lt;|
    dhs_dir_ref: &#39;dir_ref;
    dhs_observe_handle : ty_od_handle &#39;dir_ref;
    dhs_must_report : <span class="dt">list</span> name; 
      <span class="co">(* the entries of the directory that still need to be reported by readdir. This list will never contain duplicates. *)</span>
    dhs_may_report : <span class="dt">list</span> name; <span class="co">(* the entries of the directory that may, but does not need to be still reported.</span>
<span class="co">      This list might contain duplicates, which indicates that these entries might be reported twice. *)</span>
  |&gt; <span class="co">(*o with sexp_of o*)</span>


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* file descriptor state         *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">type</span> fd_state = &lt;|
    fds_fid: ty_fid;
    fds_FD_CLOEXEC: <span class="dt">bool</span>; <span class="co">(* FIXME how to test? *)</span>
  |&gt; <span class="co">(*o with sexp_of o*)</span>


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* file identifier states        *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">type</span> fid_open_closed_state = <span class="dt">FID_OPEN</span> | <span class="dt">FID_CLOSED</span> <span class="co">(*o with sexp_of o*)</span>

  <span class="kw">type</span> fid_state &#39;dir_ref &#39;file_ref = &lt;|
    fids_offset: nat; <span class="co">(* cannot be negative *)</span>
    fids_entry: entry &#39;dir_ref &#39;file_ref;
    fids_oflags: finset open_flag  <span class="co">(*o sexp_opaque o*)</span>;  <span class="co">(* flags that were provided on creation *)</span>
    fids_open_or_closed: fid_open_closed_state;
  |&gt; <span class="co">(*o with sexp_of o*)</span>


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* per process states            *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">type</span> ty_pps_pid_run_state = <span class="dt">RUNNING</span> | <span class="dt">BLOCKED_CALL</span> <span class="kw">of</span> ty_os_command | <span class="dt">PENDING_RETURN</span> <span class="kw">of</span> (error_or_value ret_value) <span class="co">(*o with sexp_of o*)</span>

<span class="co">(*o</span>
<span class="co">  let sexp_of_fmap a b x = x |&gt; (fmap_bindings</span>
<span class="co">          (Lem_map.instance_Map_MapKeyType_var_dict instance_Basic_classes_SetType_var_dict) </span>
<span class="co">          instance_Basic_classes_SetType_var_dict </span>
<span class="co">          instance_Basic_classes_SetType_var_dict)</span>
<span class="co">          |&gt; sexp_of_list (sexp_of_pair a b)</span>
<span class="co">o*)</span>

  <span class="kw">type</span> per_process_state &#39;dir_ref = &lt;|
    pps_cwd: &#39;dir_ref; 
    pps_fd_table: fmap ty_fd (fd_state)  <span class="co">(*o sexp_opaque o*)</span>;
    pps_dh_table: fmap ty_dh (dh_state &#39;dir_ref) <span class="co">(*o sexp_opaque o*)</span>;
    pps_pid_run_state : ty_pps_pid_run_state;
    pps_file_creation_mask : file_perm;    
    pps_effective_uid : uid;
    pps_real_uid      : uid;
    pps_saved_uid     : uid;
    pps_effective_gid : gid;
    pps_real_gid      : gid;
    pps_saved_gid     : gid;
  |&gt; <span class="co">(*o with sexp_of o*)</span>

  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* operating system states       *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">type</span> ty_os_state &#39;dir_ref &#39;file_ref &#39;jimpl = &lt;|
    oss_pid_table: fmap ty_pid (per_process_state &#39;dir_ref);
    oss_fid_table: fmap ty_fid (fid_state &#39;dir_ref &#39;file_ref);
    oss_group_table: fmap gid (finset uid) <span class="co">(*o sexp_opaque o*)</span>;
    oss_fs_state: &#39;jimpl;
    oss_env: environment &#39;dir_ref &#39;file_ref &#39;jimpl
  |&gt; <span class="co">(*o with sexp_of o*)</span>

  <span class="kw">val</span> os_state_to_fs_state : forall &#39;dir_ref &#39;file_ref &#39;jimpl. ty_os_state &#39;dir_ref &#39;file_ref &#39;jimpl -&gt; &#39;jimpl
  <span class="kw">let</span> os_state_to_fs_state s0 = s0.oss_fs_state

  <span class="kw">let</span> os_state_to_env s0 = s0.oss_env

  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Monad states                  *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* We model the non-deterministic behaviour of the specification</span>
<span class="co">     explicitly.  A normal monad state consists of a file-system state</span>
<span class="co">     with either a posix defined error or with a return</span>
<span class="co">     value. However, we might also have special states. Special states</span>
<span class="co">     from the specification are states where the specification is</span>
<span class="co">     vague (explicitly for various reasons) and we therefore just have</span>
<span class="co">     to stop and say that we don&#39;t know what happens. Another reason</span>
<span class="co">     is that we just did not get around (yet) modeling some less common</span>
<span class="co">     parts of the specification. *)</span>
  <span class="kw">type</span> monad_special_state = <span class="dt">Impossible</span> | <span class="dt">Implementation_defined</span> | <span class="dt">Unspecified</span> | <span class="dt">Undefined</span> | <span class="dt">FIXME</span> <span class="co">(*o with sexp o*)</span>

  <span class="co">(* Since we also support non-determinism, a monad state is either a (finite) set of normal states or of special states. *)</span>
  <span class="kw">type</span> monad_state &#39;impl &#39;ja = 
    <span class="dt">Normal_state</span> <span class="kw">of</span> (&#39;impl * &#39;ja) 
  | <span class="dt">Error_state</span> <span class="kw">of</span> (&#39;impl * error)
  | <span class="dt">Special_state</span> <span class="kw">of</span> (monad_special_state * <span class="dt">string</span>)
 
  <span class="kw">val</span> is_Normal_state : forall &#39;impl &#39;a. monad_state &#39;impl &#39;a -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> is_Normal_state st = <span class="kw">match</span> st <span class="kw">with</span>
    | <span class="dt">Normal_state</span> _ -&gt; <span class="kw">true</span>
    | _ -&gt; <span class="kw">false</span>
  end

  <span class="kw">val</span> is_Error_state : forall &#39;impl &#39;a. monad_state &#39;impl &#39;a -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> is_Error_state st = <span class="kw">match</span> st <span class="kw">with</span>
    | <span class="dt">Error_state</span> _ -&gt; <span class="kw">true</span> <span class="co">(* coverage:unused *)</span>
    | _ -&gt; <span class="kw">false</span> <span class="co">(* coverage:unused *)</span>
  end

  <span class="kw">val</span> is_Error_state_err : forall &#39;impl &#39;a. error -&gt; monad_state &#39;impl &#39;a -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> is_Error_state_err e st = <span class="kw">match</span> st <span class="kw">with</span>
    | <span class="dt">Error_state</span> (_, e&#39;) -&gt; (e = e&#39;) <span class="co">(* coverage:unused *)</span>
    | _ -&gt; <span class="kw">false</span> <span class="co">(* coverage:unused *)</span>
  end

  <span class="kw">val</span> is_Special_state : forall &#39;impl &#39;a. monad_state &#39;impl &#39;a -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> is_Special_state st = <span class="kw">match</span> st <span class="kw">with</span>
    | <span class="dt">Special_state</span> _ -&gt; <span class="kw">true</span> <span class="co">(* coverage:unused *)</span>
    | _ -&gt; <span class="kw">false</span> <span class="co">(* coverage:unused *)</span>
  end

  <span class="kw">val</span> is_Impossible_state : forall &#39;impl &#39;a. monad_state &#39;impl &#39;a -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> is_Impossible_state st = <span class="kw">match</span> st <span class="kw">with</span>
    | <span class="dt">Special_state</span> (<span class="dt">Impossible</span>, _) -&gt; <span class="kw">true</span> <span class="co">(* coverage:unused *)</span>
    | _ -&gt; <span class="kw">false</span> <span class="co">(* coverage:unused *)</span>
  end

  <span class="kw">val</span> dest_Normal_state : forall &#39;impl &#39;a. monad_state &#39;impl &#39;a -&gt; (&#39;impl * &#39;a)
  <span class="kw">val</span> dest_Error_state : forall &#39;impl &#39;a. monad_state &#39;impl &#39;a -&gt; (&#39;impl * error)
  <span class="kw">val</span> dest_Special_state : forall &#39;impl &#39;a. monad_state &#39;impl &#39;a -&gt; (monad_special_state * <span class="dt">string</span>)
  <span class="kw">let</span> dest_Normal_state (<span class="dt">Normal_state</span> sx) = sx <span class="co">(* coverage:unused *)</span>
  <span class="kw">let</span> dest_Error_state (<span class="dt">Error_state</span> se) = se <span class="co">(* coverage:unused *)</span>
  <span class="kw">let</span> dest_Special_state (<span class="dt">Special_state</span> sm) = sm <span class="co">(* coverage:unused *)</span>

  <span class="co">(* We can&#39;t compare all &#39;impl. So let&#39;s use the following heuristic. If it returns true,</span>
<span class="co">     two states are equal, otherwise, we don&#39;t know. *)</span>
  <span class="kw">val</span> monad_state_shallow_eq : forall &#39;impl &#39;a. <span class="dt">Eq</span> &#39;a =&gt; monad_state &#39;impl &#39;a -&gt; monad_state &#39;impl &#39;a -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> monad_state_shallow_eq st1 st2 = <span class="kw">match</span> (st1, st2) <span class="kw">with</span>
    | (<span class="dt">Normal_state</span> (s1, v1),   <span class="dt">Normal_state</span> (s2, v2))   -&gt; <span class="co">(* coverage:impossible *)</span>
       (v1 = v2) &amp;&amp; (shallow_equality s1 s2) <span class="co">(* coverage:impossible -monad_state_shallow_eq is used only on partitions of states that are not normal *)</span>
    | (<span class="dt">Error_state</span> (s1, e1),    <span class="dt">Error_state</span> (s2, e2))    -&gt; (e1 = e2) &amp;&amp; (shallow_equality s1 s2)
    | (<span class="dt">Special_state</span> (ss1, m1), <span class="dt">Special_state</span> (ss2, m2)) -&gt; (ss1 = ss2) &amp;&amp; (m1 = m2) <span class="co">(* coverage:linux:irrelevant *)</span>
    | _ -&gt; <span class="kw">false</span>
  end


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* OS states                     *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">type</span> os_state_or_special &#39;dir_ref &#39;file_ref &#39;impl = 
    | <span class="dt">OS_normal</span> <span class="kw">of</span> (ty_os_state &#39;dir_ref &#39;file_ref &#39;impl)
    | <span class="dt">OS_special</span> <span class="kw">of</span> (monad_special_state * <span class="dt">string</span>) <span class="co">(*o with sexp_of o*)</span>

  <span class="kw">let</span> is_OS_normal s = (<span class="kw">match</span> s <span class="kw">with</span> | <span class="dt">OS_normal</span> s -&gt; <span class="kw">true</span> | _ -&gt; <span class="kw">false</span> end) <span class="co">(* coverage:unused *)</span>
  <span class="kw">let</span> is_OS_special s = (<span class="kw">match</span> s <span class="kw">with</span> | <span class="dt">OS_special</span> s -&gt; <span class="kw">true</span> | _ -&gt; <span class="kw">false</span> end) <span class="co">(* coverage:unused *)</span>
  <span class="kw">let</span> dest_OS_normal s = (<span class="kw">match</span> s <span class="kw">with</span> | <span class="dt">OS_normal</span> s -&gt; s | _ -&gt; failwith <span class="st">&quot;dest_OS_normal&quot;</span> end) <span class="co">(* coverage:unused *)</span>
  <span class="kw">let</span> dest_OS_special s = (<span class="kw">match</span> s <span class="kw">with</span> | <span class="dt">OS_special</span> s -&gt; s | _ -&gt; failwith <span class="st">&quot;dest_OS_special&quot;</span> end) <span class="co">(* coverage:unused *)</span>

end<span class="co">(* Fs_types *)</span>


<span class="co">(******************************************************************************)</span>
<span class="co">(* Fs_arch                                                                    *)</span>
<span class="co">(*                                                                            *)</span>
<span class="co">(* Architecture-specific definitions                                          *)</span>
<span class="co">(******************************************************************************)</span>

<span class="ot">module</span> Fs_arch = <span class="kw">struct</span>

  <span class="ot">open</span> Fs_types

  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Encoding of open-flags        *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* taken from Linux/include/uapi/asm-generic/fcntl.h  http://lxr.free-electrons.com/source/include/uapi/asm-generic/fcntl.h *)</span>
  <span class="kw">val</span> linux_int_of_open_flag : open_flag -&gt; maybe int_open_flags
  <span class="kw">let</span> linux_int_of_open_flag = (<span class="kw">fun</span> f -&gt;
    <span class="kw">match</span> f <span class="kw">with</span>
    <span class="co">(* ACCMODE 00000003 *)</span>
    | <span class="dt">O_EXEC</span>                        -&gt; <span class="dt">Nothing</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    | <span class="dt">O_RDONLY</span>                      -&gt; <span class="dt">Nothing</span> <span class="co">(* note that this is non-posix behaviour - O_RDONLY should be represented by a bit, rather than the absence of other bits *)</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    | <span class="dt">O_WRONLY</span>                      -&gt; (<span class="dt">Just</span> <span class="bn">0O00000001</span>) <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    | <span class="dt">O_RDWR</span>                        -&gt; (<span class="dt">Just</span> <span class="bn">0O00000002</span>) <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    | <span class="dt">O_SEARCH</span>                      -&gt; <span class="dt">Nothing</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    | <span class="dt">O_CREAT</span>                       -&gt; (<span class="dt">Just</span> <span class="bn">0O00000100</span>) <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    | <span class="dt">O_EXCL</span>                        -&gt; (<span class="dt">Just</span> <span class="bn">0O00000200</span>) <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    | <span class="dt">O_NOCTTY</span>                      -&gt; (<span class="dt">Just</span> <span class="bn">0O00000400</span>) <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    | <span class="dt">O_TRUNC</span>                       -&gt; (<span class="dt">Just</span> <span class="bn">0O00001000</span>) <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    | <span class="dt">O_APPEND</span>                      -&gt; (<span class="dt">Just</span> <span class="bn">0O00002000</span>) <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    | <span class="dt">O_NONBLOCK</span>                    -&gt; (<span class="dt">Just</span> <span class="bn">0O00004000</span>) <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    | <span class="dt">O_RSYNC</span>                       -&gt; <span class="dt">Nothing</span>  <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    | <span class="dt">O_SYNC</span>                        -&gt; <span class="dt">Nothing</span>  <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    | <span class="dt">O_DSYNC</span>                       -&gt; (<span class="dt">Just</span> <span class="bn">0O00010000</span>) <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    <span class="co">(* | FASYNC  0o00020000 *)</span>
    <span class="co">(* | O_DIRECT 0o00040000 *)</span>
    <span class="co">(* | O_LARGEFILE 00100000 *)</span> 
    | <span class="dt">O_DIRECTORY</span>                   -&gt; (<span class="dt">Just</span> <span class="bn">0O00200000</span>) <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    | <span class="dt">O_NOFOLLOW</span>                    -&gt; (<span class="dt">Just</span> <span class="bn">0O00400000</span>) <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    <span class="co">(* | O_NOATIME 01000000 *)</span> 
    | <span class="dt">O_CLOEXEC</span>                     -&gt; (<span class="dt">Just</span> <span class="bn">0O02000000</span>) <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    | <span class="dt">O_TTY_INIT</span>                    -&gt; <span class="dt">Nothing</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
  <span class="kw">end</span>)


  <span class="co">(* taken from Xcode/.../usr/include/sys/fcntl.h *)</span>
  <span class="kw">val</span> mac_int_of_open_flag : open_flag -&gt; maybe int_open_flags
  <span class="kw">let</span> mac_int_of_open_flag = (<span class="kw">fun</span> f -&gt;
    <span class="kw">match</span> f <span class="kw">with</span>
    <span class="co">(* ACCMODE 00000003 *)</span>
    | <span class="dt">O_EXEC</span>                        -&gt; <span class="dt">Nothing</span> 
    | <span class="dt">O_RDONLY</span>                      -&gt; <span class="dt">Nothing</span> <span class="co">(* actually defined as 0x0000 on mac, but this is not useful when dealing with bits where a 1 represents the presence of a flag *)</span>
    | <span class="dt">O_WRONLY</span>                      -&gt; (<span class="dt">Just</span> <span class="bn">0X0001</span>) 
    | <span class="dt">O_RDWR</span>                        -&gt; (<span class="dt">Just</span> <span class="bn">0X0002</span>) 
    | <span class="dt">O_SEARCH</span>                      -&gt; <span class="dt">Nothing</span> 


    | <span class="dt">O_NONBLOCK</span>                    -&gt; (<span class="dt">Just</span> <span class="bn">0X0004</span>) 
    | <span class="dt">O_APPEND</span>                      -&gt; (<span class="dt">Just</span> <span class="bn">0X0008</span>) 

    | <span class="dt">O_CREAT</span>                       -&gt; (<span class="dt">Just</span> <span class="bn">0X0200</span>) 
    | <span class="dt">O_EXCL</span>                        -&gt; (<span class="dt">Just</span> <span class="bn">0X0800</span>) 
    | <span class="dt">O_NOCTTY</span>                      -&gt; (<span class="dt">Just</span> <span class="bn">0X20000</span>) 
    | <span class="dt">O_TRUNC</span>                       -&gt; (<span class="dt">Just</span> <span class="bn">0X0400</span>) 
    | <span class="dt">O_RSYNC</span>                       -&gt; <span class="dt">Nothing</span>  
    | <span class="dt">O_SYNC</span>                        -&gt; (<span class="dt">Just</span> <span class="bn">0X0080</span>)
    | <span class="dt">O_DSYNC</span>                       -&gt; (<span class="dt">Just</span> <span class="bn">0X400000</span>) 
    <span class="co">(* | FASYNC  0o00020000 *)</span>
    <span class="co">(* | O_DIRECT 0o00040000 *)</span>
    <span class="co">(* | O_LARGEFILE 00100000 *)</span> 
    | <span class="dt">O_DIRECTORY</span>                   -&gt; (<span class="dt">Just</span> <span class="bn">0X100000</span>) 
    | <span class="dt">O_NOFOLLOW</span>                    -&gt; (<span class="dt">Just</span> <span class="bn">0X0100</span>) 
    <span class="co">(* | O_NOATIME 01000000 *)</span> 
    | <span class="dt">O_CLOEXEC</span>                     -&gt; (<span class="dt">Just</span> <span class="bn">0X1000000</span>) 
    | <span class="dt">O_TTY_INIT</span>                    -&gt; <span class="dt">Nothing</span> 
  end)

  <span class="co">(* A dummy one that encodes (in contrast to Linux) really everything *)</span>
  <span class="kw">val</span> posix_int_of_open_flag : open_flag -&gt; maybe int_open_flags
  <span class="kw">let</span> posix_int_of_open_flag = (<span class="kw">fun</span> f -&gt;
    <span class="kw">match</span> f <span class="kw">with</span>
    <span class="co">(* ACCMODE 00000003 *)</span>
    | <span class="dt">O_EXEC</span>                        -&gt; (<span class="dt">Just</span> <span class="bn">0O000000001</span>)  <span class="co">(* coverage:linux:irrelevant *)</span>
    | <span class="dt">O_RDONLY</span>                      -&gt; (<span class="dt">Just</span> <span class="bn">0O000000002</span>)  <span class="co">(* coverage:linux:irrelevant *)</span>
    | <span class="dt">O_WRONLY</span>                      -&gt; (<span class="dt">Just</span> <span class="bn">0O000000004</span>) <span class="co">(* coverage:linux:irrelevant *)</span>
    | <span class="dt">O_RDWR</span>                        -&gt; (<span class="dt">Just</span> <span class="bn">0O000000010</span>) <span class="co">(* coverage:linux:irrelevant *)</span>
    | <span class="dt">O_SEARCH</span>                      -&gt; (<span class="dt">Just</span> <span class="bn">0O000000020</span>) <span class="co">(* coverage:linux:irrelevant *)</span>
    | <span class="dt">O_CREAT</span>                       -&gt; (<span class="dt">Just</span> <span class="bn">0O000000040</span>) <span class="co">(* coverage:linux:irrelevant *)</span>
    | <span class="dt">O_EXCL</span>                        -&gt; (<span class="dt">Just</span> <span class="bn">0O000000100</span>) <span class="co">(* coverage:linux:irrelevant *)</span>
    | <span class="dt">O_NOCTTY</span>                      -&gt; (<span class="dt">Just</span> <span class="bn">0O000000200</span>) <span class="co">(* coverage:linux:irrelevant *)</span>
    | <span class="dt">O_TRUNC</span>                       -&gt; (<span class="dt">Just</span> <span class="bn">0O000000400</span>) <span class="co">(* coverage:linux:irrelevant *)</span>
    | <span class="dt">O_APPEND</span>                      -&gt; (<span class="dt">Just</span> <span class="bn">0O000001000</span>) <span class="co">(* coverage:linux:irrelevant *)</span>
    | <span class="dt">O_NONBLOCK</span>                    -&gt; (<span class="dt">Just</span> <span class="bn">0O000002000</span>) <span class="co">(* coverage:linux:irrelevant *)</span>
    | <span class="dt">O_RSYNC</span>                       -&gt; (<span class="dt">Just</span> <span class="bn">0O000004000</span>) <span class="co">(* coverage:linux:irrelevant *)</span>
    | <span class="dt">O_SYNC</span>                        -&gt; (<span class="dt">Just</span> <span class="bn">0O000010000</span>) <span class="co">(* coverage:linux:irrelevant *)</span>
    | <span class="dt">O_DSYNC</span>                       -&gt; (<span class="dt">Just</span> <span class="bn">0O000020000</span>) <span class="co">(* coverage:linux:irrelevant *)</span>
    | <span class="dt">O_DIRECTORY</span>                   -&gt; (<span class="dt">Just</span> <span class="bn">0O000040000</span>) <span class="co">(* coverage:linux:irrelevant *)</span>
    | <span class="dt">O_NOFOLLOW</span>                    -&gt; (<span class="dt">Just</span> <span class="bn">0O000100000</span>) <span class="co">(* coverage:linux:irrelevant *)</span>
    | <span class="dt">O_CLOEXEC</span>                     -&gt; (<span class="dt">Just</span> <span class="bn">0O000200000</span>) <span class="co">(* coverage:linux:irrelevant *)</span>
    | <span class="dt">O_TTY_INIT</span>                    -&gt; (<span class="dt">Just</span> <span class="bn">0O000400000</span>) end)  <span class="co">(* coverage:linux:irrelevant *)</span>

  <span class="co">(* convert an oflag int argument to a set of flags *)</span>
  <span class="kw">val</span> gen_arch_open_flags_of_int : (open_flag -&gt; maybe int_open_flags) -&gt; int_open_flags -&gt; finset open_flag
  <span class="kw">let</span> gen_arch_open_flags_of_int int_of_open_flag = (<span class="kw">fun</span> oflag -&gt; 
    <span class="kw">let</span> is_flag_in_oflag flag = (
      <span class="kw">let</span> i = int_of_open_flag flag <span class="kw">in</span>
      (<span class="kw">match</span> i <span class="kw">with</span>
        | <span class="dt">Nothing</span> -&gt; <span class="kw">false</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
        | <span class="dt">Just</span> i -&gt; (i <span class="kw">land</span> oflag) &lt;&gt; <span class="dv">0</span>
      end)
    ) <span class="kw">in</span>
    <span class="kw">let</span> fs = finset_filter is_flag_in_oflag open_flags <span class="kw">in</span>
    <span class="co">(* if no access mode, then the access mode is O_RDONLY! this arises because Linux (and Mac) defines O_RDONLY=0 *)</span>  
    <span class="kw">if</span> finset_all (<span class="kw">fun</span> flag -&gt; not (finset_mem flag fs)) access_mode_flags <span class="kw">then</span> 
      finset_insert <span class="dt">O_RDONLY</span> fs 
    <span class="kw">else</span> 
      fs)

  <span class="kw">val</span> linux_arch_open_flags_of_int : int_open_flags -&gt; finset open_flag
  <span class="kw">let</span> linux_arch_open_flags_of_int = gen_arch_open_flags_of_int linux_int_of_open_flag

  <span class="kw">val</span> mac_arch_open_flags_of_int : int_open_flags -&gt; finset open_flag
  <span class="kw">let</span> mac_arch_open_flags_of_int = gen_arch_open_flags_of_int mac_int_of_open_flag


  <span class="kw">val</span> posix_arch_open_flags_of_int : int_open_flags -&gt; finset open_flag
  <span class="kw">let</span> posix_arch_open_flags_of_int = gen_arch_open_flags_of_int posix_int_of_open_flag

  <span class="kw">val</span> gen_arch_int_of_open_flags : (open_flag -&gt; maybe int_open_flags) -&gt; finset open_flag -&gt; int_open_flags 
  <span class="kw">let</span> gen_arch_int_of_open_flags int_of_open_flag = (<span class="kw">fun</span> fs -&gt;
    <span class="kw">let</span> flags = list_from_finset fs <span class="kw">in</span>
    <span class="kw">let</span> sum = List<span class="kw">.</span>foldl (<span class="kw">fun</span> sum f -&gt; <span class="kw">match</span> int_of_open_flag f <span class="kw">with</span>
      | <span class="dt">Nothing</span> -&gt; sum <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
      | <span class="dt">Just</span> i -&gt; sum <span class="kw">lor</span> i
    end) <span class="dv">0</span> flags <span class="kw">in</span>
    sum)

  <span class="kw">val</span> linux_arch_int_of_open_flags : finset open_flag -&gt; int_open_flags 
  <span class="kw">let</span> linux_arch_int_of_open_flags = gen_arch_int_of_open_flags linux_int_of_open_flag

  <span class="kw">val</span> mac_arch_int_of_open_flags : finset open_flag -&gt; int_open_flags 
  <span class="kw">let</span> mac_arch_int_of_open_flags = gen_arch_int_of_open_flags mac_int_of_open_flag

  <span class="kw">val</span> posix_arch_int_of_open_flags : finset open_flag -&gt; int_open_flags 
  <span class="kw">let</span> posix_arch_int_of_open_flags = gen_arch_int_of_open_flags posix_int_of_open_flag


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Encoding of seek-commands     *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* values copied from linux stdio.h *)</span>
  <span class="kw">val</span> linux_arch_int_of_seek_command : seek_command -&gt; int_seek_command
  <span class="kw">let</span> linux_arch_int_of_seek_command c = (<span class="kw">match</span> c <span class="kw">with</span>
    | <span class="dt">SEEK_SET</span> -&gt; <span class="dv">0</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    | <span class="dt">SEEK_CUR</span> -&gt; <span class="dv">1</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    | <span class="dt">SEEK_END</span> -&gt; <span class="dv">2</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    | <span class="dt">SEEK_DATA</span> -&gt; <span class="dv">3</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    | <span class="dt">SEEK_HOLE</span> -&gt; <span class="dv">4</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
  end)

  <span class="kw">val</span> posix_arch_int_of_seek_command : seek_command -&gt; int_seek_command
  <span class="kw">let</span> posix_arch_int_of_seek_command c = linux_arch_int_of_seek_command c <span class="co">(*coverage:linux:irrelevant*)</span>


  <span class="kw">val</span> linux_arch_seek_command_of_int : int_seek_command -&gt; maybe seek_command
  <span class="kw">let</span> linux_arch_seek_command_of_int i = (
    <span class="kw">if</span> i = <span class="dv">0</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    <span class="kw">then</span> <span class="dt">Just</span> <span class="dt">SEEK_SET</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    <span class="kw">else</span>
      <span class="kw">if</span> i = <span class="dv">1</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
      <span class="kw">then</span> <span class="dt">Just</span> <span class="dt">SEEK_CUR</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
      <span class="kw">else</span>
        <span class="kw">if</span> i = <span class="dv">2</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
        <span class="kw">then</span> <span class="dt">Just</span> <span class="dt">SEEK_END</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
        <span class="kw">else</span>
          <span class="kw">if</span> i = <span class="dv">3</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
          <span class="kw">then</span> <span class="dt">Just</span> <span class="dt">SEEK_DATA</span> <span class="co">(* coverage:unused *)</span>
          <span class="kw">else</span>
            <span class="kw">if</span> i = <span class="dv">4</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
            <span class="kw">then</span> <span class="dt">Just</span> <span class="dt">SEEK_HOLE</span> <span class="co">(* coverage:unused *)</span>
            <span class="kw">else</span> <span class="dt">Nothing</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
  )

  <span class="kw">val</span> posix_arch_seek_command_of_int : int_seek_command -&gt; maybe seek_command 
  <span class="kw">let</span> posix_arch_seek_command_of_int i = (
    <span class="kw">if</span> i = <span class="dv">0</span> <span class="kw">then</span> <span class="dt">Just</span> <span class="dt">SEEK_SET</span> <span class="kw">else</span> <span class="co">(* coverage:linux:irrelevant *)</span>
    <span class="kw">if</span> i = <span class="dv">1</span> <span class="kw">then</span> <span class="dt">Just</span> <span class="dt">SEEK_CUR</span> <span class="kw">else</span> <span class="co">(* coverage:linux:irrelevant *)</span>
    <span class="kw">if</span> i = <span class="dv">2</span> <span class="kw">then</span> <span class="dt">Just</span> <span class="dt">SEEK_END</span> <span class="kw">else</span> <span class="co">(* coverage:linux:irrelevant *)</span>
    <span class="dt">Nothing</span> <span class="co">(*coverage:linux:irrelevant*)</span>
  )


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* Architecture records          *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">val</span> linux_arch : architecture
  <span class="kw">let</span> linux_arch = &lt;|
    arch_abs_path_slash_slash = <span class="kw">true</span>;
    arch_linux_non_posix = <span class="kw">true</span>;
    arch_link_directories = <span class="kw">false</span>;  <span class="co">(* this is not supported *)</span>
    arch_open_flags_of_int = linux_arch_open_flags_of_int;
    arch_int_of_open_flags = linux_arch_int_of_open_flags;
    arch_seek_command_of_int = linux_arch_seek_command_of_int;
    arch_int_of_seek_command = linux_arch_int_of_seek_command;
    arch_allows_dir_read = <span class="kw">false</span>;
    arch_group_from_parent_dir = <span class="kw">false</span>; <span class="co">(* use effective gid of process for new dirs *)</span>
    arch_allows_removing_from_protected_dir_if_writeable = <span class="kw">false</span>; 
  |&gt;

  <span class="co">(* for testing, we don&#39;t want to fail every time we hit a POSIX</span>
<span class="co">     &quot;implementation defined&quot; feature; the following architecture is</span>
<span class="co">     POSIX, but with implementation defined features selected so that the</span>
<span class="co">     behaviour is sensible *)</span>
  <span class="kw">val</span> posix_test_arch : architecture
  <span class="kw">let</span> posix_test_arch = &lt;|
    arch_abs_path_slash_slash = <span class="kw">true</span>;
    arch_linux_non_posix = <span class="kw">false</span>;
    arch_link_directories = <span class="kw">false</span>; <span class="co">(* for testing? we should also test the spec if this is allowed *)</span>
    arch_open_flags_of_int = posix_arch_open_flags_of_int;
    arch_int_of_open_flags = posix_arch_int_of_open_flags;
    arch_seek_command_of_int = posix_arch_seek_command_of_int;
    arch_int_of_seek_command = posix_arch_int_of_seek_command;
    arch_allows_dir_read = <span class="kw">false</span>;
    arch_group_from_parent_dir = <span class="kw">false</span>; <span class="co">(* for testing perhaps try true as well *)</span>
    arch_allows_removing_from_protected_dir_if_writeable = <span class="kw">false</span>;
  |&gt;


  <span class="co">(* mac os x arch is like posix, but allows dir links *)</span>
  <span class="kw">val</span> mac_os_x_test_arch : architecture
  <span class="kw">let</span> mac_os_x_test_arch = &lt;|
    arch_abs_path_slash_slash = <span class="kw">true</span>;
    arch_linux_non_posix = <span class="kw">false</span>;
    arch_link_directories = <span class="kw">false</span>; <span class="co">(* FIXME not observed on Mac OS X tests yet? reverting to false for the time being *)</span>
    arch_open_flags_of_int = mac_arch_open_flags_of_int;
    arch_int_of_open_flags = mac_arch_int_of_open_flags;
    arch_seek_command_of_int = posix_arch_seek_command_of_int;
    arch_int_of_seek_command = posix_arch_int_of_seek_command;
    arch_allows_dir_read = <span class="kw">false</span>;
    arch_group_from_parent_dir = <span class="kw">false</span>; <span class="co">(* for testing perhaps try true as well *)</span>
    arch_allows_removing_from_protected_dir_if_writeable = <span class="kw">false</span>;
  |&gt;


  <span class="kw">let</span> architecture_of_ty_arch a = (<span class="kw">match</span> a <span class="kw">with</span>
    | <span class="dt">ARCH_LINUX</span> -&gt; linux_arch <span class="co">(* coverage:mac_os_x:irrelevant *)</span>
    | <span class="dt">ARCH_POSIX</span> -&gt; posix_test_arch <span class="co">(* coverage:linux:mac_os_x:irrelevant *)</span>
    | <span class="dt">ARCH_MAC_OS_X</span> -&gt; mac_os_x_test_arch end) <span class="co">(* coverage:linux:posix:irrelevant *)</span>

  <span class="kw">val</span> default_arch : ty_arch
  <span class="kw">let</span> default_arch = <span class="dt">ARCH_POSIX</span>


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* auxiliary functions to access *)</span>
  <span class="co">(* architecture records          *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">val</span> is_linux_arch : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> is_linux_arch env = (env.env_arch = <span class="dt">ARCH_LINUX</span>)

  <span class="kw">val</span> is_mac_os_x_arch: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> is_mac_os_x_arch env = (env.env_arch = <span class="dt">ARCH_MAC_OS_X</span>)

  <span class="kw">val</span> arch_allows_dir_links : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> arch_allows_dir_links env = (
    (architecture_of_ty_arch (env.env_arch)).arch_link_directories) <span class="co">(* coverage:unused *)</span>

end

<span class="ot">#ifdef aspect_perms</span>
<span class="co">(******************************************************************************)</span>
<span class="co">(* Fs_permissions                                                             *)</span>
<span class="co">(*                                                                            *)</span>
<span class="co">(* operations concerned with file permissions                                 *)</span>
<span class="co">(******************************************************************************)</span>

<span class="ot">module</span> Fs_permissions = <span class="kw">struct</span>

  <span class="ot">open</span> Fs_types

  <span class="co">(* ------------------------------------ *)</span>
  <span class="co">(* constants for file permissions       *)</span>
  <span class="co">(* ------------------------------------ *)</span>
  <span class="kw">let</span> <span class="dt">S_IRWXU</span> : file_perm = <span class="dt">File_perm</span> <span class="bn">0O0700</span> <span class="co">(* Read, write, execute/search by owner. *)</span>
  <span class="kw">let</span> <span class="dt">S_IRUSR</span> : file_perm = <span class="dt">File_perm</span> <span class="bn">0O0400</span> <span class="co">(* Read permission, owner. *)</span>
  <span class="kw">let</span> <span class="dt">S_IWUSR</span> : file_perm = <span class="dt">File_perm</span> <span class="bn">0O0200</span> <span class="co">(* Write permission, owner. *)</span>
  <span class="kw">let</span> <span class="dt">S_IXUSR</span> : file_perm = <span class="dt">File_perm</span> <span class="bn">0O0100</span> <span class="co">(* Execute/search permission, owner. *)</span>

  <span class="kw">let</span> <span class="dt">S_IRWXG</span> : file_perm = <span class="dt">File_perm</span> <span class="bn">0O0070</span> <span class="co">(* Read, write, execute/search by group. *)</span>
  <span class="kw">let</span> <span class="dt">S_IRGRP</span> : file_perm = <span class="dt">File_perm</span> <span class="bn">0O0040</span> <span class="co">(* Read permission, group. *)</span>
  <span class="kw">let</span> <span class="dt">S_IWGRP</span> : file_perm = <span class="dt">File_perm</span> <span class="bn">0O0020</span> <span class="co">(* Write permission, group. *)</span>
  <span class="kw">let</span> <span class="dt">S_IXGRP</span> : file_perm = <span class="dt">File_perm</span> <span class="bn">0O0010</span> <span class="co">(* Execute/search permission, group. *)</span>

  <span class="kw">let</span> <span class="dt">S_IRWXO</span> : file_perm = <span class="dt">File_perm</span> <span class="bn">0O0007</span> <span class="co">(* Read, write, execute/search by others. *)</span>
  <span class="kw">let</span> <span class="dt">S_IROTH</span> : file_perm = <span class="dt">File_perm</span> <span class="bn">0O0004</span> <span class="co">(* Read permission, others. *)</span>
  <span class="kw">let</span> <span class="dt">S_IWOTH</span> : file_perm = <span class="dt">File_perm</span> <span class="bn">0O0002</span> <span class="co">(* Write permission, others. *)</span>
  <span class="kw">let</span> <span class="dt">S_IXOTH</span> : file_perm = <span class="dt">File_perm</span> <span class="bn">0O0001</span> <span class="co">(* Execute/search permission, others. *)</span>

  <span class="kw">let</span> <span class="dt">S_ISUID</span> : file_perm = <span class="dt">File_perm</span> <span class="bn">0O4000</span> <span class="co">(* Set-user-ID on execution. *)</span>
  <span class="kw">let</span> <span class="dt">S_ISGID</span> : file_perm = <span class="dt">File_perm</span> <span class="bn">0O2000</span> <span class="co">(* Set-group-ID on execution. *)</span>
  <span class="kw">let</span> <span class="dt">S_ISVTX</span> : file_perm = <span class="dt">File_perm</span> <span class="bn">0O1000</span> <span class="co">(* On directories, restricted deletion flag *)</span>


  <span class="co">(* ------------------------------------ *)</span>
  <span class="co">(* some operations on file permissions  *)</span>
  <span class="co">(* ------------------------------------ *)</span>
   
  <span class="kw">val</span> combine_file_perms : <span class="dt">list</span> file_perm -&gt; file_perm
  <span class="kw">let</span> combine_file_perms pl = <span class="dt">File_perm</span> (List<span class="kw">.</span>foldl (<span class="kw">fun</span> i p -&gt; (i <span class="kw">lor</span> (dest_file_perm p))) <span class="dv">0</span> pl) <span class="co">(* coverage:unused *)</span>

  <span class="co">(* the Posix defined file permissions only use the lower 12 bits. 3 * 3 bits are used for</span>
<span class="co">     read, write and search/execute permissions for owner, group and others + 3 bits for</span>
<span class="co">     special permissions. However, some implementations may use further bits. Some functions</span>
<span class="co">     need to be able to check, whether such permissions are present. *)</span>
  <span class="kw">val</span> contains_implementation_specific_file_perms : file_perm -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> contains_implementation_specific_file_perms p = not ((dest_file_perm p) <span class="kw">land</span> (lnot <span class="bn">0O07777</span>) = <span class="dv">0</span>)

  <span class="co">(* [set_file_perms org_perm new_perm] updates the permission [org_perm] to now contain also</span>
<span class="co">     the permissions [new_perm] *)</span>
  <span class="kw">val</span> set_file_perms : file_perm -&gt; file_perm -&gt; file_perm
  <span class="kw">let</span> set_file_perms org_perm new_perm = <span class="dt">File_perm</span> (dest_file_perm org_perm <span class="kw">lor</span> dest_file_perm new_perm) <span class="co">(* coverage:unused *)</span>

  <span class="co">(* [unset_file_perms org_perm new_perm] updates the permission [org_perm] to remove the permissions [new_perm] *)</span>
  <span class="kw">val</span> unset_file_perms : file_perm -&gt; file_perm -&gt; file_perm
  <span class="kw">let</span> unset_file_perms org_perm new_perm = <span class="dt">File_perm</span> (dest_file_perm org_perm <span class="kw">land</span> (lnot (dest_file_perm new_perm)))

  <span class="co">(* [check_file_perms perm check_perm] checks whether the permission [perm] contains permissions [check_perm] *)</span>
  <span class="kw">val</span> check_file_perms : file_perm -&gt; file_perm -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> check_file_perms perm check_perm = ((dest_file_perm perm <span class="kw">land</span> dest_file_perm check_perm) = dest_file_perm check_perm)


  <span class="co">(* --------------------------------------------- *)</span>
  <span class="co">(* check whether a user has certain permissions  *)</span>
  <span class="co">(* --------------------------------------------- *)</span>

  <span class="co">(* extract the relevant permission from a stat result for a given uid *)</span>
  <span class="kw">type</span> permission_type = 
     <span class="dt">Perm_read</span> | <span class="dt">Perm_write</span> | <span class="dt">Perm_execute_search</span>

  <span class="kw">val</span> permission_type_to_user_perm : permission_type -&gt; file_perm
  <span class="kw">let</span> permission_type_to_user_perm = <span class="kw">function</span>
    | <span class="dt">Perm_read</span>           -&gt; <span class="dt">S_IRUSR</span>
    | <span class="dt">Perm_write</span>          -&gt; <span class="dt">S_IWUSR</span>
    | <span class="dt">Perm_execute_search</span> -&gt; <span class="dt">S_IXUSR</span>
  <span class="kw">end</span>

  <span class="kw">val</span> permission_type_to_group_perm : permission_type -&gt; file_perm
  <span class="kw">let</span> permission_type_to_group_perm = <span class="kw">function</span>
    | <span class="dt">Perm_read</span>           -&gt; <span class="dt">S_IRGRP</span>
    | <span class="dt">Perm_write</span>          -&gt; <span class="dt">S_IWGRP</span>
    | <span class="dt">Perm_execute_search</span> -&gt; <span class="dt">S_IXGRP</span>
  end

  <span class="kw">val</span> permission_type_to_other_perm : permission_type -&gt; file_perm
  <span class="kw">let</span> permission_type_to_other_perm = <span class="kw">function</span>
    | <span class="dt">Perm_read</span>           -&gt; <span class="dt">S_IROTH</span>
    | <span class="dt">Perm_write</span>          -&gt; <span class="dt">S_IWOTH</span>
    | <span class="dt">Perm_execute_search</span> -&gt; <span class="dt">S_IXOTH</span>
  end

  <span class="co">(* [uid_check_permission ops s0 uid pt stat] checks whether</span>
<span class="co">     in the state [s0] the user [uid] has permission of type [pt] on a file or directory</span>
<span class="co">     with stats [stat]. In order to do this, one needs to figure</span>
<span class="co">     out whether to look in the user, group or other part of the </span>
<span class="co">     permissions. *)</span>
  <span class="kw">val</span> uid_check_permission : forall &#39;dir_ref &#39;file_ref &#39;impl &#39;a &#39;b &#39;c.
    environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
    (uid -&gt; gid -&gt; <span class="dt">bool</span>) -&gt;
    uid -&gt; permission_type -&gt; 
    ty_stats -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> uid_check_permission env is_user_in_group uid pt stat = <span class="kw">begin</span>
     <span class="kw">let</span> perm_check = 
       <span class="kw">if</span> (uid = stat.st_uid) <span class="kw">then</span>
          permission_type_to_user_perm pt
       <span class="kw">else</span> <span class="kw">if</span> is_user_in_group uid stat.st_gid <span class="kw">then</span>
          permission_type_to_group_perm pt
       <span class="kw">else</span>
          permission_type_to_other_perm pt
     <span class="kw">in</span>
     check_file_perms stat.st_perm perm_check
  <span class="kw">end</span>


  <span class="co">(* ------------------------------------ *)</span>
  <span class="co">(* check-permission records             *)</span>
  <span class="co">(* ------------------------------------ *)</span>

  <span class="co">(* ................ *)</span>
  <span class="co">(* full permissions *)</span>
  <span class="co">(* ................ *)</span>

  <span class="co">(* full_permissions grants all permissions, effectively, it turns off permission checking *)</span>
  <span class="kw">val</span> full_permissions : forall &#39;dir_ref &#39;file_ref &#39;impl. check_permissions &#39;dir_ref &#39;file_ref &#39;impl
  <span class="kw">let</span> full_permissions =  &lt;|
     cp_get_umask = (<span class="kw">fun</span> _ -&gt; <span class="dt">File_perm</span> <span class="bn">0O0000</span>); <span class="co">(* don&#39;t restrict anything *)</span> <span class="co">(* coverage:unused -this field is overwritten by the only call to full_permissions *)</span>
     cp_get_euid = (<span class="kw">fun</span> () -&gt; root_uid); <span class="co">(* coverage:unused -this field is overwritten by the only call to full_permissions *)</span>
     cp_get_egid = (<span class="kw">fun</span> () -&gt; root_gid); <span class="co">(* coverage:unused -this field is overwritten by the only call to full_permissions *)</span>

     cp_has_dir_search_permission = (<span class="kw">fun</span> _ _ -&gt; <span class="kw">true</span>);
     cp_has_dir_read_permission = (<span class="kw">fun</span> _ _ -&gt; <span class="kw">true</span>);
     cp_has_dir_write_permission = (<span class="kw">fun</span> _ _ -&gt; <span class="kw">true</span>);
     cp_has_dir_chmod_permission = (<span class="kw">fun</span> _ _ -&gt; <span class="kw">true</span>);
     cp_has_dir_chown_permission = (<span class="kw">fun</span> _ _ -&gt; <span class="kw">true</span>);

     cp_has_file_execute_permission = (<span class="kw">fun</span> _ _ -&gt; <span class="kw">true</span>); <span class="co">(* coverage:unused -this field is overwritten by the only call to full_permissions *)</span>
     cp_has_file_read_permission = (<span class="kw">fun</span> _ _ -&gt; <span class="kw">true</span>);
     cp_has_file_write_permission = (<span class="kw">fun</span> _ _ -&gt; <span class="kw">true</span>);
     cp_has_file_chmod_permission = (<span class="kw">fun</span> _ _ -&gt; <span class="kw">true</span>);
     cp_has_file_chown_permission = (<span class="kw">fun</span> _ _ -&gt; <span class="kw">true</span>);

     cp_has_dir_link_create_privilege = (<span class="kw">fun</span> _ _ -&gt; <span class="kw">true</span>); <span class="co">(* coverage:unused -this field is overwritten by the only call to full_permissions *)</span>
     cp_has_dir_restricted_delete_privilege = (<span class="kw">fun</span> _ _ _ _ -&gt; <span class="kw">true</span>);
     cp_has_file_restricted_delete_privilege = (<span class="kw">fun</span> _ _ _ _ -&gt; <span class="kw">true</span>);
  |&gt;


  <span class="co">(* ..................... *)</span>
  <span class="co">(* superuser permissions *)</span>
  <span class="co">(* ..................... *)</span>

  <span class="co">(* superuser_permissions models the permissions of a superuser.</span>
<span class="co">     Only a tiny bit more restrictive than full_permissions (e.g. when</span>
<span class="co">     asking for execute permission) *)</span>

  <span class="co">(* check whether anyone is allowed to execute the file *)</span>
  <span class="kw">val</span> anyone_has_file_execute_permission : forall &#39;dir_ref &#39;file_ref &#39;impl. 
    fs_ops &#39;dir_ref &#39;file_ref &#39;impl -&gt;  
    &#39;impl -&gt; &#39;file_ref -&gt; <span class="dt">bool</span> 
  <span class="kw">let</span> anyone_has_file_execute_permission ops s0 i0_ref =
    <span class="kw">let</span> i0_stats = ops.fops_stat_file s0 i0_ref <span class="kw">in</span> <span class="co">(* coverage:linux:irrelevant *)</span>
    <span class="kw">let</span> i0_perms = i0_stats.st_perm <span class="kw">in</span> <span class="co">(* coverage:linux:irrelevant *)</span>
    check_file_perms i0_perms <span class="dt">S_IXUSR</span> <span class="co">(* coverage:linux:irrelevant *)</span>
    ||
    check_file_perms i0_perms <span class="dt">S_IXGRP</span> <span class="co">(* coverage:linux:irrelevant *)</span>
    ||
    check_file_perms i0_perms <span class="dt">S_IXOTH</span> <span class="co">(* coverage:linux:irrelevant *)</span>

  <span class="kw">val</span> superuser_permissions : forall &#39;dir_ref &#39;file_ref &#39;impl. 
     fs_ops &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     uid -&gt; gid -&gt; file_perm -&gt; 
     check_permissions &#39;dir_ref &#39;file_ref &#39;impl
  <span class="kw">let</span> superuser_permissions ops uid gid umask = &lt;| full_permissions <span class="kw">with</span>
     cp_get_euid = (<span class="kw">fun</span> () -&gt; uid);
     cp_get_egid = (<span class="kw">fun</span> () -&gt; gid);
     cp_has_file_execute_permission = anyone_has_file_execute_permission ops; <span class="co">(* coverage:linux:irrelevant *)</span>
     cp_has_dir_link_create_privilege = (<span class="kw">fun</span> _ _ -&gt; <span class="kw">true</span>); <span class="co">(* allow superusers to create links to dirs,  posix/link.md EPERM:1 FIXME this depends on the underlying filesystem as well *)</span>
     cp_get_umask = (<span class="kw">fun</span> _ -&gt; umask); 
  |&gt;


  <span class="co">(* ............... *)</span>
  <span class="co">(* uid_permissions *)</span>
  <span class="co">(* ............... *)</span>

  <span class="co">(* uid_permissions gets the effective user uid from the process running. It then checks the permissions</span>
<span class="co">     for this user *)</span>

  <span class="kw">val</span> uid_has_dir_permission : forall &#39;dir_ref &#39;file_ref &#39;impl. 
    environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
    (uid -&gt; gid -&gt; <span class="dt">bool</span>) -&gt;
    uid -&gt; permission_type -&gt; &#39;impl -&gt; &#39;dir_ref -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> uid_has_dir_permission env in_group uid pt s0 d0_ref =
    <span class="kw">let</span> d0_stats = env.env_ops.fops_stat_dir s0 d0_ref <span class="kw">in</span>
    uid_check_permission env in_group uid pt d0_stats

  <span class="kw">val</span> uid_has_file_permission : forall &#39;dir_ref &#39;file_ref &#39;impl. 
    environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
    (uid -&gt; gid -&gt; <span class="dt">bool</span>) -&gt;
    uid -&gt; permission_type -&gt; &#39;impl -&gt; &#39;file_ref -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> uid_has_file_permission env in_group uid pt s0 i0_ref =
    <span class="kw">let</span> i0_stats = env.env_ops.fops_stat_file s0 i0_ref <span class="kw">in</span>
    uid_check_permission env in_group uid pt i0_stats

  <span class="co">(* [uid_has_restricted_delete_privilege ops uid allow_write s0 dir_stats file_stats] implements the</span>
<span class="co">     check, whether a file or directory can be deleted from a protected directory </span>
<span class="co">     (see posix/dir_protect.md). It is an auxiliary function used for both files and</span>
<span class="co">     directories. It gets only the stats, not a link to the file or it&#39;s parent dir.</span>
<span class="co">     Wrapper functions acquire these stats. *)</span>
  <span class="kw">val</span> uid_has_restricted_delete_privilege : forall &#39;dir_ref &#39;file_ref &#39;impl. 
    environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
    (uid -&gt; gid -&gt; <span class="dt">bool</span>) -&gt;
    uid -&gt; <span class="dt">bool</span> -&gt; 
    ty_stats -&gt; ty_stats -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> uid_has_restricted_delete_privilege env in_group uid allow_write dir_stats file_stats = (
    <span class="co">(* abort if there is no write permission on the directory. In this case, one</span>
<span class="co">       does not have delete permission, but the restricted one is fine. This is important</span>
<span class="co">       since a different error is raised if write permission is missing by e.g. rename or rm. </span>
<span class="co">       (see e.g. posix/rename.md EACCES:2 EPERM:1). *)</span>
    <span class="kw">if</span> (not (uid_check_permission env in_group uid <span class="dt">Perm_write</span> dir_stats)) <span class="kw">then</span> <span class="kw">true</span> <span class="kw">else</span> 

    <span class="co">(* Similarly abort, if the parent directory is not protected. *)</span>
    <span class="kw">let</span> dir_is_protected = check_file_perms dir_stats.st_perm <span class="dt">S_ISVTX</span> <span class="kw">in</span>
    <span class="kw">if</span> (not dir_is_protected) <span class="kw">then</span> <span class="kw">true</span> <span class="kw">else</span> <span class="kw">begin</span>
       (uid = file_stats.st_uid) || 
       (uid = dir_stats.st_uid) ||
       (allow_write
         &amp;&amp; (uid_check_permission env in_group uid <span class="dt">Perm_write</span> file_stats)) <span class="co">(* coverage:impossible -there are no architectures that have arch_allows_removing_from_protected_dir_if_writeable set to true, so allow_write is always false*)</span>
    <span class="kw">end</span>
  )

  <span class="kw">val</span> uid_has_dir_restricted_delete_privilege : forall &#39;dir_ref &#39;file_ref &#39;impl. 
    environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
    (uid -&gt; gid -&gt; <span class="dt">bool</span>) -&gt;
    uid -&gt; <span class="dt">bool</span> -&gt; &#39;impl -&gt;
    &#39;dir_ref -&gt; &#39;dir_ref -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> uid_has_dir_restricted_delete_privilege env in_group uid allow_write s0 parent_dir_ref dir_ref =
    <span class="kw">let</span> parent_dir_stats = env.env_ops.fops_stat_dir s0 parent_dir_ref <span class="kw">in</span>
    <span class="kw">let</span> dir_stats = env.env_ops.fops_stat_dir s0 dir_ref <span class="kw">in</span>
    uid_has_restricted_delete_privilege env in_group uid allow_write parent_dir_stats dir_stats

  <span class="kw">val</span> uid_has_file_restricted_delete_privilege : forall &#39;dir_ref &#39;file_ref &#39;impl. 
    environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
    (uid -&gt; gid -&gt; <span class="dt">bool</span>) -&gt;
    uid -&gt; <span class="dt">bool</span> -&gt; &#39;impl -&gt;
    &#39;dir_ref -&gt; &#39;file_ref -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> uid_has_file_restricted_delete_privilege env in_group uid allow_write s0 parent_dir_ref file_ref =
    <span class="kw">let</span> parent_dir_stats = env.env_ops.fops_stat_dir s0 parent_dir_ref <span class="kw">in</span>
    <span class="kw">let</span> file_stats = env.env_ops.fops_stat_file s0 file_ref <span class="kw">in</span>
    uid_has_restricted_delete_privilege env in_group uid allow_write parent_dir_stats file_stats

  <span class="kw">val</span> uid_owns_file : forall &#39;dir_ref &#39;file_ref &#39;impl. 
    environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
    uid -&gt; 
    &#39;impl -&gt;
    &#39;file_ref -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> uid_owns_file env uid s0 file_ref =
    <span class="kw">let</span> file_stats = env.env_ops.fops_stat_file s0 file_ref <span class="kw">in</span>
    (file_stats.st_uid = uid)

  <span class="kw">val</span> uid_owns_dir : forall &#39;dir_ref &#39;file_ref &#39;impl. 
    environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
    uid -&gt; 
    &#39;impl -&gt;
    &#39;dir_ref -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> uid_owns_dir env uid s0 dir_ref =
    <span class="kw">let</span> file_stats = env.env_ops.fops_stat_dir s0 dir_ref <span class="kw">in</span>
    (file_stats.st_uid = uid)

  <span class="kw">val</span> uid_permissions : forall &#39;dir_ref &#39;file_ref &#39;impl. 
    environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
    (uid -&gt; gid -&gt; <span class="dt">bool</span>) -&gt;
    uid -&gt; gid -&gt; file_perm -&gt;
    check_permissions &#39;dir_ref &#39;file_ref &#39;impl
  <span class="kw">let</span> uid_permissions env in_group uid gid umask = &lt;|
     cp_get_umask = (<span class="kw">fun</span> _ -&gt; umask);
     cp_get_euid = (<span class="kw">fun</span> () -&gt; uid);
     cp_get_egid = (<span class="kw">fun</span> () -&gt; gid);

     cp_has_dir_search_permission  = uid_has_dir_permission env in_group uid <span class="dt">Perm_execute_search</span>;
     cp_has_dir_read_permission    = uid_has_dir_permission env in_group uid <span class="dt">Perm_read</span>;
     cp_has_dir_write_permission   = uid_has_dir_permission env in_group uid <span class="dt">Perm_write</span>;
     cp_has_dir_chmod_permission   = uid_owns_dir env uid;
     cp_has_dir_chown_permission   = uid_owns_dir env uid;

     cp_has_file_execute_permission= uid_has_file_permission env in_group uid <span class="dt">Perm_execute_search</span>;
     cp_has_file_read_permission   = uid_has_file_permission env in_group uid <span class="dt">Perm_read</span>;
     cp_has_file_write_permission  = uid_has_file_permission env in_group uid <span class="dt">Perm_write</span>;
     cp_has_file_chmod_permission  = uid_owns_file env uid;
     cp_has_file_chown_permission  = uid_owns_file env uid;

     cp_has_dir_link_create_privilege = (<span class="kw">fun</span> _ _ -&gt; <span class="kw">false</span>); 

     cp_has_dir_restricted_delete_privilege = uid_has_dir_restricted_delete_privilege env in_group uid;
     cp_has_file_restricted_delete_privilege = uid_has_file_restricted_delete_privilege env in_group uid;
  |&gt;


  <span class="co">(* ------------------------------------ *)</span>
  <span class="co">(* user management                      *)</span>
  <span class="co">(* ------------------------------------ *)</span>

  <span class="kw">val</span> get_uids_in_gid : forall &#39;dir_ref &#39;file_ref &#39;impl. ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt; gid -&gt; finset uid
  <span class="kw">let</span> get_uids_in_gid s gid =
    <span class="kw">match</span> fmap_lookup s.oss_group_table gid <span class="kw">with</span>
      | <span class="dt">Nothing</span> -&gt; finset_empty ()
      | <span class="dt">Just</span> uids -&gt; uids
    end

  <span class="kw">val</span> is_uid_in_gid : forall &#39;dir_ref &#39;file_ref &#39;impl. ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt; uid -&gt; gid -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> is_uid_in_gid s uid gid = finset_mem uid (get_uids_in_gid s gid)

  <span class="kw">val</span> add_uid_to_gid : forall &#39;dir_ref &#39;file_ref &#39;impl. 
    ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt; uid -&gt; gid -&gt; ty_os_state &#39;dir_ref &#39;file_ref &#39;impl
  <span class="kw">let</span> add_uid_to_gid s uid gid = (
    <span class="kw">let</span> current_uids = get_uids_in_gid s gid <span class="kw">in</span>
    <span class="kw">let</span> new_uids = finset_insert uid current_uids <span class="kw">in</span>
    <span class="kw">let</span> new_groups = fmap_update s.oss_group_table (gid, new_uids) <span class="kw">in</span>
    &lt;| s <span class="kw">with</span> oss_group_table = new_groups |&gt;
  )

end
<span class="ot">#endif</span>


<span class="co">(******************************************************************************)</span>
<span class="co">(* Resolving paths                                                            *)</span>
<span class="co">(******************************************************************************)</span>

<span class="co">(**</span>
<span class="co">## Resolve names</span>

<span class="co">Update: we first process the string to give a list of entries; /a/b/c -&gt; [&quot;&quot;;&quot;a&quot;;&quot;b&quot;;&quot;c&quot;]; /a/b/c/ -&gt; [&quot;&quot;;&quot;a&quot;;&quot;b&quot;;&quot;c&quot;;&quot;&quot;]; a/b/c -&gt; [&quot;a&quot;;&quot;b&quot;;&quot;c&quot;]; note that [] is not in the range of this function; the empty string &quot;&quot; maps to [&quot;&quot;]. We keep this first list because we may need to examine it at some points. </span>

<span class="co">FIXME we need to distinguish between a null string and an empty string</span>

<span class="co">what about a relative path that is empty? in this case, it appears that this is returned as an error ENOENT (so the CWD is not appended in this case)</span>

<span class="co">interestingly if you delete /tmp/d1 and a process is still in d1, the PWD for that process is /tmp/d1; and in /proc/pid/cwd it says &quot;/tmp/d1 (deleted)&quot;</span>


<span class="co">**)</span>
<span class="ot">module</span> Resolve = <span class="kw">struct</span>
 
  <span class="ot">open</span> T_fs_prelude
  <span class="ot">open</span> Fs_types
  <span class="ot">open</span> Fs_arch
<span class="ot">#ifdef aspect_perms</span>
  <span class="ot">open</span> Fs_permissions
<span class="ot">#endif</span>


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* real_path_dir_ref             *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">val</span> is_root_dir : forall &#39;dir_ref &#39;file_ref &#39;impl.
    fs_ops &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
    &#39;impl -&gt; 
    &#39;dir_ref -&gt; 
    <span class="dt">bool</span>
  <span class="kw">let</span> is_root_dir ops s0 d0_ref = (
    <span class="kw">let</span> root = (
      <span class="kw">match</span> ops.fops_get_root s0 <span class="kw">with</span>
      | <span class="dt">Nothing</span> -&gt; (failwith <span class="st">&quot;is_root_dir: impossible: no root&quot;</span>)
      | <span class="dt">Just</span> x -&gt; x <span class="kw">end</span>)
    <span class="kw">in</span>
    ops.fops_dir_ref_eq s0 root d0_ref)

  <span class="co">(* get the real path, given a dir_ref; the real path of &quot;/&quot; is [&quot;&quot;;&quot;&quot;] the real path of &quot;/n&quot; is [&quot;&quot;;&quot;n&quot;] *)</span>
  <span class="kw">val</span> real_path_dir_ref : forall &#39;dir_ref &#39;file_ref &#39;impl.
     fs_ops &#39;dir_ref &#39;file_ref &#39;impl -&gt; &#39;impl -&gt; 
     &#39;dir_ref -&gt; <span class="dt">list</span> name
  <span class="kw">let</span> <span class="kw">rec</span> real_path_dir_ref ops s0 d0_ref = (
    <span class="kw">match</span> (is_root_dir ops s0 d0_ref) <span class="kw">with</span>
     | <span class="kw">true</span> -&gt; [<span class="st">&quot;&quot;</span>;<span class="st">&quot;&quot;</span>]  <span class="co">(* if root, return the corresponding real path *)</span>
     | <span class="kw">false</span> -&gt; (
         <span class="kw">let</span> p = ops.fops_get_parent s0 d0_ref <span class="kw">in</span>
         (<span class="kw">match</span> p <span class="kw">with</span>
          | <span class="dt">Nothing</span> -&gt; (
              <span class="co">(* d0_ref is not root, but no parent; disconnected directory? *)</span>
              failwith <span class="st">&quot;real_path_dir_ref: disconnected directory? FIXME&quot;</span>)
          | <span class="dt">Just</span>(d1_ref,n) -&gt; (
              <span class="kw">if</span> (is_root_dir ops s0 d1_ref) <span class="kw">then</span> 
                [<span class="st">&quot;&quot;</span>;n] 
              <span class="kw">else</span>
                (real_path_dir_ref ops s0 d1_ref)++[n]) end)) end)


  <span class="co">(* Termination argument: </span>
<span class="co">     Why does real_path_dir_ref terminate? Informal argument: there is a fixed mapping to absolute dirs. *)</span>
  <span class="kw">val</span> fops_get_parent_OK_abs_map : forall &#39;a &#39;b &#39;c. <span class="dt">Eq</span> &#39;a =&gt; fs_ops &#39;a &#39;b &#39;c -&gt; &#39;c -&gt; (&#39;a -&gt; <span class="dt">list</span> <span class="dt">string</span>) -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> non_exec fops_get_parent_OK_abs_map ops s0 abs_map = (forall d0_ref.
    <span class="kw">match</span> (abs_map d0_ref) <span class="kw">with</span>
      | [] -&gt; (ops.fops_get_parent s0 d0_ref = <span class="dt">Nothing</span>)
      | (n :: ns) -&gt; ((n &lt;&gt; <span class="st">&quot;&quot;</span>) &amp;&amp; (n &lt;&gt; <span class="st">&quot;.&quot;</span>) &amp;&amp; (n &lt;&gt; <span class="st">&quot;..&quot;</span>) &amp;&amp;
          (exists d1_ref. (ops.fops_get_parent s0 d0_ref = <span class="dt">Just</span> (d1_ref, n)) &amp;&amp;
                          (abs_map d1_ref = ns)))
    end);;

  <span class="kw">let</span> non_exec fops_get_parent_OK ops s0 = (exists abs_map. fops_get_parent_OK_abs_map ops s0 abs_map);;
     
  theorem real_path_dir_ref_wf : (forall ops s0 d0_ref. fops_get_parent_OK ops s0 --&gt; 
     is_simple_absolute_path (real_path_dir_ref ops s0 d0_ref)) 


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* datatype for resolve results  *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* this is a cutdown version of res_name that is used</span>
<span class="co">     during resolution. Once resolution is finished, it is</span>
<span class="co">     transformed into a res_name by adding additional fields. *)</span>
  <span class="kw">type</span> ty_resolve_relative_result &#39;dir_ref &#39;file_ref = 
    <span class="dt">RR_dir</span> <span class="kw">of</span> &#39;dir_ref
  | <span class="dt">RR_file</span> <span class="kw">of</span> (&#39;dir_ref * name * &#39;file_ref)
  | <span class="dt">RR_none</span> <span class="kw">of</span> (&#39;dir_ref * name)
  | <span class="dt">RR_error</span> <span class="kw">of</span> (error * maybe (ty_resolve_relative_result &#39;dir_ref &#39;file_ref))

  <span class="kw">val</span> ty_resolve_relative_result2res_name : forall &#39;dir_ref &#39;file_ref &#39;impl.
     fs_ops &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     &#39;impl -&gt;
     &#39;dir_ref -&gt;
     ty_name_list -&gt;
     ty_resolve_relative_result &#39;dir_ref &#39;file_ref -&gt;
     res_name &#39;dir_ref &#39;file_ref
  <span class="kw">let</span> <span class="kw">rec</span> ty_resolve_relative_result2res_name ops s0 cwd nl x =
     <span class="kw">match</span> x <span class="kw">with</span>
       | <span class="dt">RR_dir</span> d0_ref -&gt; (
         <span class="kw">let</span> rp = &lt;| rp_cwd=cwd; rp_nl=nl; rp_ns=(real_path_dir_ref ops s0 d0_ref) |&gt; <span class="kw">in</span>
         <span class="dt">RN_dir</span>(d0_ref,rp))
       | <span class="dt">RR_file</span> (d0_ref,n,i0_ref) -&gt; (
         <span class="kw">let</span> rp = &lt;| rp_cwd=cwd; rp_nl=nl; rp_ns=((real_path_dir_ref ops s0 d0_ref)++[n]) |&gt; <span class="kw">in</span>
         <span class="dt">RN_file</span>(d0_ref,n,i0_ref,rp))
       | <span class="dt">RR_none</span> (d0_ref,n) -&gt; 
         <span class="kw">let</span> rp = &lt;| rp_cwd=cwd; rp_nl=nl; rp_ns=(real_path_dir_ref ops s0 d0_ref)++[n] |&gt; <span class="kw">in</span>
         <span class="dt">RN_none</span> (d0_ref,n,rp) 
       | <span class="dt">RR_error</span> (e, res_without_sl) -&gt; (<span class="dt">RN_error</span>(e,&lt;| re_cwd=cwd; re_nl=(<span class="dt">Just</span> nl); 
           re_rn=Maybe<span class="kw">.</span>map (ty_resolve_relative_result2res_name ops s0 cwd nl) res_without_sl |&gt;))
     end
  declare termination_argument ty_resolve_relative_result2res_name = automatic


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* split path into name lists    *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* [split_path_string] is the first processing step during path resolution.</span>
<span class="co">     It splits a path into a non-empty list of names separated by &quot;/&quot;. </span>
<span class="co">     See tests in fs_test/paths.testpath.ml and fs_test/testpath.native. The expected invariant is that</span>
<span class="co">     s |&gt; split_path_string |&gt; ty_name_list_to_list |&gt; String.concat &quot;/&quot; should be the identity.</span>
<span class="co">  *)</span>
  <span class="kw">val</span> split_path_string : <span class="dt">string</span> -&gt; ty_name_list
  <span class="kw">let</span> split_path_string path = (
    <span class="kw">let</span> p = String<span class="kw">.</span>toCharList path <span class="kw">in</span>
    <span class="kw">let</span> f1 ((ns:<span class="dt">list</span> <span class="dt">string</span>),(cur:<span class="dt">list</span> <span class="dt">char</span>)) c = (<span class="kw">if</span> c=#<span class="ch">&#39;/&#39;</span> <span class="kw">then</span> (ns++[String<span class="kw">.</span>toString (reverse cur)],[]) <span class="kw">else</span> (ns,c::cur)) <span class="kw">in</span>
    <span class="kw">let</span> (ns,cur) = List<span class="kw">.</span>foldl f1 ([],[]) p <span class="kw">in</span>
    <span class="kw">let</span> ns = ns++[String<span class="kw">.</span>toString (reverse cur)] <span class="kw">in</span>
    make_ty_name_list ns) <span class="co">(* invariant: ns is not [] - see line above! *)</span>

  <span class="co">(* inverse of split_path_string *)</span>
  <span class="kw">val</span> ty_name_list_to_string: ty_name_list -&gt; <span class="dt">string</span>
  <span class="kw">let</span> ty_name_list_to_string tnl = (
    <span class="kw">match</span> tnl <span class="kw">with</span>
    | <span class="dt">Name_list</span> (n,nl) -&gt; 
      <span class="kw">let</span> f1 sofar n = sofar^<span class="st">&quot;/&quot;</span>^n <span class="kw">in</span>
      List<span class="kw">.</span>foldl f1 n nl end)


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* resolve_relative              *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* whether to follow the last symlink when resolving paths for a command; apart from OS_CHXXX, the default appears to be false, but POSIX does resolve if a trailing slash whereas Linux typically doesn&#39;t *)</span>
  <span class="kw">val</span> follow_last_symlink : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     ty_os_command -&gt;
     <span class="dt">bool</span>
  <span class="kw">let</span> follow_last_symlink env cmd = (
    <span class="kw">let</span> arch = architecture_of_ty_arch env.env_arch <span class="kw">in</span>
    <span class="kw">let</span> dummy = <span class="kw">true</span> <span class="kw">in</span> <span class="co">(* some commands don&#39;t have paths, so follow_last_symlink is irrelevant *)</span>
    <span class="kw">match</span> cmd <span class="kw">with</span>
    | <span class="dt">OS_CLOSE</span> _ -&gt; dummy <span class="co">(* coverage:impossible -this command does not use path, so follow_last_symlink is never called on it *)</span>
    | <span class="dt">OS_LINK</span> _ -&gt; (
        <span class="kw">if</span> is_mac_os_x_arch env <span class="kw">then</span> 
          <span class="kw">true</span>  <span class="co">(* check_exec_adhoc_symlink_tests-int.trace link &quot;/dir_link&quot; &quot;/dir_4&quot; ; mac follows /dir_link and result is EPERM *)</span>
        <span class="kw">else</span> 
          <span class="kw">false</span>)
    | <span class="dt">OS_MKDIR</span> _ -&gt; <span class="kw">false</span> 
    | <span class="dt">OS_OPEN</span> (p,fs,mo) -&gt; (
      <span class="kw">let</span> oflags = arch.arch_open_flags_of_int fs <span class="kw">in</span> 
      <span class="kw">if</span> finset_mem <span class="dt">O_EXCL</span> oflags &amp;&amp; finset_mem <span class="dt">O_CREAT</span> oflags <span class="kw">then</span>
        <span class="kw">false</span>  <span class="co">(* posix/open.md O_EXCL:3 , don&#39;t follow if O_EXCL and O_CREAT *)</span>
      <span class="kw">else</span> <span class="kw">if</span> finset_mem <span class="dt">O_NOFOLLOW</span> oflags <span class="kw">then</span>  <span class="co">(* posix/open.md ELOOP:1 *)</span>
        <span class="kw">false</span>
      <span class="kw">else</span>
        <span class="kw">true</span>)
    | <span class="dt">OS_PREAD</span> _ -&gt; dummy <span class="co">(* coverage:impossible -this command does not use path, so follow_last_symlink is never called on it *)</span>
    | <span class="dt">OS_READ</span> _ -&gt; dummy <span class="co">(* coverage:impossible -this command does not use path, so follow_last_symlink is never called on it *)</span>
    | <span class="dt">OS_READDIR</span> _ -&gt; dummy <span class="co">(* coverage:impossible -this command does not use path, so follow_last_symlink is never called on it *)</span>
    | <span class="dt">OS_OPENDIR</span> _ -&gt; <span class="kw">true</span>  <span class="co">(* can&#39;t opendir a symlink *)</span>
    | <span class="dt">OS_REWINDDIR</span> _ -&gt; dummy <span class="co">(* coverage:impossible -this command does not use path, so follow_last_symlink is never called on it *)</span>
    | <span class="dt">OS_CLOSEDIR</span> _ -&gt; dummy <span class="co">(* coverage:impossible -this command does not use path, so follow_last_symlink is never called on it *)</span>
    | <span class="dt">OS_READLINK</span> _ -&gt; <span class="kw">false</span> <span class="co">(* FIXME on Linux, it does follow if there is a trailing slash *)</span>
    | <span class="dt">OS_RENAME</span> _ -&gt; <span class="kw">false</span>  <span class="co">(* FIXME false on Linux, but under posix should this be true? cf POSIX/Linux differences with rename of link to dir *)</span>
    | <span class="dt">OS_RMDIR</span> _ -&gt; <span class="kw">false</span> <span class="co">(* FIXME really? *)</span>
    | <span class="dt">OS_STAT</span> _ -&gt; <span class="kw">true</span>
    | <span class="dt">OS_LSTAT</span> _ -&gt; <span class="kw">false</span> <span class="co">(* lstat doesn&#39;t follow *)</span>
    | <span class="dt">OS_SYMLINK</span> _ -&gt; <span class="kw">false</span>
    | <span class="dt">OS_TRUNCATE</span> _ -&gt; <span class="kw">true</span>  <span class="co">(* can&#39;t truncate a link *)</span>
    | <span class="dt">OS_UNLINK</span> _ -&gt; <span class="kw">false</span>
    | <span class="dt">OS_PWRITE</span> _ -&gt; dummy <span class="co">(* coverage:impossible -this command does not use path, so follow_last_symlink is never called on it *)</span>
    | <span class="dt">OS_WRITE</span> _ -&gt; dummy <span class="co">(* coverage:impossible -this command does not use path, so follow_last_symlink is never called on it *)</span>
    | <span class="dt">OS_UMASK</span> _ -&gt; dummy <span class="co">(* coverage:impossible -this command does not use path, so follow_last_symlink is never called on it *)</span>
    | <span class="dt">OS_CHMOD</span> _ -&gt; <span class="kw">true</span>
    | <span class="dt">OS_CHOWN</span> _ -&gt; <span class="kw">true</span>
    | <span class="dt">OS_CHDIR</span> _ -&gt; <span class="kw">true</span>
    | <span class="dt">OS_LSEEK</span> _ -&gt; dummy <span class="co">(* coverage:impossible -this command does not use path, so follow_last_symlink is never called on it *)</span>
    | <span class="dt">OS_EXTENDED_CMD</span> _ -&gt; dummy <span class="co">(* only matters for OPEN_CLOSE, where hopefully we don&#39;t use it on a symlink *)</span>
    end)

  <span class="kw">let</span> is_OS_READLINK cmd = (<span class="kw">match</span> cmd <span class="kw">with</span> <span class="dt">OS_READLINK</span> _ -&gt; <span class="kw">true</span> | _ -&gt; <span class="kw">false</span> end) <span class="co">(* coverage:mac_os_x:posix:irrelevant - used only in a case for linux only *)</span>

  <span class="kw">let</span> is_OS_LSTAT cmd = (<span class="kw">match</span> cmd <span class="kw">with</span> <span class="dt">OS_LSTAT</span> _ -&gt; <span class="kw">true</span> | _ -&gt; <span class="kw">false</span> end) <span class="co">(* coverage:mac_os_x:posix:irrelevant - used only in a case for linux only *)</span>

  <span class="kw">type</span> rr_params &#39;dir_ref &#39;file_ref &#39;impl = &lt;| rr_env: environment &#39;dir_ref &#39;file_ref &#39;impl; rr_s0: &#39;impl; rr_cmd: ty_os_command |&gt;


  <span class="co">(* in order to make the recursive structure clear (for theorem</span>
<span class="co">     provers, and humans) auxiliary functions don&#39;t recurse directly, but</span>
<span class="co">     return the result of processing, which may be [RR_final] to indicate</span>
<span class="co">     that processing is finished, or [RR_inter] to indicate that further</span>
<span class="co">     processing should happen *)</span>

  <span class="kw">type</span> rr_input &#39;dir_ref = &lt;| rr_symlinks_so_far: nat; rr_so_far: &#39;dir_ref; rr_ns: <span class="dt">list</span> <span class="dt">string</span> |&gt;

  <span class="kw">type</span> rr_output &#39;dir_ref &#39;file_ref = 
    | <span class="dt">RR_inter</span> <span class="kw">of</span> rr_input &#39;dir_ref 
    | <span class="dt">RR_final</span> <span class="kw">of</span> ty_resolve_relative_result &#39;dir_ref &#39;file_ref

  <span class="kw">val</span> rr_dot_dot : forall &#39;dir_ref &#39;file_ref &#39;impl.
    rr_params &#39;dir_ref &#39;file_ref &#39;impl -&gt;
    nat -&gt;
    &#39;dir_ref -&gt;
    <span class="dt">list</span> <span class="dt">string</span> -&gt;
    rr_output &#39;dir_ref &#39;file_ref
  <span class="kw">let</span> rr_dot_dot ps symlinks_so_far so_far ns =
    (<span class="kw">match</span> ps.rr_env.env_ops.fops_get_parent ps.rr_s0 so_far <span class="kw">with</span>
    | <span class="dt">Nothing</span> -&gt; (<span class="dt">RR_inter</span> &lt;| rr_symlinks_so_far=symlinks_so_far; rr_so_far=so_far; rr_ns=ns |&gt;)
        <span class="co">(* FIXME not correct for disconnected dirs - should probably throw an exception ENOENT *)</span>
    | <span class="dt">Just</span>(dir_ref,_) -&gt; (<span class="dt">RR_inter</span> &lt;| rr_symlinks_so_far=symlinks_so_far; rr_so_far=dir_ref; rr_ns=ns |&gt;) end)

  <span class="co">(* i0_ref is a symlink *)</span>
  <span class="kw">val</span> rr_symlink : forall &#39;dir_ref &#39;file_ref &#39;impl.
    rr_params &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
    nat -&gt;
    &#39;dir_ref -&gt; 
    <span class="dt">list</span> <span class="dt">string</span> -&gt; 
    <span class="dt">string</span> -&gt;
    &#39;file_ref -&gt;
    rr_output &#39;dir_ref &#39;file_ref
  <span class="kw">let</span> rr_symlink ps symlinks_so_far so_far ns n i0_ref = (
    <span class="co">(* process a symlink *)</span>
    <span class="co">(* do we follow the symlink? *)</span>
    <span class="kw">let</span> is_last_component = List<span class="kw">.</span>all (<span class="kw">fun</span> s -&gt; s=<span class="st">&quot;&quot;</span>) ns <span class="kw">in</span> <span class="co">(* the last component is n in .../n or .../n//// *)</span>
    <span class="kw">let</span> follow_last_symlink = follow_last_symlink ps.rr_env ps.rr_cmd <span class="kw">in</span>  <span class="co">(* whether to follow last symlink depends mainly on the command *)</span>
    <span class="kw">let</span> follow_symlink = (
      <span class="kw">match</span> is_linux_arch ps.rr_env <span class="kw">with</span>
      | <span class="kw">true</span> -&gt; (
        <span class="kw">if</span> is_last_component <span class="kw">then</span>  <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
          follow_last_symlink  <span class="co">(* regardless of trailing slashes *)</span>  <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
          || (
            <span class="kw">let</span> is_os_open_nofollow = (<span class="kw">match</span> ps.rr_cmd <span class="kw">with</span> 
                | <span class="dt">OS_OPEN</span> (_,fs,_) -&gt; (
                    <span class="kw">let</span> arch = architecture_of_ty_arch ps.rr_env.env_arch <span class="kw">in</span>
                    <span class="kw">let</span> oflags = arch.arch_open_flags_of_int fs <span class="kw">in</span> 
                    (finset_mem <span class="dt">O_NOFOLLOW</span> oflags))
                | _ -&gt; <span class="kw">false</span> end)
            <span class="kw">in</span>
            (is_OS_READLINK ps.rr_cmd || is_OS_LSTAT ps.rr_cmd || is_os_open_nofollow) &amp;&amp; ns &lt;&gt; [])  <span class="co">(* ie readlink symlink/ or lstat symlink/ or open [O_NOFOLLOW] symlink/, in which case do follow *)</span>  <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
        <span class="kw">else</span>
          <span class="kw">true</span><span class="co">(*ns &lt;&gt; [] || follow_last_symlink *)</span>) <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
      | <span class="kw">false</span> -&gt; ( <span class="co">(*coverage:linux:irrelevant*)</span>
        ns &lt;&gt; []  <span class="co">(* if used as a directory, link is always followed except under Linux *)</span> <span class="co">(*coverage:linux:irrelevant*)</span>
        || follow_last_symlink) end) <span class="co">(* if last component, then as follow_last_symlink *)</span> <span class="co">(*coverage:linux:irrelevant*)</span>
    <span class="kw">in</span>
    (<span class="kw">match</span> follow_symlink <span class="kw">with</span>
    | <span class="kw">true</span> -&gt; (
      <span class="co">(* check whether too many symbolic links have already been followed *)</span>
      <span class="kw">if</span> (symlinks_so_far &gt;= ps.rr_env.env_ops.fops_lookup_sysconf ps.rr_s0 <span class="dt">SC_SYMLOOP_MAX</span>) <span class="kw">then</span> <span class="dt">RR_final</span> (<span class="dt">RR_error</span>(<span class="dt">ELOOP</span>, <span class="dt">Nothing</span>)) <span class="kw">else</span>
      <span class="co">(* read the link contents *)</span>
      <span class="kw">let</span> bs = ps.rr_env.env_ops.fops_readlink ps.rr_s0 i0_ref <span class="kw">in</span>
      <span class="kw">let</span> s = T_list_array<span class="kw">.</span>to_string bs <span class="kw">in</span>
      <span class="co">(* at this point, we need to process bs as a path, possibly an absolute path *)</span>
      <span class="kw">let</span> nl = split_path_string s <span class="kw">in</span>
      <span class="kw">if</span> nl_starts_with_slash nl <span class="kw">then</span>
        <span class="kw">let</span> root = fromJust (ps.rr_env.env_ops.fops_get_root ps.rr_s0) <span class="kw">in</span>
        <span class="dt">RR_inter</span> &lt;| rr_symlinks_so_far=(succ symlinks_so_far); rr_so_far=root; rr_ns=(ty_name_list_to_list nl ++ ns) |&gt;
      <span class="kw">else</span>
        <span class="dt">RR_inter</span> &lt;| rr_symlinks_so_far=(succ symlinks_so_far); rr_so_far=so_far; rr_ns=(ty_name_list_to_list nl ++ ns) |&gt;)
    | <span class="kw">false</span> -&gt; (
      <span class="co">(* in this case, ns=[] and ps.rr_follow_last_symlink was false; return the symlink itself *)</span>
      <span class="dt">RR_final</span> (<span class="dt">RR_file</span>(so_far,n,i0_ref)) <span class="co">(* if we are at the end, return the file *)</span>) end))

  <span class="kw">val</span> alt_rr : forall &#39;dir_ref &#39;file_ref &#39;impl.
     rr_params &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     nat -&gt;
     &#39;dir_ref -&gt; <span class="dt">list</span> <span class="dt">string</span> -&gt; 
     ty_resolve_relative_result &#39;dir_ref &#39;file_ref
  <span class="kw">let</span> <span class="kw">rec</span> alt_rr ps symlinks_so_far so_far ns = (
    (<span class="kw">match</span> ns <span class="kw">with</span> 
    | [] -&gt; (<span class="dt">RR_dir</span>(so_far))
    | n::ns -&gt; (
<span class="ot">#ifdef aspect_perms</span>
      <span class="co">(* if we have no search permission on component n, raise EACCES, except</span>
<span class="co">         on Linux for the parent directory *)</span>
      <span class="kw">if</span> ((not (ps.rr_env.env_prms.cp_has_dir_search_permission ps.rr_s0 so_far)) &amp;&amp;
          (not (is_linux_arch ps.rr_env &amp;&amp; (n = <span class="st">&quot;&quot;</span>))))  <span class="kw">then</span> <span class="co">(* FIXME trace? *)</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
          <span class="dt">RR_error</span>(<span class="dt">EACCES</span>, <span class="dt">Nothing</span>) <span class="kw">else</span>
<span class="ot">#endif</span>
      <span class="kw">let</span> is_last_component = List<span class="kw">.</span>all (<span class="kw">fun</span> s -&gt; s=<span class="st">&quot;&quot;</span>) ns <span class="kw">in</span> <span class="co">(* the last component is n in .../n or .../n//// *)</span>
      (<span class="kw">match</span> n <span class="kw">with</span>
      <span class="co">(* process empty and . and .. entries *)</span>
      | <span class="st">&quot;&quot;</span> -&gt; (alt_rr ps symlinks_so_far so_far ns)
      | <span class="st">&quot;.&quot;</span> -&gt; (alt_rr ps symlinks_so_far so_far ns)
      | <span class="st">&quot;..&quot;</span> -&gt; (<span class="kw">match</span> rr_dot_dot ps symlinks_so_far so_far ns <span class="kw">with</span>
        | <span class="dt">RR_inter</span> i0 -&gt; alt_rr ps i0.rr_symlinks_so_far i0.rr_so_far i0.rr_ns
        | <span class="dt">RR_final</span> r -&gt; r end) <span class="co">(* coverage:impossible - rr_dot_dot can only return RR_inter *)</span>
      | _ -&gt; (
      <span class="co">(* try and resolve n (the next path component) *)</span>
      <span class="kw">let</span> m = ps.rr_env.env_ops.fops_resolve ps.rr_s0 so_far n <span class="kw">in</span>
      (<span class="kw">match</span> m <span class="kw">with</span> 
      | <span class="dt">Nothing</span> -&gt; (<span class="kw">if</span> is_last_component <span class="kw">then</span> <span class="dt">RR_none</span>(so_far,n) <span class="kw">else</span> <span class="dt">RR_error</span>(<span class="dt">ENOENT</span>, <span class="dt">Nothing</span>))  <span class="co">(* posix/rename.md ENOENT:2; posix/link.md ENOENT:1; posix/rmdir.md ENOENT:2 *)</span>
      | <span class="dt">Just</span> entry -&gt; (  <span class="co">(* process the entry corresponding to n *)</span>
        (<span class="kw">match</span> entry <span class="kw">with</span> 
        | <span class="dt">Dir_ref_entry</span> d0_ref -&gt; (alt_rr ps symlinks_so_far d0_ref ns)
        | <span class="dt">File_ref_entry</span> i0_ref -&gt; (
          <span class="kw">let</span> is_symlink = ((ps.rr_env.env_ops.fops_stat_file ps.rr_s0 i0_ref).st_kind = <span class="dt">S_IFLNK</span>) <span class="kw">in</span>
          (<span class="kw">match</span> is_symlink <span class="kw">with</span> 
          | <span class="kw">true</span> -&gt; (<span class="kw">match</span> rr_symlink ps symlinks_so_far so_far ns n i0_ref <span class="kw">with</span>
            | <span class="dt">RR_inter</span> i0 -&gt; alt_rr ps i0.rr_symlinks_so_far i0.rr_so_far i0.rr_ns
            | <span class="dt">RR_final</span> r -&gt; r end)
          | <span class="kw">false</span> -&gt; (<span class="kw">match</span> ns <span class="kw">with</span>
            | [] -&gt; (<span class="dt">RR_file</span>(so_far,n,i0_ref))  <span class="co">(* return if no more path components to process *)</span>
            | _ -&gt; (
              <span class="co">(* we got a file, which is not a symlink and it is not the last component during</span>
<span class="co">                 path resolution. So always raise an error. However, a common problem are trailing</span>
<span class="co">                 slashes. In this case raise and error, but also return the file found. *)</span>
              <span class="kw">let</span> opt = (<span class="kw">if</span> is_last_component <span class="kw">then</span> <span class="dt">Just</span> (<span class="dt">RR_file</span>(so_far,n,i0_ref)) <span class="kw">else</span> <span class="dt">Nothing</span>) <span class="kw">in</span>
              <span class="dt">RR_error</span>(<span class="dt">ENOTDIR</span>, opt)) end)  <span class="co">(* posix/rename.md ENOTDIR:1 ENOTDIR:3 ENOTDIR:5; posix/link.md ENOTDIR:1 ENOTDIR:3; FIXME posix/mkdir.md ENOENT:4 specifies that this may return ENOENT, but this is surely a POSIX specification error *)</span>
 end)) end)) end) ) end)) end))



  <span class="kw">val</span> resolve_relative : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     &#39;impl -&gt; ty_os_command -&gt; nat -&gt;
     &#39;dir_ref -&gt; <span class="dt">list</span> <span class="dt">string</span> -&gt; 
     ty_resolve_relative_result &#39;dir_ref &#39;file_ref
  <span class="kw">let</span> <span class="kw">rec</span> resolve_relative env s0 cmd symlinks_so_far so_far ns = (
    alt_rr &lt;| rr_env=env; rr_s0=s0; rr_cmd=cmd |&gt; symlinks_so_far so_far ns)

<span class="co">(*</span>
<span class="co">  let rec resolve_relative env s0 follow_last_symlink symlinks_so_far sofar ns = (</span>
<span class="co">    match ns with </span>
<span class="co">    | [] -&gt; (RR_dir(sofar))</span>
<span class="co">    | n::ns -&gt; (</span>
<span class="co">      (* process . and .. entries *)</span>
<span class="co">      if (n=&quot;.&quot;) || (n=&quot;&quot;) then (</span>
<span class="co">        resolve_relative env s0 follow_last_symlink symlinks_so_far sofar ns</span>
<span class="co">      ) else if (n=&quot;..&quot;) then (</span>
<span class="co">        (match env.env_ops.fops_get_parent s0 sofar with</span>
<span class="co">        | Nothing -&gt; (resolve_relative env s0 follow_last_symlink symlinks_so_far sofar ns) (* FIXME not correct for disconnected dirs *)</span>
<span class="co">        | Just(dir_ref,_) -&gt; (resolve_relative env s0 follow_last_symlink symlinks_so_far dir_ref ns) </span>
<span class="co">        end)</span>
<span class="co">#ifdef aspect_perms</span>
<span class="co">      ) else if (not (env.env_prms.cp_has_dir_search_permission s0 sofar)) then RR_error(EACCES, Nothing) else (</span>
<span class="co">#else</span>
<span class="co">      ) else (</span>
<span class="co">#endif</span>
<span class="co">        (* try and resolve n (the next path component) *)</span>
<span class="co">        let m = env.env_ops.fops_resolve s0 sofar n in</span>
<span class="co">        (match m with </span>
<span class="co">        | Nothing -&gt; (</span>
<span class="co">          if (ns=[]) || (ns=[&quot;&quot;]) then (* may end in a slash; FIXME what about multiple slashes? *)</span>
<span class="co">            RR_none(sofar,n)</span>
<span class="co">          else</span>
<span class="co">            RR_error(ENOENT, Nothing))  (* posix/rename.md ENOENT:2; posix/link.md ENOENT:1; posix/rmdir.md ENOENT:2 *)</span>
<span class="co">        | Just entry -&gt; (</span>
<span class="co">          (* process the entry corresponding to n *)</span>
<span class="co">          (match entry with </span>
<span class="co">          | File_ref_entry i0_ref -&gt; (</span>
<span class="co">            (* process a symlink *)</span>
<span class="co">            (* If i0_ref is a symlink, do we follow it? *)</span>
<span class="co">            let follow_symlink = </span>
<span class="co">              (* of course we only do it, if it is really a symlink *)</span>
<span class="co">              ((env.env_ops.fops_stat_file s0 i0_ref).st_kind = S_IFLNK) (* is it actually one *) &amp;&amp; (</span>
<span class="co">                 (* if used as a directory, it is always followed *)</span>
<span class="co">                 (ns &lt;&gt; []) ||</span>
<span class="co">                 (* if it is the last component, it depends on</span>
<span class="co">                    the command that requested the resolution. Commands like</span>
<span class="co">                    [open] want to follow the symlink, whereas e.g. [unlink] does</span>
<span class="co">                    not. The argument [follow_last_symlink] is used for this purpose. *)</span>
<span class="co">                 follow_last_symlink</span>
<span class="co">      ) in</span>
<span class="co">            if (follow_symlink) then </span>
<span class="co">              (* check whether too many symbolic links have already been followed *)</span>
<span class="co">              if (symlinks_so_far &gt;= env.env_ops.fops_lookup_sysconf s0 SC_SYMLOOP_MAX) then</span>
<span class="co">                RR_error(ELOOP, Nothing)</span>
<span class="co">              else (</span>
<span class="co">                let bs = env.env_ops.fops_readlink s0 i0_ref in</span>
<span class="co">                let s = T_list_array.to_string bs in</span>
<span class="co">                (* FIXME at this point, we need to process bs as a path, possibly an absolute path *)</span>
<span class="co">                let nl = split_path_string s in</span>
<span class="co">                if nl_starts_with_slash nl then</span>
<span class="co">                  let root = fromJust (env.env_ops.fops_get_root s0) in</span>
<span class="co">                  resolve_relative env s0 follow_last_symlink (succ symlinks_so_far) root (ty_name_list_to_list nl ++ ns)</span>
<span class="co">                else</span>
<span class="co">                  resolve_relative env s0 follow_last_symlink (succ symlinks_so_far) sofar (ty_name_list_to_list nl ++ ns) (* potentially non-terminating eg ln -s loop loop *)</span>
<span class="co">              )</span>
<span class="co">            (* return if no more path components to process *)</span>
<span class="co">            else if (ns=[]) then </span>
<span class="co">              RR_file(sofar,n,i0_ref) (* if we are at the end, return the file *)</span>
<span class="co">            else</span>
<span class="co">              (* we got a file, which is no symlink and it is not the last component</span>
<span class="co">                 during path resolution. So, we are in trouble. So always raise an error.</span>
<span class="co">                 However, a common problem are trailing slashes. In this case raise and error,</span>
<span class="co">                 but also return the file found. *)</span>
<span class="co">              (let res_without_slashes = (if (List.all (fun s -&gt; s = &quot;&quot;) ns) then Just (RR_file(sofar,n,i0_ref)) else Nothing) in</span>
<span class="co">               RR_error(ENOTDIR, res_without_slashes)))  (* posix/rename.md ENOTDIR:1 ENOTDIR:3 ENOTDIR:5; posix/link.md ENOTDIR:1 ENOTDIR:3; FIXME posix/mkdir.md ENOENT:4 specifies that this may return ENOENT, but this is surely a POSIX specification error *)</span>
<span class="co">          | Dir_ref_entry d0_ref -&gt; (</span>
<span class="co">            resolve_relative env s0 follow_last_symlink symlinks_so_far d0_ref ns) end)) end)) ) end)</span>
<span class="co">*)</span>

  <span class="co">(* if a path starts with two slashes, the behaviour is impl defined;</span>
<span class="co">     we don&#39;t want to deal with this in every command, so we have a</span>
<span class="co">     clause in os_trans that uses this definition *)</span>
  <span class="kw">val</span> path_starts_with_exactly_two_slashes : cstring -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> path_starts_with_exactly_two_slashes s = (
    <span class="kw">match</span> s <span class="kw">with</span> | <span class="dt">CS_Null</span> -&gt; <span class="kw">false</span> | <span class="dt">CS_Some</span> s -&gt;
      <span class="kw">let</span> nl = split_path_string s <span class="kw">in</span>
      (<span class="kw">match</span> (ty_name_list_to_list nl) <span class="kw">with</span>
      | (<span class="st">&quot;&quot;</span>::<span class="st">&quot;&quot;</span>::[]) -&gt; <span class="kw">false</span>  <span class="co">(* / *)</span>
      | (<span class="st">&quot;&quot;</span>::<span class="st">&quot;&quot;</span>::xs) -&gt; (
        <span class="co">(* starts with at least two slashes, but how many exactly? *)</span>
        <span class="kw">match</span> xs <span class="kw">with</span>
        | [] -&gt; (failwith <span class="st">&quot;impossible: case considered above&quot;</span>)
        | <span class="st">&quot;&quot;</span>::[] -&gt; <span class="kw">true</span>  <span class="co">(* // *)</span>
        | <span class="st">&quot;&quot;</span>::_ -&gt; <span class="kw">false</span> <span class="co">(* three slashes *)</span>
        | _ -&gt; <span class="kw">true</span> <span class="co">(* //tom *)</span> end)
      | _ -&gt; <span class="kw">false</span>
       end) end)


  <span class="co">(* process path is only called, on path that do NOT start with with</span>
<span class="co">     two slashes, the behaviour in this case is impl defined, the the</span>
<span class="co">     implementation of pre_os_trans guarentees that process_path is</span>
<span class="co">     only called on such paths *)</span>
  <span class="kw">val</span> process_path : forall &#39;dir_ref &#39;file_ref &#39;impl.
    environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
    &#39;impl -&gt; 
    &#39;dir_ref -&gt; ty_os_command -&gt; cstring -&gt;
    res_name &#39;dir_ref &#39;file_ref
  <span class="kw">let</span> process_path env s0 cwd cmd path = (
    <span class="kw">match</span> path <span class="kw">with</span> 
      | <span class="dt">CS_Null</span> -&gt; (<span class="dt">RN_error</span>(<span class="dt">ENOENT</span>,&lt;|re_cwd=cwd;re_nl=<span class="dt">Nothing</span>;re_rn=<span class="dt">Nothing</span>|&gt;))
      | <span class="dt">CS_Some</span> path -&gt; (
  <span class="kw">let</span> nl = split_path_string path <span class="kw">in</span>
  <span class="kw">if</span> (path = <span class="st">&quot;&quot;</span>) <span class="kw">then</span> 
          <span class="dt">RN_error</span>(<span class="dt">ENOENT</span>,&lt;|re_cwd=cwd;re_nl=<span class="dt">Just</span> nl;re_rn=<span class="dt">Nothing</span>|&gt;)
      <span class="co">(* posix/rename.md ENOENT:3; posix/link.md ENOENT:3; posix/rmdir.md ENOENT:3 *)</span>
      <span class="kw">else</span> (
        <span class="kw">let</span> init_cwd = <span class="kw">if</span> nl_starts_with_slash nl <span class="kw">then</span> fromJust (env.env_ops.fops_get_root s0) <span class="kw">else</span> cwd <span class="kw">in</span>
        <span class="kw">let</span> res = resolve_relative env s0 cmd <span class="dv">0</span> init_cwd (ty_name_list_to_list nl) <span class="kw">in</span>
        ty_resolve_relative_result2res_name env.env_ops s0 cwd nl res
      ))
     end)

<span class="co">(* FIXME this complexity should be incorporated into process path? *)</span>
<span class="co">(* this is a complete hack because Mac OS X behaviour is very</span>
<span class="co">   strange wrt trailing slashes and symlinks; we try to resolve a path,</span>
<span class="co">   after first removing any trailing slashes; we then check if we have a symlink *)</span>
  <span class="kw">val</span> process_path_no_follow_no_trailing_slash : forall &#39;dir_ref &#39;file_ref &#39;impl.
    environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
    &#39;impl -&gt; 
    &#39;dir_ref -&gt; cstring -&gt;
    res_name &#39;dir_ref &#39;file_ref
  <span class="kw">let</span> process_path_no_follow_no_trailing_slash env s0 cwd path = (
    <span class="kw">let</span> cmd = <span class="dt">OS_READLINK</span> path <span class="kw">in</span>
    <span class="kw">let</span> path = (<span class="kw">match</span> path <span class="kw">with</span>
      | <span class="dt">CS_Null</span> -&gt; <span class="dt">CS_Null</span>
      | <span class="dt">CS_Some</span> path -&gt; (
          <span class="co">(* strip trailing slashes *)</span>
          <span class="kw">let</span> p = String<span class="kw">.</span>toCharList path <span class="kw">in</span>
          <span class="kw">let</span> p = reverse p <span class="kw">in</span>
          <span class="kw">let</span> p = dropWhile (<span class="kw">fun</span> c -&gt; c=#<span class="ch">&#39;/&#39;</span>) p <span class="kw">in</span>
          <span class="kw">let</span> p = reverse p <span class="kw">in</span>
          <span class="dt">CS_Some</span>(String<span class="kw">.</span>toString p)) end)
    <span class="kw">in</span>
    process_path env s0 cwd cmd path)

  <span class="kw">val</span> process_path_from_root : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     &#39;impl -&gt; 
     ty_os_command -&gt; cstring -&gt; res_name &#39;dir_ref &#39;file_ref
  <span class="kw">let</span> process_path_from_root env s0 cmd path = (
    <span class="kw">let</span> root = fromJust (env.env_ops.fops_get_root s0) <span class="kw">in</span>
    process_path env s0 root cmd path)


  <span class="kw">val</span> res_name_is_symlink : forall &#39;dir_ref &#39;file_ref &#39;impl.
     fs_ops &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> res_name_is_symlink ops s0 rn = <span class="kw">match</span> rn <span class="kw">with</span>
    | <span class="dt">RN_file</span>(_,_,i0_ref,_) -&gt; ((ops.fops_stat_file s0 i0_ref).st_kind = <span class="dt">S_IFLNK</span>)
    | _ -&gt; <span class="kw">false</span> 
  end


end


<span class="co">(******************************************************************************)</span>
<span class="co">(* The Monad                                                                  *)</span>
<span class="co">(******************************************************************************)</span>

<span class="ot">module</span> The_monad = <span class="kw">struct</span>

  <span class="ot">open</span> Fs_types

  <span class="co">(*---------------------------------*)</span>
  <span class="co">(* Monad type with bind and return *)</span>
  <span class="co">(*---------------------------------*)</span>

  <span class="co">(* Our monad is used to implement filesystem operations. It is able</span>
<span class="co">     to encode non-deterministic choice between a finite set of</span>
<span class="co">     states. Normal states are abstract fs-states, there are also</span>
<span class="co">     error and special states, though.  (see type-definition of</span>
<span class="co">     monad_state). *)</span>

  <span class="kw">type</span> fsmonad &#39;impl &#39;ja  = <span class="dt">Fsmonad</span> <span class="kw">of</span> (&#39;impl -&gt; finset (monad_state &#39;impl &#39;ja ))

  <span class="kw">val</span> dest_fsmonad : forall &#39;impl &#39;a. fsmonad &#39;impl &#39;a -&gt; 
     (&#39;impl -&gt; finset (monad_state &#39;impl &#39;a))
  <span class="kw">let</span> dest_fsmonad (<span class="dt">Fsmonad</span> u) = u <span class="co">(* coverage:unused *)</span>

  <span class="kw">val</span> fsm_return : forall &#39;impl &#39;a. &#39;a -&gt; fsmonad &#39;impl &#39;a 
  <span class="kw">let</span> fsm_return x = <span class="dt">Fsmonad</span> (<span class="kw">fun</span> s -&gt; finset_singleton (<span class="dt">Normal_state</span> (s, x)))

  <span class="kw">val</span> run_fsmonad : forall &#39;impl &#39;a. fsmonad &#39;impl &#39;a -&gt; 
     &#39;impl -&gt; finset (monad_state &#39;impl &#39;a)
  <span class="kw">let</span> run_fsmonad (<span class="dt">Fsmonad</span> f) s = (f s)

  <span class="kw">val</span> fsm_bind_process_single_state : forall &#39;impl &#39;a &#39;b. 
     (&#39;a -&gt; fsmonad &#39;impl &#39;b) -&gt; 
     monad_state &#39;impl &#39;a -&gt; 
     finset (monad_state &#39;impl &#39;b)
  <span class="kw">let</span> fsm_bind_process_single_state f v = (<span class="kw">match</span> v <span class="kw">with</span>     
    | <span class="dt">Error_state</span> se -&gt; (finset_singleton (<span class="dt">Error_state</span> se)) <span class="co">(* stop once error is reached *)</span>
    | <span class="dt">Special_state</span> sm -&gt; (finset_singleton (<span class="dt">Special_state</span> sm)) <span class="co">(* stop once special state is reached *)</span>
    | <span class="dt">Normal_state</span> sx -&gt; (run_fsmonad (f (snd sx)) (fst sx))
  <span class="kw">end</span>) 

  <span class="kw">val</span> fsm_bind : forall &#39;impl &#39;a &#39;b. 
     fsmonad &#39;impl &#39;a -&gt;
     (&#39;a -&gt; fsmonad &#39;impl &#39;b) -&gt; 
     fsmonad &#39;impl &#39;b
  <span class="kw">let</span> fsm_bind u f = <span class="dt">Fsmonad</span> (<span class="kw">fun</span> s0 -&gt;
    <span class="kw">let</span> result_states = run_fsmonad u s0 <span class="kw">in</span>
    (finset_bigunion_image (fsm_bind_process_single_state f) result_states))

  <span class="kw">val</span> (&gt;&gt;=) : forall &#39;impl &#39;a &#39;b. fsmonad &#39;impl &#39;a -&gt; (&#39;a -&gt; fsmonad &#39;impl &#39;b) -&gt; fsmonad &#39;impl &#39;b
  <span class="kw">let</span> (&gt;&gt;=) = fsm_bind


  <span class="co">(*---------------------------------*)</span>
  <span class="co">(* Basic monad operations          *)</span>
  <span class="co">(*---------------------------------*)</span>

  <span class="co">(* we have 3 main constructor:</span>
<span class="co">      - fsm_normal:  construct successful executions</span>
<span class="co">      - fsm_raise:   raise an error</span>
<span class="co">      - fsm_special: mark a special state </span>
<span class="co">  *)</span>
  <span class="kw">val</span> fsm_normal : forall &#39;impl &#39;a. (&#39;impl -&gt; (&#39;impl * &#39;a)) -&gt; fsmonad &#39;impl &#39;a
  <span class="kw">let</span> fsm_normal f = <span class="dt">Fsmonad</span> (<span class="kw">fun</span> s -&gt; finset_singleton (<span class="dt">Normal_state</span> (f s)))

  <span class="kw">val</span> fsm_raise : forall &#39;impl &#39;a. error -&gt; fsmonad &#39;impl &#39;a
  <span class="kw">let</span> fsm_raise e = <span class="dt">Fsmonad</span> (<span class="kw">fun</span> s -&gt; finset_singleton(<span class="dt">Error_state</span> (s, e)))

  <span class="kw">val</span> fsm_special : forall &#39;impl &#39;a. monad_special_state -&gt; <span class="dt">string</span> -&gt; fsmonad &#39;impl &#39;a
  <span class="kw">let</span> fsm_special spec_s m = <span class="dt">Fsmonad</span> (<span class="kw">fun</span> s -&gt; finset_singleton(<span class="dt">Special_state</span>(spec_s,m)))


  <span class="co">(*---------------------------------*)</span>
  <span class="co">(* Useful operations               *)</span>
  <span class="co">(* derived from basic ones         *)</span>
  <span class="co">(*---------------------------------*)</span>

  <span class="kw">val</span> fsm_get_state : forall &#39;impl. fsmonad &#39;impl &#39;impl
  <span class="kw">let</span> ~{ocaml} fsm_get_state = fsm_normal (<span class="kw">fun</span> s -&gt; (s, s))
  <span class="kw">let</span> {ocaml} fsm_get_state = <span class="dt">Fsmonad</span> (<span class="kw">fun</span> s -&gt; finset_singleton (<span class="dt">Normal_state</span> (s, s))) 
     <span class="co">(* OCaml needs unfolding the definition of fsm_normal to generalize the state type *)</span>

  <span class="kw">val</span> fsm_put_state : forall &#39;impl. &#39;impl -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsm_put_state s = fsm_normal (<span class="kw">fun</span> _ -&gt; (s, <span class="dt">RV_none</span>))

  <span class="kw">val</span> fsm_put_state_return : forall &#39;impl &#39;a. &#39;impl -&gt; &#39;a -&gt; fsmonad &#39;impl &#39;a
  <span class="kw">let</span> fsm_put_state_return s x = fsm_normal (<span class="kw">fun</span> _ -&gt; (s, x))

  lemma fsm_put_state_alt_def : forall s. fsm_put_state s = fsm_put_state_return s <span class="dt">RV_none</span>

  <span class="kw">val</span> fsm_do_nothing : forall &#39;impl. fsmonad &#39;impl ret_value
  <span class="kw">let</span> ~{ocaml} fsm_do_nothing = fsm_normal (<span class="kw">fun</span> s -&gt; (s, dummy_return_value))
  <span class="kw">let</span> {ocaml} fsm_do_nothing = <span class="dt">Fsmonad</span> (<span class="kw">fun</span> s -&gt; finset_singleton (<span class="dt">Normal_state</span> (s, dummy_return_value)))
     <span class="co">(* OCaml needs unfolding the definition of fsm_normal to generalise the state type *)</span>

  lemma fsm_return_alt_def : forall x. fsm_return x = fsm_normal (<span class="kw">fun</span> s -&gt; (s, x))


  <span class="co">(*--------------------------------------*)</span>
  <span class="co">(* multiple sucessful return states     *)</span>
  <span class="co">(*--------------------------------------*)</span>

  <span class="kw">val</span> fsm_normals : forall &#39;impl &#39;a &#39;b. ((&#39;impl * &#39;b) -&gt; (&#39;impl * &#39;a)) -&gt; <span class="dt">list</span> &#39;b -&gt; fsmonad &#39;impl &#39;a
  <span class="kw">let</span> fsm_normals f l = <span class="dt">Fsmonad</span> (<span class="kw">fun</span> s -&gt; finset_from_list (map (<span class="kw">fun</span> x -&gt; <span class="dt">Normal_state</span> (f (s, x))) l))

  <span class="kw">val</span> fsm_returns : forall &#39;impl &#39;a. <span class="dt">list</span> &#39;a -&gt; fsmonad &#39;impl &#39;a 
  <span class="kw">let</span> fsm_returns xs = fsm_normals id xs

  <span class="co">(* [fsm_choose_nat n] chooses nondeterministically a number between [0] (including) and</span>
<span class="co">     [n] (including) *)</span>
  <span class="kw">val</span> fsm_choose_nat : forall &#39;impl. nat -&gt; fsmonad &#39;impl nat
  <span class="kw">let</span> fsm_choose_nat n = fsm_returns (List<span class="kw">.</span>genlist id (succ n))

  <span class="co">(*--------------------------------------*)</span>
  <span class="co">(* raising multiple errors and specials *)</span>
  <span class="co">(*--------------------------------------*)</span>

  <span class="co">(* Instead of raising errors and special states individually, it is convenient to use</span>
<span class="co">     lists and non-deterministically raise one in the list. *)</span>
  <span class="kw">type</span> error_or_special =
    | <span class="dt">EOS_error</span> <span class="kw">of</span> error
    | <span class="dt">EOS_special</span> <span class="kw">of</span> (monad_special_state * <span class="dt">string</span>)

  <span class="kw">val</span> error_or_special_to_state : forall &#39;impl &#39;a. &#39;impl -&gt; error_or_special -&gt; monad_state &#39;impl &#39;a
  <span class="kw">let</span> error_or_special_to_state s eos =
     <span class="kw">match</span> eos <span class="kw">with</span> 
       | <span class="dt">EOS_error</span> e -&gt; <span class="dt">Error_state</span> (s, e)
       | <span class="dt">EOS_special</span> ssm -&gt; <span class="dt">Special_state</span> ssm <span class="co">(* coverage:linux:irrelevant *)</span>
     end

  <span class="kw">val</span> fsm_raises_specials : forall &#39;impl &#39;a. 
      <span class="dt">list</span> error_or_special -&gt; 
      fsmonad &#39;impl &#39;a
  <span class="kw">let</span> fsm_raises_specials eoss = 
      <span class="dt">Fsmonad</span> (<span class="kw">fun</span> s -&gt; finset_from_list (List<span class="kw">.</span>map (error_or_special_to_state s) eoss))

  <span class="kw">val</span> fsm_raises : forall &#39;impl &#39;a. <span class="dt">list</span> error -&gt; fsmonad &#39;impl &#39;a
  <span class="kw">let</span> fsm_raises es = fsm_raises_specials (map <span class="dt">EOS_error</span> es)

  <span class="kw">val</span> fsm_specials : forall &#39;impl &#39;a. <span class="dt">list</span> (monad_special_state * <span class="dt">string</span>) -&gt; fsmonad &#39;impl &#39;a
  <span class="kw">let</span> fsm_specials sms = <span class="co">(* coverage:unused *)</span>
    fsm_raises_specials (map <span class="dt">EOS_special</span> sms) <span class="co">(* coverage:unused *)</span>

  <span class="kw">val</span> fsm_cond_raises_specials : forall &#39;impl. 
      <span class="dt">list</span> (error_or_special * <span class="dt">bool</span>) -&gt; 
      fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsm_cond_raises_specials ceoss = 
    <span class="kw">let</span> eoss = (List<span class="kw">.</span>map fst (List<span class="kw">.</span>filter snd ceoss)) <span class="kw">in</span>
    <span class="kw">if</span> List<span class="kw">.</span>null eoss <span class="kw">then</span> 
      fsm_do_nothing
    <span class="kw">else</span>
      fsm_raises_specials eoss

  <span class="kw">val</span> fsm_cond_raises : forall &#39;impl. <span class="dt">list</span> (error * <span class="dt">bool</span>) -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsm_cond_raises bes = fsm_cond_raises_specials (List<span class="kw">.</span>map (<span class="kw">fun</span> (e, b) -&gt; (<span class="dt">EOS_error</span> e, b)) bes)

  <span class="kw">val</span> fsm_cond_raise : forall &#39;impl. error -&gt; <span class="dt">bool</span> -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsm_cond_raise e b = fsm_cond_raises [(e, b)]

  <span class="kw">val</span> fsm_cond_specials : forall &#39;impl. <span class="dt">list</span> ((monad_special_state * <span class="dt">string</span>) * <span class="dt">bool</span>) -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsm_cond_specials bsms = fsm_cond_raises_specials (List<span class="kw">.</span>map (<span class="kw">fun</span> (sm, b) -&gt; (<span class="dt">EOS_special</span> sm, b)) bsms)

  <span class="kw">val</span> fsm_cond_special : forall &#39;impl. monad_special_state -&gt; <span class="dt">string</span> -&gt; <span class="dt">bool</span> -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsm_cond_special ss m b = fsm_cond_specials [((ss, m), b)]


  <span class="co">(*---------------------------------*)</span>
  <span class="co">(* non-deterministic choice        *)</span>
  <span class="co">(*---------------------------------*)</span>

  <span class="kw">val</span> fsm_empty : forall &#39;impl &#39;a. fsmonad &#39;impl &#39;a
  <span class="kw">let</span> fsm_empty = <span class="dt">Fsmonad</span> (<span class="kw">fun</span> s -&gt; finset_empty ()) <span class="co">(* coverage:unused *)</span>

  <span class="kw">val</span> fsm_choice : forall &#39;impl &#39;a. fsmonad &#39;impl &#39;a -&gt; fsmonad &#39;impl &#39;a -&gt; fsmonad &#39;impl &#39;a
  <span class="kw">let</span> fsm_choice m1 m2 = <span class="dt">Fsmonad</span> (<span class="kw">fun</span> s -&gt; finset_union (run_fsmonad m1 s) (run_fsmonad m2 s)) <span class="co">(* coverage:unused *)</span>


  <span class="co">(*---------------------------------*)</span>
  <span class="co">(* parallel composition            *)</span>
  <span class="co">(*---------------------------------*)</span>

  <span class="co">(* When checking for errors, it is often handy to be able to</span>
<span class="co">     consider errors independently. The following parallel composition</span>
<span class="co">     operator first runs two monads in both orders and returns all</span>
<span class="co">     possible results. This is a crude model for parallel</span>
<span class="co">     composition. *)</span>

  <span class="kw">val</span> fsm_parallel_composition : forall &#39;impl &#39;a &#39;b. 
    fsmonad &#39;impl &#39;a -&gt;
    fsmonad &#39;impl &#39;b -&gt; 
    fsmonad &#39;impl (&#39;a * &#39;b)
  <span class="kw">let</span> fsm_parallel_composition m1 m2 = <span class="co">(* coverage:unused *)</span>
    fsm_choice
      (<span class="co">(* either un m1 and then m2 *)</span>
       (m1 &gt;&gt;= (<span class="kw">fun</span> x1 -&gt; (m2 &gt;&gt;= (<span class="kw">fun</span> x2 -&gt; fsm_return (x1, x2)))))) <span class="co">(* coverage:unused *)</span>
      (<span class="co">(* or m2 and then m1 *)</span>
       (m2 &gt;&gt;= (<span class="kw">fun</span> x2 -&gt; (m1 &gt;&gt;= (<span class="kw">fun</span> x1 -&gt; fsm_return (x1, x2)))))) <span class="co">(* coverage:unused *)</span>


  <span class="co">(* [fsm_parallel_composition] is simple to define, but rather</span>
<span class="co">     crude. One problem is for example that the operation is not</span>
<span class="co">     associative in general, a property that one normally would</span>
<span class="co">     expect. We intend to use parallel composition mainly for</span>
<span class="co">     error-checking.  In this case we can enforce that the operations</span>
<span class="co">     do not modify the state and we can discard the return values. The</span>
<span class="co">     resulting operation [fsm_parallel_composition_drop] has nice properties</span>
<span class="co">     like being associative.</span>

<span class="co">     The described high-level, abstract definition of</span>
<span class="co">     [fsm_parallel_composition_drop] is inefficient to execute. So, we</span>
<span class="co">     first define an efficiently executable version and then state as</span>
<span class="co">     a lemma that this efficient implementation is equivalent to the</span>
<span class="co">     abstract definition described above. The implementation is</span>
<span class="co">     interesting on it&#39;s own. It shows that the parallel composition</span>
<span class="co">     operator collects the errors from both monads and combines</span>
<span class="co">     them. It adds a normal state, iff both monads might right a</span>
<span class="co">     normal state. *)</span>

  <span class="kw">val</span> fsm_parallel_composition_drop : forall &#39;impl. 
     fsmonad &#39;impl ret_value -&gt;
     fsmonad &#39;impl ret_value -&gt; 
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsm_parallel_composition_drop m1 m2 = <span class="dt">Fsmonad</span> (<span class="kw">fun</span> s -&gt; 
    <span class="kw">let</span> (st_s1_n, st_s1) = finset_partition is_Normal_state (run_fsmonad m1 s) <span class="kw">in</span>
    <span class="kw">let</span> (st_s2_n, st_s2) = finset_partition is_Normal_state (run_fsmonad m2 s) <span class="kw">in</span>

    <span class="kw">let</span> res = finset_union st_s1 st_s2 <span class="kw">in</span>
    <span class="kw">let</span> res&#39; = finset_cleanup monad_state_shallow_eq res <span class="kw">in</span> <span class="co">(* remove obvious duplicates *)</span>
    <span class="kw">if</span> (finset_is_empty st_s1_n || finset_is_empty st_s2_n) <span class="kw">then</span>
      res&#39;
    <span class="kw">else</span>
      finset_insert (<span class="dt">Normal_state</span> (s, dummy_return_value))  res&#39;
  )

  <span class="co">(* enforce that a monad does not change the state *)</span>
  <span class="kw">val</span> fsm_preserve_state : forall &#39;a &#39;b. fsmonad &#39;a &#39;b -&gt; fsmonad &#39;a &#39;b
  <span class="kw">let</span> fsm_preserve_state m = <span class="co">(* coverage:unused *)</span>
    fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; m &gt;&gt;= (<span class="kw">fun</span> r -&gt; fsm_normal (<span class="kw">fun</span> _ -&gt; (s0, r))))

  lemma fsm_parallel_composition_drop_alt_def : (forall m1 m2. fsm_parallel_composition_drop m1 m2 = 
     (fsm_parallel_composition 
       (fsm_preserve_state (m1 : fsmonad &#39;impl ret_value)) 
       (fsm_preserve_state (m2 : fsmonad &#39;impl ret_value)) &gt;&gt;= 
     (<span class="kw">fun</span> (_, _) -&gt; fsm_return dummy_return_value)))


  <span class="co">(* define infix notations for parallel composition operators *)</span>  

  <span class="kw">val</span> (&lt;|||&gt;) : forall &#39;impl &#39;a &#39;b. fsmonad &#39;impl &#39;a -&gt; fsmonad &#39;impl &#39;b -&gt; fsmonad &#39;impl (&#39;a * &#39;b)
  <span class="kw">let</span> (&lt;|||&gt;) = fsm_parallel_composition

  <span class="kw">val</span> (|||) : forall &#39;impl. fsmonad &#39;impl ret_value -&gt; fsmonad &#39;impl ret_value -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> (|||) = fsm_parallel_composition_drop



end


<span class="co">(******************************************************************************)</span>
<span class="co">(* Fs_operations                                                              *)</span>
<span class="co">(*                                                                            *)</span>
<span class="co">(* This is one of the central parts of the specifications. It contains        *)</span>
<span class="co">(* models of the operations at file-system level.                             *)</span>
<span class="co">(******************************************************************************)</span>

<span class="ot">module</span> Fs_operations = <span class="kw">struct</span>

  <span class="ot">open</span> T_fs_prelude
  <span class="ot">open</span> Fs_types
  <span class="ot">open</span> Fs_arch
  <span class="ot">open</span> The_monad
<span class="ot">#ifdef aspect_perms</span>
  <span class="ot">open</span> Fs_permissions
<span class="ot">#endif</span>

  <span class="co">(*--------------------------*)</span>
  <span class="co">(* auxiliary functions      *)</span>
  <span class="co">(*--------------------------*)</span>

  <span class="co">(* [dir_is_empty env.env_ops s0 d0_ref] checks that a directory [d0_ref] is empty in state [s0]. *)</span>
  <span class="kw">val</span> dir_is_empty : forall &#39;dir_ref &#39;file_ref &#39;impl.
     fs_ops &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     &#39;impl -&gt; &#39;dir_ref -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> dir_is_empty ops s0 d0_ref = (<span class="kw">match</span> (ops.fops_readdir s0 d0_ref) <span class="kw">with</span>
    | (_, []) -&gt; <span class="kw">true</span> | _ -&gt; <span class="kw">false</span> <span class="kw">end</span>)

  <span class="co">(* get the size of a file quickly *)</span>
  <span class="kw">val</span> file_get_size : forall &#39;dir_ref &#39;file_ref &#39;impl.
     fs_ops &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     &#39;impl -&gt; &#39;file_ref -&gt; nat
  <span class="kw">let</span> file_get_size ops s0 i0_ref = (
    <span class="kw">let</span> (_, ret) = ops.fops_read s0 i0_ref <span class="kw">in</span> 
    <span class="kw">let</span> bs = dest_RV_bytes ret <span class="kw">in</span>
    <span class="kw">let</span> len_bs = T_list_array<span class="kw">.</span>dim bs <span class="kw">in</span>
    len_bs
  )

  <span class="co">(* [parent_dir_of_res_name] tries to return the parent directory of</span>
<span class="co">     the resolved name.  For [RN_error] and the root directory,</span>
<span class="co">     [Nothing] is returned. *)</span>
  <span class="kw">val</span> parent_dir_of_res_name : forall &#39;dir_ref &#39;file_ref &#39;impl. 
    fs_ops &#39;dir_ref &#39;file_ref &#39;impl -&gt;
    &#39;impl -&gt;
    res_name &#39;dir_ref &#39;file_ref -&gt; 
    maybe &#39;dir_ref
  <span class="kw">let</span> parent_dir_of_res_name ops s0 rn = (<span class="kw">match</span> rn <span class="kw">with</span> 
    | <span class="dt">RN_file</span> (d0_ref, _, _, _) -&gt; <span class="dt">Just</span> d0_ref
    | <span class="dt">RN_none</span> (d0_ref, _, _) -&gt; <span class="dt">Just</span> d0_ref
    | <span class="dt">RN_error</span> _ -&gt; <span class="dt">Nothing</span>
    | <span class="dt">RN_dir</span> (d0_ref, rpd) -&gt; (
      <span class="kw">match</span> (ops.fops_get_parent s0 d0_ref) <span class="kw">with</span>
      | <span class="dt">Nothing</span> -&gt; <span class="dt">Nothing</span> <span class="co">(* src is the root dir, catched by subdir check *)</span>
           | <span class="dt">Just</span> (d1_ref, _) -&gt; <span class="dt">Just</span> d1_ref
      end)
  end)

<span class="ot">#ifdef aspect_perms</span>
  <span class="kw">val</span> res_name_has_restricted_delete_privilege : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     <span class="dt">bool</span>
  <span class="kw">let</span> res_name_has_restricted_delete_privilege env s0 rn = <span class="kw">begin</span>
    <span class="kw">let</span> arch = architecture_of_ty_arch env.env_arch <span class="kw">in</span>
    <span class="kw">let</span> arch_allows_removing_writable = arch.arch_allows_removing_from_protected_dir_if_writeable <span class="kw">in</span>
    <span class="kw">match</span> rn <span class="kw">with</span>
      | <span class="dt">RN_file</span> (d0_ref, _, i0_ref, _) -&gt; 
         (env.env_prms.cp_has_file_restricted_delete_privilege arch_allows_removing_writable s0 d0_ref i0_ref)
      | <span class="dt">RN_dir</span> (d0_ref, _) -&gt; (
          <span class="kw">match</span> (env.env_ops.fops_get_parent s0 d0_ref) <span class="kw">with</span>
            | <span class="dt">Nothing</span> -&gt; <span class="kw">true</span> <span class="co">(* src is the root dir, we can&#39;t do anything, better return true to be conservative *)</span>
            | <span class="dt">Just</span> (d1_ref, _) -&gt; 
                (env.env_prms.cp_has_dir_restricted_delete_privilege arch_allows_removing_writable s0 d1_ref d0_ref)
         <span class="kw">end</span>)
       | _ -&gt; <span class="kw">true</span> <span class="co">(* we can&#39;t check, because there is no source file *)</span>
    end
  end
<span class="ot">#endif</span>


  <span class="co">(* mac os x non-POSIX behaviour on symlinks to files with a trailing slash *)</span>
  <span class="kw">let</span> mac_os_x_map_rpath env s0 rpath = (
    <span class="kw">match</span> is_mac_os_x_arch env <span class="kw">with</span>
    | <span class="kw">false</span> -&gt; rpath
    | <span class="kw">true</span> -&gt; ( 
        <span class="kw">match</span> rpath <span class="kw">with</span>
        | <span class="dt">RN_error</span>(<span class="dt">ENOTDIR</span>,&lt;|re_cwd=cwd;re_nl=<span class="dt">Just</span> nl;re_rn=<span class="dt">Just</span> fopt|&gt;) -&gt; (
            <span class="kw">let</span> path = <span class="dt">CS_Some</span>(Resolve<span class="kw">.</span>ty_name_list_to_string nl) <span class="kw">in</span>
            <span class="kw">let</span> b = Resolve<span class="kw">.</span>res_name_is_symlink env.env_ops s0 (Resolve<span class="kw">.</span>process_path_no_follow_no_trailing_slash env s0 cwd path) <span class="kw">in</span> 
            <span class="kw">if</span> b <span class="kw">then</span> fopt <span class="kw">else</span> rpath)
        | _ -&gt; rpath end) end)

  <span class="co">(*--------------------------*)</span>
  <span class="co">(* link                     *)</span>
  <span class="co">(*--------------------------*)</span>

<span class="ot">#ifdef aspect_perms</span>
  <span class="kw">val</span> fsop_link_checks_perms : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt; 
     res_name &#39;dir_ref &#39;file_ref -&gt; 
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_link_checks_perms env spath dpath = (
    fsm_get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="kw">match</span> dpath <span class="kw">with</span> 
    | <span class="dt">RN_none</span> (d0_ref,n,rp) -&gt; (fsm_cond_raise <span class="dt">EACCES</span> (not (env.env_prms.cp_has_dir_write_permission s0 d0_ref))) <span class="co">(* posix/link.md EACCES:2 *)</span>
    | _ -&gt; fsm_do_nothing end)
<span class="ot">#endif</span>

  <span class="kw">val</span> fsop_link_checks : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt; 
     res_name &#39;dir_ref &#39;file_ref -&gt; 
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_link_checks env spath dpath = (
    fsm_get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="co">(* sanity check spath in parallel with dpath *)</span>
    ( <span class="kw">match</span> dpath <span class="kw">with</span>
        | <span class="dt">RN_error</span>(e,&lt;|re_rn=fopt|&gt;) -&gt; (
          fsm_cond_raises [
            (e,<span class="kw">true</span>);
            (<span class="dt">EEXIST</span>, is_linux_arch env &amp;&amp; isJust fopt &amp;&amp; (e = <span class="dt">ENOTDIR</span>)); <span class="co">(* tr/23 probable non-POSIX Linux behaviour (path should not resolve) *)</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
            (<span class="dt">EEXIST</span>, is_mac_os_x_arch env &amp;&amp; isJust fopt &amp;&amp; (e = <span class="dt">ENOTDIR</span>)) <span class="co">(* tr/27 apparent non-POSIX behaviour - symlink is followed but a different error results *)</span> <span class="co">(* coverage:linux:posix:irrelevant *)</span>
            ]) 
        | <span class="dt">RN_file</span> _ -&gt; (fsm_raise <span class="dt">EEXIST</span>)  <span class="co">(* posix/link.md EEXIST:1 *)</span>
        | <span class="dt">RN_dir</span> _ -&gt; (fsm_raise <span class="dt">EEXIST</span>)  <span class="co">(* posix/link.md EEXIST:1 *)</span>
        | <span class="dt">RN_none</span> (d0_ref,n,rp) -&gt; (
            <span class="kw">let</span> cwd = rp.rp_cwd <span class="kw">in</span>
            <span class="kw">let</span> nl = rp.rp_nl <span class="kw">in</span>
            <span class="kw">let</span> path = <span class="dt">CS_Some</span>(Resolve<span class="kw">.</span>ty_name_list_to_string nl) <span class="kw">in</span>
            <span class="kw">let</span> b0 = Resolve<span class="kw">.</span>res_name_is_symlink env.env_ops s0 (Resolve<span class="kw">.</span>process_path_no_follow_no_trailing_slash env s0 cwd path) <span class="kw">in</span> 
          (<span class="kw">if</span> (is_linux_arch env || (is_mac_os_x_arch env &amp;&amp; not b0)) &amp;&amp; rn_ends_with_slash dpath <span class="kw">then</span> 
              fsm_raise <span class="dt">ENOENT</span> <span class="co">(* tr/24, mac hfsplus_loop/link/results/check_exec_link___link_nonempty_dir2__f2.txt___nonexist_2__-int.trace *)</span> 
           <span class="kw">else</span>
              fsm_do_nothing)
          ||| (<span class="co">(* a symlink to a non-existing entry on mac is treated as though the path resolved to the symlink itself hfsplus_loop/link/results/check_exec_link___link_empty_dir1_____nonempty_dir1__d2__sl_dotdot_no_such_target-int.trace *)</span>
                   <span class="kw">if</span> is_mac_os_x_arch env &amp;&amp; b0 &amp;&amp; not (rn_ends_with_slash dpath) <span class="kw">then</span> fsm_raise <span class="dt">EEXIST</span> <span class="kw">else</span> fsm_do_nothing))
      end  
    ) ||| (
      <span class="kw">match</span> spath <span class="kw">with</span>
        | <span class="dt">RN_error</span>(e,_) -&gt; (fsm_raise e)
        | <span class="dt">RN_none</span> _ -&gt; (fsm_raise <span class="dt">ENOENT</span>)  <span class="co">(* posix/link.md ENOENT:2 *)</span>
        | <span class="dt">RN_file</span> _ -&gt; (
          <span class="kw">let</span> cond = is_linux_arch env &amp;&amp; Resolve<span class="kw">.</span>res_name_is_symlink env.env_ops s0 spath &amp;&amp; rn_ends_with_slash spath <span class="kw">in</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
          fsm_cond_raises
            [(<span class="dt">ENOTDIR</span>, (is_RN_none dpath &amp;&amp; rn_ends_with_slash dpath &amp;&amp; (not (is_mac_os_x_arch env)))); <span class="co">(* posix/link.md ENOTDIR:4 hfsplus_loop/link/results/check_exec_link___link_nonempty_dir1__d2__f3.txt___nonempty_dir1__d2__sl_dotdot_no_such_target__-int.trace *)</span>
             (<span class="dt">ENOTDIR</span>, cond); <span class="co">(* FIXME tr/?? *)</span>
             (<span class="dt">EPERM</span>, cond);   <span class="co">(* FIXME tr/?? *)</span>
             (<span class="dt">ENOENT</span>, cond)]) <span class="co">(* FIXME tr/?? *)</span>
        | <span class="dt">RN_dir</span>(d0_ref, _) -&gt; (
            <span class="co">(* FIXME we should check link /a/exist_dir /b/f1.txt/ *)</span>
<span class="ot">#ifdef aspect_perms</span>
            <span class="kw">if</span> (env.env_prms.cp_has_dir_link_create_privilege s0 d0_ref &amp;&amp; 
               arch_allows_dir_links env) <span class="kw">then</span>
<span class="ot">#else</span>
            <span class="kw">if</span> (arch_allows_dir_links env) <span class="kw">then</span>
<span class="ot">#endif</span>
              fsm_special <span class="dt">FIXME</span> <span class="st">&quot;link: directory links unsupported in this spec&quot;</span> <span class="co">(* coverage:impossible *)</span>
            <span class="kw">else</span> 
              fsm_raise <span class="dt">EPERM</span>)  <span class="co">(* posix/link.md EPERM:2 *)</span>
      end)
<span class="ot">#ifdef aspect_perms</span>
    ||| fsop_link_checks_perms env spath dpath
<span class="ot">#endif</span>
  )

  <span class="kw">val</span> fsop_link_core : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt; 
     res_name &#39;dir_ref &#39;file_ref -&gt; 
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_link_core env spath dpath = (
    fsm_get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    (<span class="kw">match</span> (spath, dpath) <span class="kw">with</span> 
      | (<span class="dt">RN_file</span>(_,_,i0_ref,_), <span class="dt">RN_none</span>(d0_ref, n, _)) -&gt; (
            <span class="kw">let</span> s0 = env.env_ops.fops_link_file s0 i0_ref d0_ref n <span class="kw">in</span>
            fsm_put_state s0)
      | _ -&gt; fsm_special <span class="dt">Impossible</span> <span class="st">&quot;error raised before&quot;</span> <span class="co">(* coverage:impossible *)</span>
     end))

  <span class="co">(* posix/1 *)</span>
  <span class="kw">val</span> fsop_link : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt; 
     res_name &#39;dir_ref &#39;file_ref -&gt; 
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_link env spath dpath = (fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; 
    <span class="kw">let</span> spath = (<span class="kw">if</span> (is_mac_os_x_arch env) <span class="kw">then</span> (mac_os_x_map_rpath env s0 spath) <span class="kw">else</span> spath) <span class="kw">in</span>
    fsop_link_checks env spath dpath &gt;&gt;= (<span class="kw">fun</span> _ -&gt; fsop_link_core env spath dpath)))



  <span class="co">(*--------------------------*)</span>
  <span class="co">(* mkdir                    *)</span>
  <span class="co">(*--------------------------*)</span>

<span class="ot">#ifdef aspect_perms</span>
  <span class="kw">let</span> fsop_mkdir_checks_perms env rpath mode = fsm_get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    (fsm_cond_special <span class="dt">Implementation_defined</span> <span class="st">&quot;mkdir: additional file permission bits&quot;</span>
       (contains_implementation_specific_file_perms mode)      
    ) ||| 
    (<span class="kw">match</span> rpath <span class="kw">with</span> 
       | <span class="dt">RN_none</span>(d0_ref,n,_) -&gt; (
           fsm_cond_raise <span class="dt">EACCES</span> (not (env.env_prms.cp_has_dir_write_permission s0 d0_ref))) <span class="co">(* posix/mkdir.md EACCES:2 *)</span>
       | _ -&gt; fsm_do_nothing 
     end)
<span class="ot">#endif</span>

  <span class="kw">let</span> fsop_mkdir_checks env rpath mode = 
    (<span class="kw">match</span> rpath <span class="kw">with</span> 
      | <span class="dt">RN_none</span>(d0_ref,n,_) -&gt; fsm_do_nothing          
      | <span class="dt">RN_error</span>(e,&lt;|re_rn=fopt|&gt;) -&gt; 
          fsm_cond_raises [
            (e, <span class="kw">true</span>); 
            (<span class="dt">ENOENT</span>, e = <span class="dt">ENOTDIR</span>);  <span class="co">(* posix/mkdir.md ENOENT:4; probable POSIX spec error; confirmed on austin group mailing list 2014-06-16 by Geoff Clare *)</span>
            (<span class="dt">EEXIST</span>, is_linux_arch env &amp;&amp; isJust fopt &amp;&amp; (e = <span class="dt">ENOTDIR</span>)); <span class="co">(* tr/22 FIXME check other places where we have ENOTDIR because last component is /f1.txt/  - we need to add isJust check *)</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
            (<span class="dt">EEXIST</span>, is_mac_os_x_arch env &amp;&amp; isJust fopt &amp;&amp; (e = <span class="dt">ENOTDIR</span>)) <span class="co">(* tr/26 apparent non-posix behaviour - symlink is followed but a different error results *)</span> <span class="co">(* coverage:linux:posix:irrelevant *)</span>
          ]
      | <span class="dt">RN_dir</span> _ -&gt; (fsm_raise <span class="dt">EEXIST</span>)  <span class="co">(* posix/mkdir.md EEXIST:1 *)</span>
      | <span class="dt">RN_file</span> _ -&gt; (fsm_raise <span class="dt">EEXIST</span>)  <span class="co">(* posix/mkdir.md EEXIST:1 *)</span>
     end
    ) 
<span class="ot">#ifdef aspect_perms</span>
     |||
    <span class="co">(* additionally check for permissions *)</span>
    (fsop_mkdir_checks_perms env rpath mode)
<span class="ot">#endif</span>

<span class="ot">#ifdef aspect_perms</span>
  <span class="co">(* mkdir_core_perms is the permission concerned part of mkdir. It sets</span>
<span class="co">     the correct permissions and owner for the new directory. *)</span>
  <span class="kw">let</span> fsop_mkdir_core_perms env mode s1 d0_ref d1_ref =
    <span class="co">(* set the permissions of new dir *)</span>
    <span class="kw">let</span> mode&#39; = unset_file_perms mode (env.env_prms.cp_get_umask s1) <span class="kw">in</span>
    <span class="kw">let</span> s2 = env.env_perm_ops.pops_set_perm_dir s1 mode&#39; d1_ref <span class="kw">in</span>

    <span class="co">(* set owner of the new file *)</span>
    <span class="kw">let</span> arch = architecture_of_ty_arch env.env_arch <span class="kw">in</span>
    <span class="kw">let</span> new_uid = env.env_prms.cp_get_euid () <span class="kw">in</span>
    <span class="kw">let</span> new_gid = <span class="kw">if</span> arch.arch_group_from_parent_dir <span class="kw">then</span>
        <span class="co">(* inherit group from parent directory d0_ref *)</span>
        (env.env_ops.fops_stat_dir s2 d0_ref).st_gid <span class="co">(* coverage:impossible -no architecture has this field set to true *)</span>
      <span class="kw">else</span> 
        <span class="co">(* use effective group id of process *)</span>
        env.env_prms.cp_get_egid () 
    <span class="kw">in</span>
    <span class="kw">let</span> s3 = env.env_perm_ops.pops_chown_dir s2 (new_uid, new_gid) d1_ref <span class="kw">in</span> 
    s3
<span class="ot">#endif</span>

  <span class="kw">let</span> fsop_mkdir_core env rpath mode =
    fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt;
    (<span class="kw">match</span> rpath <span class="kw">with</span> 
      | <span class="dt">RN_none</span>(d0_ref,n,_) -&gt; (
         <span class="co">(* create the new directory and get a reference to it back *)</span>
         <span class="kw">let</span> (s1, d1_ref) = env.env_ops.fops_mkdir s0 d0_ref n <span class="kw">in</span>
<span class="ot">#ifdef aspect_perms</span>
         <span class="kw">let</span> s1 = fsop_mkdir_core_perms env mode s1 d0_ref d1_ref <span class="kw">in</span> <span class="co">(* update permissions and owner of new directory *)</span>
<span class="ot">#endif</span>
         fsm_put_state s1)
      | _ -&gt; fsm_special <span class="dt">Impossible</span> <span class="st">&quot;error raised before&quot;</span> <span class="co">(* coverage:impossible *)</span>
     end))


  <span class="kw">val</span> fsop_mkdir : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt; 
     file_perm -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_mkdir env rpath mode = 
    (fsop_mkdir_checks env rpath mode &gt;&gt;= (<span class="kw">fun</span> _ -&gt; fsop_mkdir_core env rpath mode))



  <span class="co">(*--------------------------*)</span>
  <span class="co">(* open                     *)</span>
  <span class="co">(*--------------------------*)</span>

<span class="ot">#ifdef aspect_perms</span>
  <span class="kw">val</span> fsop_open_checks_perms : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; 
     finset open_flag -&gt; maybe file_perm -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_open_checks_perms env rpath oflags mode = (fsm_get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    <span class="co">(* check for posix/open.md EACCES:2 *)</span>
    ( <span class="kw">match</span> rpath <span class="kw">with</span>
       | <span class="dt">RN_file</span> (_,_,i0_ref,_) -&gt; (fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; (                
           <span class="kw">let</span> o_exec_ok   = (finset_mem <span class="dt">O_EXEC</span>   oflags --&gt;  env.env_prms.cp_has_file_execute_permission s0 i0_ref) <span class="kw">in</span> <span class="co">(* coverage:linux:irrelevant *)</span>
           <span class="kw">let</span> o_rdonly_ok = (finset_mem <span class="dt">O_RDONLY</span> oflags --&gt;  env.env_prms.cp_has_file_read_permission s0 i0_ref) <span class="kw">in</span>
           <span class="kw">let</span> o_rdwr_ok   = (finset_mem <span class="dt">O_RDWR</span>   oflags --&gt; (env.env_prms.cp_has_file_read_permission s0 i0_ref &amp;&amp; 
                                                              env.env_prms.cp_has_file_write_permission s0 i0_ref)) <span class="kw">in</span>
           <span class="kw">let</span> o_wronly_ok = (finset_mem <span class="dt">O_WRONLY</span> oflags --&gt;  env.env_prms.cp_has_file_write_permission s0 i0_ref) <span class="kw">in</span>
           <span class="kw">let</span> o_trunc_ok  = (finset_mem <span class="dt">O_TRUNC</span>  oflags --&gt;  env.env_prms.cp_has_file_write_permission s0 i0_ref) <span class="kw">in</span> <span class="co">(* posix/open.md EACCES:4 *)</span>
           fsm_cond_raise <span class="dt">EACCES</span> (not (o_exec_ok &amp;&amp; o_rdonly_ok &amp;&amp; o_rdwr_ok &amp;&amp; o_wronly_ok &amp;&amp; o_trunc_ok))
         )))
       | <span class="dt">RN_dir</span> (d0_ref,_) -&gt; (fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; (                
           <span class="kw">let</span> o_search_ok = (finset_mem <span class="dt">O_SEARCH</span> oflags --&gt;  env.env_prms.cp_has_dir_search_permission s0 d0_ref) <span class="kw">in</span>  <span class="co">(* coverage:linux:irrelevant *)</span>
           <span class="kw">let</span> o_rdonly_ok = (finset_mem <span class="dt">O_RDONLY</span> oflags --&gt;  env.env_prms.cp_has_dir_read_permission s0 d0_ref) <span class="kw">in</span>

           <span class="co">(* write permissions on dirs don&#39;t make sense and whether permission is granted or not,</span>
<span class="co">              EISDIR:1 is raised anyhow. *)</span>
           <span class="kw">let</span> o_rdwr_ok   = (finset_mem <span class="dt">O_RDWR</span>   oflags --&gt; (env.env_prms.cp_has_dir_read_permission s0 d0_ref &amp;&amp; 
                                                              env.env_prms.cp_has_dir_write_permission s0 d0_ref)) <span class="kw">in</span>
           <span class="kw">let</span> o_wronly_ok = (finset_mem <span class="dt">O_WRONLY</span> oflags --&gt;  env.env_prms.cp_has_dir_write_permission s0 d0_ref) <span class="kw">in</span>
           fsm_cond_raise <span class="dt">EACCES</span> (not (o_search_ok &amp;&amp; o_rdonly_ok &amp;&amp; o_rdwr_ok &amp;&amp; o_wronly_ok))
         )))
       | _ -&gt; fsm_do_nothing <span class="co">(* only check for existing files *)</span>
      end
    )
  |||
    (<span class="kw">match</span> rpath <span class="kw">with</span> 
      | <span class="dt">RN_none</span>(d0_ref,n,ns) -&gt; <span class="kw">if</span> (finset_mem <span class="dt">O_CREAT</span> oflags) <span class="kw">then</span>
          <span class="co">(* check that mode is OK *)</span>
          ( (fsm_cond_special 
               <span class="dt">Undefined</span> <span class="st">&quot;open: extra permissions bit for newly created file&quot;</span>
               (isJust mode &amp;&amp; (contains_implementation_specific_file_perms (fromJust mode))))
              |||
            (fsm_cond_raise <span class="dt">EACCES</span> (not (env.env_prms.cp_has_dir_write_permission s0 d0_ref))) <span class="co">(* posix/open.md EACCES:3 *)</span>
          )
         <span class="kw">else</span> fsm_do_nothing
       | _ -&gt; fsm_do_nothing
     end))
<span class="ot">#endif</span>

  <span class="kw">val</span> fsop_open_checks_flags : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; 
     finset open_flag -&gt; maybe file_perm -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_open_checks_flags env rpath oflags mode_opt = (
    (
      (<span class="kw">if</span> (is_linux_arch env || is_mac_os_x_arch env)  <span class="kw">then</span> fsm_do_nothing <span class="kw">else</span>  <span class="co">(* tr/15 *)</span> <span class="co">(* hfsplus_loop/open/results/check_exec_open___open_nonexist_dir__nonexist2___O_EXCL__O_WRONLY___none___close_3-int.trace *)</span> 
      (fsm_cond_special <span class="dt">Undefined</span> <span class="st">&quot;open: O_EXCL, no O_CREAT, posix/open.md D:1&quot;</span> <span class="co">(* coverage:linux:irrelevant *)</span>
        ((finset_mem <span class="dt">O_EXCL</span> oflags) &amp;&amp; <span class="co">(* coverage:linux:irrelevant *)</span>
           not ( <span class="co">(* coverage:linux:irrelevant *)</span> finset_mem <span class="dt">O_CREAT</span> oflags)))) <span class="co">(* coverage:linux:irrelevant *)</span>
    |||
      (<span class="kw">if</span> is_linux_arch env <span class="kw">then</span> fsm_do_nothing <span class="kw">else</span>  <span class="co">(* tr/16 note this leads to the file being truncated even though the file was opened O_RDONLY FIXME very strange behaviour *)</span>  <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
       <span class="kw">if</span> is_mac_os_x_arch env <span class="kw">then</span> fsm_do_nothing <span class="kw">else</span> <span class="co">(* exec_open___open_broken_sl_____O_APPEND__O_CLOEXEC__O_CREAT__O_DIRECTORY__O_EXCL__O_EXEC__O_NOFOLLOW__O_TRUNC___0666___close_3-int.trace *)</span>
      (fsm_cond_special  <span class="co">(* coverage:linux:irrelevant *)</span>
         <span class="dt">Undefined</span> <span class="st">&quot;open: O_TRUNC, no O_RDWR or O_WRONLY, posix/open.md O_TRUNC:4&quot;</span> <span class="co">(* coverage:linux:irrelevant *)</span>
         (( <span class="co">(* coverage:linux:irrelevant *)</span>finset_mem <span class="dt">O_TRUNC</span> oflags) &amp;&amp; <span class="co">(* coverage:linux:irrelevant *)</span>
           not ( <span class="co">(* coverage:linux:irrelevant *)</span> finset_mem <span class="dt">O_RDWR</span> oflags || <span class="co">(* coverage:linux:irrelevant *)</span>
           <span class="co">(* coverage:linux:irrelevant *)</span> finset_mem <span class="dt">O_WRONLY</span> oflags)))) <span class="co">(* coverage:linux:irrelevant *)</span>
    |||
      <span class="co">(* check that exactly one file access mode is provided *)</span>
      (<span class="kw">if</span> is_linux_arch env <span class="kw">then</span> fsm_do_nothing <span class="kw">else</span>  <span class="co">(* tr/17 FIXME confirm that this is treated as O_RDWR not O_RDONLY *)</span>  <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
      (fsm_cond_special <span class="dt">Undefined</span> <span class="st">&quot;open: not exactly one file access mode&quot;</span>  <span class="co">(* coverage:linux:irrelevant *)</span>
        (not (open_flag_set_access_mode_ok oflags))))
    ||| 
      (<span class="kw">if</span> is_mac_os_x_arch env &amp;&amp; finset_mem <span class="dt">O_CREAT</span> oflags &amp;&amp; finset_mem <span class="dt">O_DIRECTORY</span> oflags <span class="kw">then</span>  
         fsm_raise <span class="dt">EINVAL</span>  <span class="co">(* FIXME this may be too loose; does Mac always return EINVAL in this situation? *)</span>
       <span class="kw">else</span>
         fsm_do_nothing)
    )
  )

  <span class="kw">val</span> fsop_open_checks_rpath : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; 
     finset open_flag -&gt; maybe file_perm -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_open_checks_rpath env rpath oflags mode_opt = (fsm_get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
     <span class="co">(* RN_error *)</span>
          (<span class="kw">match</span> rpath <span class="kw">with</span> 
            | <span class="dt">RN_error</span> (e,_) -&gt; (fsm_raise e)
            | _ -&gt; fsm_do_nothing
           end)
        |||

     <span class="co">(* RN_none *)</span>
          (<span class="kw">match</span> rpath <span class="kw">with</span> 
            | <span class="dt">RN_none</span> _ -&gt; (fsm_cond_raise <span class="dt">ENOENT</span> (not (finset_mem <span class="dt">O_CREAT</span> oflags))) <span class="co">(* posix/open.md ENOENT:1 *)</span>
            | _ -&gt; fsm_do_nothing
           end)
        |||

     <span class="co">(* RN_dir *)</span>
          (fsm_cond_raise <span class="dt">EISDIR</span> ((finset_mem <span class="dt">O_RDWR</span> oflags || finset_mem <span class="dt">O_WRONLY</span> oflags) &amp;&amp; is_RN_dir rpath))
             <span class="co">(* posix/open.md EISDIR:1 *)</span>
        |||
          (<span class="kw">let</span> cond = ((finset_mem <span class="dt">O_TRUNC</span> oflags) &amp;&amp; (is_RN_dir rpath)) <span class="kw">in</span>
          <span class="kw">if</span> cond &amp;&amp; (is_linux_arch env || is_mac_os_x_arch env) <span class="kw">then</span> fsm_raise <span class="dt">EISDIR</span> <span class="kw">else</span> <span class="co">(* tr/19 hfsplus_loop/open/results/check_exec_open___open_nonempty_dir___O_TRUNC__O_WRONLY___none___close_3-int.trace *)</span>
          (fsm_cond_special
             <span class="dt">Implementation_defined</span> <span class="st">&quot;open: O_TRUNC, directory, posix/open.md O_TRUNC:3&quot;</span>)
             cond)
        |||
          (<span class="kw">if</span> is_linux_arch env <span class="kw">then</span> fsm_do_nothing <span class="kw">else</span> <span class="co">(* NB Linux has no O_EXEC flag so this case cannot arise *)</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
          (fsm_cond_special  <span class="co">(* coverage:linux:irrelevant *)</span>
             <span class="dt">Unspecified</span> <span class="st">&quot;open: O_EXEC on directory&quot;</span> <span class="co">(* posix/open.md O_EXEC:1 *)</span> <span class="co">(* coverage:linux:irrelevant *)</span>
             ( <span class="co">(* coverage:linux:irrelevant *)</span> finset_mem <span class="dt">O_EXEC</span> oflags <span class="co">(* coverage:linux:irrelevant *)</span>
              &amp;&amp; (is_RN_dir rpath)))) <span class="co">(* coverage:linux:irrelevant *)</span>
        |||

     <span class="co">(* RN_file *)</span>
          (<span class="kw">let</span> cond = (finset_mem <span class="dt">O_DIRECTORY</span> oflags &amp;&amp; is_RN_file rpath) <span class="kw">in</span>
          (fsm_cond_raise <span class="dt">ENOTDIR</span> cond)) <span class="co">(* posix/open.md ENOTDIR:1 *)</span> 
        |||
          (<span class="kw">if</span> is_linux_arch env <span class="kw">then</span> fsm_do_nothing <span class="kw">else</span>  <span class="co">(* FIXME glibc on Linux has no O_SEARCH flag, so this case cannot arise *)</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
          (fsm_cond_special <span class="co">(* coverage:linux:irrelevant *)</span>
             <span class="dt">Unspecified</span> <span class="st">&quot;open: O_SEARCH on non-directory&quot;</span> <span class="co">(* posix/open.md O_SEARCH:1 *)</span> <span class="co">(* coverage:linux:irrelevant *)</span>
             ( <span class="co">(* coverage:linux:irrelevant *)</span> finset_mem <span class="dt">O_SEARCH</span> oflags <span class="co">(* coverage:linux:irrelevant *)</span>
              &amp;&amp; (is_RN_file rpath)))) <span class="co">(* coverage:linux:irrelevant *)</span>
        |||
           fsm_cond_raise <span class="dt">ELOOP</span> (finset_mem <span class="dt">O_NOFOLLOW</span> oflags &amp;&amp; Resolve<span class="kw">.</span>res_name_is_symlink env.env_ops s0 rpath) <span class="co">(* posix/open.md ELOOP:1 FIXME but for open, path resolution always follows symlinks, so this condition never arises? FIXME look at tests for this; mac non-posix behaviour hfsplus_loop/open/results/check_exec_open___open_f3_sl.txt___O_NOFOLLOW__O_WRONLY___none___close_3-int.trace *)</span>
        |||

     <span class="co">(* O_CREAT *)</span>
          (fsm_cond_raise <span class="dt">EEXIST</span> (finset_mem <span class="dt">O_EXCL</span> oflags &amp;&amp; finset_mem <span class="dt">O_CREAT</span> oflags
            &amp;&amp; (is_RN_dir rpath || is_RN_file rpath))) <span class="co">(* posix/open.md EEXIST:1 *)</span>
        |||
          (fsm_cond_raise <span class="dt">ENOTDIR</span> (finset_mem <span class="dt">O_CREAT</span> oflags &amp;&amp; rn_ends_with_slash rpath &amp;&amp; not(is_mac_os_x_arch env) )) <span class="co">(* posix/open.md ENOTDIR:2 open cannot be used to create a directory (implicit in posix spec), but this arises even if the directory exists; mac non-posix behaviour hfsplus_loop/open/results/check_exec_open___open_nonempty_dir_____O_CREAT__O_SEARCH___0666___close_3-int.trace *)</span>
        |||
          (fsm_cond_raise <span class="dt">EISDIR</span> (is_linux_arch env &amp;&amp; finset_mem <span class="dt">O_CREAT</span> oflags &amp;&amp; (is_RN_dir rpath || rn_ends_with_slash rpath))) <span class="co">(* tr/21 FIXME possible non-posix Linux behaviour *)</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
        |||
          (fsm_cond_raise <span class="dt">ENOENT</span> (
            finset_mem <span class="dt">O_CREAT</span> oflags &amp;&amp; rn_ends_with_slash rpath &amp;&amp;
            (is_RN_none rpath || is_RN_error rpath) &amp;&amp;
            not (
              is_mac_os_x_arch env &amp;&amp; 
              (<span class="kw">match</span> rpath <span class="kw">with</span> 
               | <span class="dt">RN_none</span>(d0_ref,n,rp) -&gt; (
                   <span class="kw">let</span> cwd = rp.rp_cwd <span class="kw">in</span>
                   <span class="kw">let</span> nl = rp.rp_nl <span class="kw">in</span>
                   <span class="kw">let</span> path = <span class="dt">CS_Some</span>(Resolve<span class="kw">.</span>ty_name_list_to_string nl) <span class="kw">in</span>
                   <span class="kw">let</span> b = Resolve<span class="kw">.</span>res_name_is_symlink env.env_ops s0 (Resolve<span class="kw">.</span>process_path_no_follow_no_trailing_slash env s0 cwd path) <span class="kw">in</span> 
                   b)
               | _ -&gt; <span class="kw">false</span> end)) <span class="co">(* hfsplus_loop/open/results/check_exec_open___open_broken_sl_____O_CREAT__O_WRONLY___0666___close_3-int.trace *)</span>
          )) <span class="co">(* posix/open.md ENOENT:3 *)</span>
        |||
          (<span class="kw">if</span> is_linux_arch env <span class="kw">then</span> fsm_do_nothing <span class="kw">else</span> <span class="co">(* FIXME 2118 see adhoc_open_tests/adhoc_open_test.posix_result in this case, Linux creates a file ---x------ ; is this always the case? could Linux create a file with different permissions e.g. depending on group membership etc? *)</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
          (fsm_cond_special <span class="dt">FIXME</span> <span class="st">&quot;open with create-flag but without mode argument&quot;</span> <span class="co">(* coverage:linux:irrelevant *)</span>
            ( <span class="co">(* coverage:linux:irrelevant *)</span> finset_mem <span class="dt">O_CREAT</span> oflags &amp;&amp; <span class="co">(* coverage:linux:irrelevant *)</span>
               is_RN_none rpath &amp;&amp; <span class="co">(* coverage:linux:irrelevant *)</span>
                 isNothing mode_opt))) <span class="co">(* coverage:linux:irrelevant *)</span>
  )

  <span class="kw">val</span> fsop_open_checks : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; 
     int_open_flags -&gt; maybe file_perm -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_open_checks env rpath oflag mode_opt = 
    <span class="kw">let</span> arch = architecture_of_ty_arch env.env_arch <span class="kw">in</span>
    <span class="kw">let</span> oflags = arch.arch_open_flags_of_int oflag <span class="kw">in</span> (
      fsop_open_checks_rpath env rpath oflags mode_opt
        |||
      fsop_open_checks_flags env rpath oflags mode_opt
<span class="ot">#ifdef aspect_perms</span>
       |||
      fsop_open_checks_perms env rpath oflags mode_opt
<span class="ot">#endif</span>
    )


<span class="ot">#ifdef aspect_perms</span>
  <span class="kw">val</span> fsop_open_core_create_perms : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; 
     file_perm -&gt; &#39;dir_ref -&gt; &#39;file_ref -&gt; &#39;impl -&gt; &#39;impl
  <span class="kw">let</span> fsop_open_core_create_perms env rpath mode d0_ref i0_ref s1 =
    <span class="co">(* set the permissions of new file *)</span>
    <span class="kw">let</span> mode&#39; = unset_file_perms mode (env.env_prms.cp_get_umask s1) <span class="kw">in</span>
    <span class="kw">let</span> s2 = env.env_perm_ops.pops_set_perm_file s1 mode&#39; i0_ref <span class="kw">in</span>

    <span class="co">(* set owner of the new file *)</span>
    <span class="kw">let</span> arch = architecture_of_ty_arch env.env_arch <span class="kw">in</span>
    <span class="kw">let</span> new_uid = env.env_prms.cp_get_euid () <span class="kw">in</span>
    <span class="kw">let</span> new_gid = <span class="kw">if</span> arch.arch_group_from_parent_dir <span class="kw">then</span>
                     <span class="co">(* inherit group from parent directory d0_ref *)</span>
                     (env.env_ops.fops_stat_dir s2 d0_ref).st_gid <span class="co">(* coverage:impossible -group inheritance unsupported by the existing architectures*)</span>
                  <span class="kw">else</span> 
                     <span class="co">(* use effective group id of process *)</span>
                     env.env_prms.cp_get_egid ()                 
    <span class="kw">in</span>
    <span class="kw">let</span> s3 = env.env_perm_ops.pops_chown_file s2 (new_uid, new_gid) i0_ref <span class="kw">in</span> 
    s3
<span class="ot">#endif</span>

  <span class="kw">val</span> fsop_open_core_create_if_not_exists : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; 
     maybe file_perm -&gt; fsmonad &#39;impl (entry &#39;dir_ref &#39;file_ref)
  <span class="kw">let</span> fsop_open_core_create_if_not_exists env rpath mode_opt =
    (<span class="kw">match</span> rpath <span class="kw">with</span>
      | <span class="dt">RN_error</span> _ -&gt; fsm_special <span class="dt">Impossible</span> <span class="st">&quot;error raised before&quot;</span> <span class="co">(* coverage:impossible *)</span>
      | <span class="dt">RN_dir</span>(d0_ref,rp)-&gt; fsm_return (<span class="dt">Dir_ref_entry</span> d0_ref) <span class="co">(* we can open a dir *)</span>
      | <span class="dt">RN_file</span>(d0_ref,n,i0_ref,rp) -&gt; fsm_return (<span class="dt">File_ref_entry</span> i0_ref)
      | <span class="dt">RN_none</span>(d0_ref,n,ns) -&gt; (
        <span class="kw">let</span> mode_opt = (<span class="kw">match</span> mode_opt <span class="kw">with</span> 
          | <span class="dt">Nothing</span> -&gt; (<span class="kw">if</span> is_linux_arch env <span class="co">(* coverage:mac_os_x:posix:irrelevant - this if is never checked for non-linux architectures for there is a check for the O_CREAT flag earlier *)</span>
                        <span class="kw">then</span> (<span class="dt">Just</span> (<span class="dt">File_perm</span> <span class="bn">0O101</span>)) <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
                        <span class="kw">else</span> <span class="dt">Nothing</span>) <span class="co">(* FIXME Linux called with no mode, but with O_CREAT, creates the file see fs_test/adhoc_open_test.posix_result; see also FIXME 2118 *)</span> <span class="co">(* coverage:impossible -the absence of permissions for non-linux is checked before in fsop_open_checks for O_CREAT *)</span>
          | <span class="dt">Just</span> _ -&gt; mode_opt end)
        <span class="kw">in</span>
        <span class="kw">match</span> mode_opt <span class="kw">with</span>
          | <span class="dt">Nothing</span> -&gt; (fsm_special <span class="dt">Impossible</span> <span class="st">&quot;error raised before&quot;</span>) <span class="co">(* coverage:impossible *)</span>
          | <span class="dt">Just</span> mode -&gt; (fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt;
              <span class="co">(* We are sure we want to create a new regular file,</span>
<span class="co">                 since if we tried to open a directory, we would have run into an error above. *)</span>
              <span class="kw">let</span> (s1,i0_ref) = env.env_ops.fops_mkfile s0 d0_ref n <span class="kw">in</span>
<span class="ot">#ifdef aspect_perms</span>
              <span class="kw">let</span> s1 = fsop_open_core_create_perms env rpath mode d0_ref i0_ref s1 <span class="kw">in</span>
<span class="ot">#endif</span>
              fsm_put_state_return s1 (<span class="dt">File_ref_entry</span> i0_ref)))
        end)
     end)

  <span class="kw">val</span> fsop_open_core_truncate : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; 
     int_open_flags -&gt; entry &#39;dir_ref &#39;file_ref -&gt; 
     fsmonad &#39;impl (entry &#39;dir_ref &#39;file_ref * finset open_flag)
  <span class="kw">let</span> fsop_open_core_truncate env rpath oflag entry = (
    fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; (
      <span class="kw">let</span> arch = architecture_of_ty_arch env.env_arch <span class="kw">in</span>
      <span class="kw">let</span> oflags = arch.arch_open_flags_of_int oflag <span class="kw">in</span> 

      <span class="co">(* truncate if necessary; at this point, rpath can only be a file. *)</span>
      <span class="kw">if</span> finset_mem <span class="dt">O_TRUNC</span> oflags <span class="kw">then</span> (<span class="kw">match</span> entry <span class="kw">with</span>
        | <span class="dt">Dir_ref_entry</span> _ -&gt; (fsm_special <span class="dt">Impossible</span> <span class="st">&quot;error raised before&quot;</span>) <span class="co">(* coverage:impossible *)</span>
        | <span class="dt">File_ref_entry</span> i0_ref -&gt; (
            <span class="kw">let</span> zero_bytes = T_list_array<span class="kw">.</span>of_string <span class="st">&quot;&quot;</span> <span class="kw">in</span> <span class="co">(* FIXME define elsewhere? *)</span>
            <span class="kw">let</span> s0 = env.env_ops.fops_write s0 i0_ref zero_bytes <span class="kw">in</span>
            fsm_put_state_return s0 (entry,oflags))
        end) <span class="kw">else</span>
         fsm_return (entry, oflags)
    )))

  <span class="kw">val</span> fsop_open_core : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; 
     int_open_flags -&gt; maybe file_perm -&gt; fsmonad &#39;impl (entry &#39;dir_ref &#39;file_ref * finset open_flag)
  <span class="kw">let</span> fsop_open_core env rpath oflag mode_opt = (
    fsop_open_core_create_if_not_exists env rpath mode_opt &gt;&gt;= (<span class="kw">fun</span> entry -&gt;
    fsop_open_core_truncate env rpath oflag entry &gt;&gt;= (<span class="kw">fun</span> (entry, oflags) -&gt;
      fsm_return (entry, oflags))))


  <span class="kw">val</span> fsop_open : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt; 
     int_open_flags -&gt;
     maybe file_perm -&gt;
     fsmonad &#39;impl (entry &#39;dir_ref &#39;file_ref * finset open_flag)
  <span class="kw">let</span> fsop_open env rpath oflag mode = (fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; 
    <span class="kw">let</span> rpath = <span class="kw">if</span> (is_mac_os_x_arch env) <span class="kw">then</span> (mac_os_x_map_rpath env s0 rpath) <span class="kw">else</span> rpath <span class="kw">in</span>
    fsop_open_checks env rpath oflag mode &gt;&gt;= (<span class="kw">fun</span> _ -&gt;
    fsop_open_core env rpath oflag mode)))


  <span class="co">(*--------------------------*)</span>
  <span class="co">(* open_close               *)</span>
  <span class="co">(*--------------------------*)</span>

  <span class="kw">val</span> fsop_open_close_checks : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt; 
     int_open_flags -&gt;
     maybe file_perm -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_open_close_checks env rpath oflag mode = fsop_open_checks env rpath oflag mode

  <span class="kw">val</span> fsop_open_close_core : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt; 
     int_open_flags -&gt;
     maybe file_perm -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_open_close_core env rpath oflag mode = 
    (fsop_open_core env rpath oflag mode &gt;&gt;= (<span class="kw">fun</span> _x_ -&gt; fsm_return <span class="dt">RV_none</span>))

  <span class="kw">val</span> fsop_open_close : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt; 
     int_open_flags -&gt;
     maybe file_perm -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_open_close env rpath oflag mode = (
    fsop_open_close_checks env rpath oflag mode &gt;&gt;= (<span class="kw">fun</span> _ -&gt;
    fsop_open_close_core env rpath oflag mode
  ))


  <span class="co">(*--------------------------*)</span>
  <span class="co">(* pread                    *)</span>
  <span class="co">(*--------------------------*)</span>

  <span class="co">(* reading is split into two functions</span>

<span class="co">  fsop_pread works with an entry - this is what is available when using read at the OS level with a file descriptor</span>

<span class="co">  fsop_pread_rn is really just a dummy function to allow fsop_pread to be called; we need to provide some way to read from a resolved name (e.g. for linking with fuse, or if we are discarding the os level stuff)</span>

<span class="co">  any permissions checks should work on pre_fs_read, not read</span>

<span class="co">  *)</span>

  <span class="kw">val</span> fsop_pread_checks : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     entry &#39;dir_ref &#39;file_ref -&gt; 
     nat -&gt; off_t -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_pread_checks env entry len ofs = (
    fsm_cond_raise <span class="dt">EINVAL</span> (ofs &lt; <span class="dv">0</span>) <span class="co">(* posix/read.md EINVAL:2 *)</span>
      |||   
    (<span class="co">(* check we read a regular file *)</span>
      <span class="kw">match</span> entry <span class="kw">with</span> 
       | <span class="dt">Dir_ref_entry</span> _ -&gt; (
           <span class="co">(* FIXME we should check link /a/exist_dir /b/f1.txt/ *)</span>
           <span class="kw">let</span> arch = architecture_of_ty_arch env.env_arch <span class="kw">in</span>
           <span class="kw">if</span> arch.arch_allows_dir_read <span class="kw">then</span>
             fsm_special <span class="dt">FIXME</span> <span class="st">&quot;read: directory reads unsupported in this spec&quot;</span> <span class="co">(* coverage:impossible *)</span>
           <span class="kw">else</span> 
             fsm_raise <span class="dt">EISDIR</span>)  <span class="co">(* posix/read.md EISDIR:1 *)</span>
       | <span class="dt">File_ref_entry</span> i0_ref -&gt; fsm_do_nothing
      end
   ))


  <span class="kw">val</span> fsop_pread_core : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     entry &#39;dir_ref &#39;file_ref -&gt; 
     nat -&gt; off_t -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_pread_core env entry len ofs = (fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; (<span class="kw">match</span> entry <span class="kw">with</span>
  | <span class="dt">Dir_ref_entry</span> _ -&gt; fsm_special <span class="dt">Impossible</span> <span class="st">&quot;error raised before&quot;</span> <span class="co">(* coverage:impossible *)</span>
  | <span class="dt">File_ref_entry</span> i0_ref -&gt; (
      <span class="kw">let</span> ofs = (natFromInt ofs) <span class="kw">in</span>
      <span class="kw">let</span> (s1, res) = env.env_ops.fops_read s0 i0_ref <span class="kw">in</span> 
      (fsm_put_state s1) &gt;&gt;= (<span class="kw">fun</span> _x_ -&gt; 
      <span class="kw">let</span> bs = dest_RV_bytes res <span class="kw">in</span>
      <span class="kw">let</span> len_bs = T_list_array<span class="kw">.</span>dim bs <span class="kw">in</span>
      <span class="kw">let</span> len_max = <span class="kw">if</span> ofs+len &lt;= len_bs <span class="kw">then</span> len <span class="kw">else</span> len_bs - ofs <span class="kw">in</span> 

      <span class="co">(* non-deterministically choose the amount of data to read,</span>
<span class="co">         if an interrupt occurs during reading or when reading from a FIFO</span>
<span class="co">         that is has not enough data yet, read might not read up to the given length. *)</span>
      (fsm_choose_nat len_max) &gt;&gt;= (<span class="kw">fun</span> len_to_read -&gt;
        <span class="kw">let</span> bs&#39; = T_list_array<span class="kw">.</span>sub bs ofs len_to_read <span class="kw">in</span>
        fsm_return (<span class="dt">RV_bytes</span>(bs&#39;)))
      ))
  end)))

  <span class="co">(* Notice that pre_fs_read does not perform any checks for permissions.</span>
<span class="co">     This is done by the calling functions, fs_read and os_read. *)</span>
  <span class="kw">val</span> fsop_pread : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     entry &#39;dir_ref &#39;file_ref -&gt; 
     nat -&gt; off_t -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_pread env entry len ofs = (
    fsop_pread_checks env entry len ofs &gt;&gt;= (<span class="kw">fun</span> _ -&gt;  
    fsop_pread_core env entry len ofs))



  <span class="co">(*--------------------------*)</span>
  <span class="co">(* pread with resolved name *)</span>
  <span class="co">(*--------------------------*)</span>

  <span class="co">(* note that these definitions are just placeholders - pre_fs_read is the real spec *)</span>

<span class="ot">#ifdef aspect_perms</span>
  <span class="kw">val</span> fsop_pread_rn_checks_perms : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt; 
     nat -&gt; off_t -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_pread_rn_checks_perms env rn len ofs = (fsm_get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt; <span class="co">(* coverage:unused *)</span>
    (<span class="kw">match</span> rn <span class="kw">with</span> 
      | <span class="dt">RN_dir</span> (d0_ref, _) -&gt; 
          fsm_cond_raise <span class="dt">EACCES</span> (not (env.env_prms.cp_has_dir_read_permission s0 d0_ref)) <span class="co">(* guessing here *)</span> <span class="co">(* coverage:unused *)</span>
      | <span class="dt">RN_file</span>(_,_,i0_ref,_) -&gt; 
          fsm_cond_raise <span class="dt">EACCES</span> (not (env.env_prms.cp_has_file_read_permission s0 i0_ref)) <span class="co">(* guessing here *)</span> <span class="co">(* coverage:unused *)</span>
      | _ -&gt; fsm_do_nothing <span class="co">(* coverage:unused *)</span>
     end))
<span class="ot">#endif</span>

  <span class="kw">val</span> fsop_pread_rn_checks : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     res_name &#39;dir_ref &#39;file_ref -&gt; 
     nat -&gt; off_t -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_pread_rn_checks env rn len ofs = (
      (fsm_cond_raise <span class="dt">EINVAL</span> (ofs &lt; <span class="dv">0</span>)) <span class="co">(* coverage:unused *)</span>
    |||
      (<span class="kw">match</span> rn <span class="kw">with</span> 
        | <span class="dt">RN_dir</span> (d0_ref, _) -&gt; fsop_pread_checks env ((<span class="dt">Dir_ref_entry</span> d0_ref):entry &#39;dir_ref &#39;file_ref) len ofs <span class="co">(* coverage:unused *)</span>
        | <span class="dt">RN_file</span>(_,_,i0_ref,_) -&gt; 
            fsop_pread_checks env ((<span class="dt">File_ref_entry</span> i0_ref):entry &#39;dir_ref &#39;file_ref) len ofs <span class="co">(* coverage:unused *)</span>
        | <span class="dt">RN_none</span> _ -&gt; (fsm_raise <span class="dt">ENOENT</span>) <span class="co">(* coverage:unused *)</span>
        | <span class="dt">RN_error</span> (e,_) -&gt; (fsm_raise e) <span class="co">(* coverage:unused *)</span>
      end)
<span class="ot">#ifdef aspect_perms</span>
    ||| fsop_pread_rn_checks_perms env rn len ofs
<span class="ot">#endif</span>
  )

  <span class="kw">val</span> fsop_pread_rn_core : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     res_name &#39;dir_ref &#39;file_ref -&gt; 
     nat -&gt; off_t -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_pread_rn_core env rn ofs len =
    (<span class="kw">match</span> rn <span class="kw">with</span> 
      | <span class="dt">RN_dir</span> (d0_ref, _) -&gt; 
          fsop_pread_core env ((<span class="dt">Dir_ref_entry</span> d0_ref):entry &#39;dir_ref &#39;file_ref) ofs len <span class="co">(* coverage:unused *)</span>
      | <span class="dt">RN_file</span>(_,_,i0_ref,_) -&gt; 
          fsop_pread_core env ((<span class="dt">File_ref_entry</span> i0_ref):entry &#39;dir_ref &#39;file_ref) ofs len <span class="co">(* coverage:unused *)</span>
      | _ -&gt; fsm_special <span class="dt">Impossible</span> <span class="st">&quot;error raised before&quot;</span> <span class="co">(* coverage:unused *)</span>
     end)

  <span class="co">(* FIXME the real spec would allow reading less than all the bytes; recall len is maxlen *)</span>
  <span class="co">(* fsop_pread using a resolved name and an  *)</span>
  <span class="kw">val</span> fsop_pread_rn : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     res_name &#39;dir_ref &#39;file_ref -&gt; 
     nat -&gt; off_t -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_pread_rn env rn len ofs = (
    fsop_pread_rn_checks env rn len ofs &gt;&gt;= (<span class="kw">fun</span> _ -&gt; <span class="co">(* coverage:unused *)</span>
    fsop_pread_rn_core env rn len ofs)  <span class="co">(* coverage:unused *)</span>)



  <span class="co">(*--------------------------*)</span>
  <span class="co">(* opendir                  *)</span>
  <span class="co">(*--------------------------*)</span>

<span class="ot">#ifdef aspect_perms</span>
  <span class="kw">val</span> fsop_opendir_checks_perms : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt; 
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_opendir_checks_perms env rn = (fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt;
    (<span class="kw">match</span> rn <span class="kw">with</span> 
       <span class="dt">RN_dir</span>(d0_ref,_) -&gt; (fsm_cond_raise <span class="dt">EACCES</span> (not (env.env_prms.cp_has_dir_read_permission s0 d0_ref))) <span class="co">(*  posix/opendir.md EACCES:2 *)</span> 
     | _ -&gt; fsm_do_nothing 
    end)))
<span class="ot">#endif</span>

  <span class="kw">val</span> fsop_opendir_checks : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt; 
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_opendir_checks env rn = (
    (<span class="kw">match</span> rn <span class="kw">with</span> 
      | <span class="dt">RN_error</span> (e,_) -&gt; (fsm_raise e)
      | <span class="dt">RN_none</span> _ -&gt; (fsm_raise <span class="dt">ENOENT</span>)  <span class="co">(*  posix/opendir.md ENOENT:1 *)</span> 
      | <span class="dt">RN_file</span> _ -&gt; (fsm_raise <span class="dt">ENOTDIR</span>) <span class="co">(*  posix/opendir.md ENOTDIR:1 *)</span> 
      | <span class="dt">RN_dir</span>(d0_ref,rp) -&gt; fsm_do_nothing
     end)
<span class="ot">#ifdef aspect_perms</span>
    |||
      fsop_opendir_checks_perms env rn
<span class="ot">#endif</span>
  )

  <span class="kw">val</span> fsop_opendir_core : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt; 
     fsmonad &#39;impl &#39;dir_ref
  <span class="kw">let</span> fsop_opendir_core env rn = (
     <span class="kw">match</span> rn <span class="kw">with</span> 
      | <span class="dt">RN_dir</span>(d0_ref,rp) -&gt; fsm_return d0_ref
      | _ -&gt; fsm_special <span class="dt">Impossible</span> <span class="st">&quot;error raised before&quot;</span> <span class="co">(* coverage:impossible *)</span>
     end
  )

  <span class="kw">val</span> fsop_opendir : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt; 
     fsmonad &#39;impl &#39;dir_ref
  <span class="kw">let</span> fsop_opendir env rn = (
    fsop_opendir_checks env rn &gt;&gt;= (<span class="kw">fun</span> _ -&gt;
    fsop_opendir_core env rn))



  <span class="co">(*--------------------------*)</span>
  <span class="co">(* rename                   *)</span>
  <span class="co">(*--------------------------*)</span>

  <span class="co">(* NB later we may want to also return a state, given access times can cause changes when reading etc *)</span>
  <span class="co">(* FIXME surely a lot of this complexity is because this is the user land behaviour of the mv command - but we want to target the syscall interface *)</span>
  <span class="co">(* FIXME rename to subdir of self? *)</span>
  <span class="co">(* posix/rename.md *)</span>

  <span class="kw">val</span> fsop_rename_checks_rsrc_rdst : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_rename_checks_rsrc_rdst env rsrc rdst = (fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; (
      (fsm_cond_raise <span class="dt">ENOENT</span> (is_RN_none rsrc)) <span class="co">(* no src file; posix/rename.md ENOENT:1 *)</span>
        |||
      (<span class="kw">match</span> rsrc <span class="kw">with</span> 
        | <span class="dt">RN_error</span> (e,_) -&gt; fsm_raise e <span class="co">(* tr/2 *)</span>
        | _ -&gt; fsm_do_nothing
       end) 
        |||
      (<span class="kw">match</span> rdst <span class="kw">with</span> 
        | <span class="dt">RN_error</span> (e,_) -&gt; fsm_raise e <span class="co">(* tr/1 *)</span>
        | _ -&gt; fsm_do_nothing
       end)
        |||
      <span class="co">(* renaming files into non-files *)</span>
      (fsm_cond_raise <span class="dt">EISDIR</span> (is_RN_file rsrc &amp;&amp; is_RN_dir rdst)) <span class="co">(* posix/rename.md EISDIR:1 *)</span>
        |||
      (fsm_cond_raise <span class="dt">ENOTDIR</span> (is_RN_file rsrc &amp;&amp; is_RN_none rdst &amp;&amp; rn_ends_with_slash rdst &amp;&amp; not (is_mac_os_x_arch env))) 
        <span class="co">(* tr/3 similar to tr/5; posix/rename.md ENOTDIR:4</span>
<span class="co">           2014-10-27_mJ4/hfsplus_loop/rename/results/check_exec_rename___rename_nonempty_dir1__d2__f3.txt___nonempty_dir1__d2__sl_dotdot_no_such_target__-int.trace</span>
<span class="co">           rename &quot;nonempty_dir1/d2/f3.txt&quot;</span>
<span class="co">           &quot;nonempty_dir1/d2/sl_dotdot_no_such_target/&quot; gives RV_none, mac_os_x</span>
<span class="co">           non-posix behaviour ignores trailing slash when going via a symlink *)</span>
        |||
      (fsm_cond_raise <span class="dt">ENOENT</span> (is_RN_file rsrc &amp;&amp; is_RN_none rdst &amp;&amp; rn_ends_with_slash rdst &amp;&amp; is_mac_os_x_arch env 
        &amp;&amp; not (
        <span class="kw">let</span> rp = (<span class="kw">match</span> rdst <span class="kw">with</span> | <span class="dt">RN_none</span>(_,_,rp) -&gt; rp end) <span class="kw">in</span> 
        <span class="kw">let</span> cwd = rp.rp_cwd <span class="kw">in</span>
        <span class="kw">let</span> path = <span class="dt">CS_Some</span>(Resolve<span class="kw">.</span>ty_name_list_to_string rp.rp_nl) <span class="kw">in</span>
        Resolve<span class="kw">.</span>res_name_is_symlink env.env_ops s0 (Resolve<span class="kw">.</span>process_path_no_follow_no_trailing_slash env s0 cwd path))))  <span class="co">(* hfsplus_loop/rename/results/check_exec_rename___rename_nonempty_dir1__d2__f3.txt___nonempty_dir1__nonexist_4__-int.trace hfsplus_loop/rename/results/check_exec_rename___rename_nonempty_dir1__d2__f3.txt___nonempty_dir1__d2__sl_dotdot_no_such_target__-int.trace</span>
<span class="co">: the path &quot;nonempty_dir1/nonexist_4/&quot; is treated differently to &quot;nonempty_dir1/d2/sl_dotdot_no_such_target/&quot; *)</span>
        |||
      (fsm_cond_raise <span class="dt">ENOTDIR</span> (is_RN_file rsrc &amp;&amp; is_RN_dir rdst &amp;&amp; is_linux_arch env &amp;&amp; rn_ends_with_slash rdst)) <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
         <span class="co">(* tr/5 even if empty; arguably a Linux bug? Confirmed non-posix behaviour *)</span>
        |||
      (fsm_cond_raise <span class="dt">ENOTDIR</span> (is_RN_dir rsrc &amp;&amp; (is_RN_file rdst || is_RN_error rdst))) <span class="co">(* posix/rename.md ENOTDIR:2 *)</span>
        |||
      (fsm_cond_raise <span class="dt">ENOTDIR</span> (is_linux_arch env &amp;&amp; Resolve<span class="kw">.</span>res_name_is_symlink env.env_ops s0 rsrc &amp;&amp; rn_ends_with_slash rsrc)) <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
        |||
      (fsm_cond_raise <span class="dt">ENOTDIR</span> (is_linux_arch env &amp;&amp; Resolve<span class="kw">.</span>res_name_is_symlink env.env_ops s0 rdst &amp;&amp; rn_ends_with_slash rdst)) <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
        |||
      ( <span class="co">(* link to a non-empty directory *)</span>
          <span class="kw">match</span> rdst <span class="kw">with</span>
            | <span class="dt">RN_dir</span> (d0_ref, _) -&gt; (
                 <span class="kw">if</span> (not (dir_is_empty env.env_ops s0 d0_ref)) <span class="kw">then</span> 
                   fsm_raises [<span class="dt">ENOTEMPTY</span>;<span class="dt">EEXIST</span>]  <span class="co">(* tr/6 ENOTEMPTY:1 *)</span>
                 <span class="kw">else</span> 
                   fsm_do_nothing)
            | _ -&gt; fsm_do_nothing
         end
      ))))


  <span class="co">(* attempt to rename root? *)</span>
  <span class="kw">val</span> fsop_rename_checks_root : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_rename_checks_root env rsrc = (fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; (
    <span class="kw">match</span> rsrc <span class="kw">with</span>
    | <span class="dt">RN_dir</span> (d0_ref, _) -&gt; (  <span class="co">(* attempt to rename root on linux or mac? *)</span>
        <span class="kw">if</span> (Resolve<span class="kw">.</span>is_root_dir env.env_ops s0 d0_ref &amp;&amp; (is_linux_arch env || is_mac_os_x_arch env)) <span class="kw">then</span> (
          fsm_cond_raises [
            (<span class="dt">EBUSY</span>,<span class="kw">true</span>); <span class="co">(* http://fs.dsheets.name/2015-03-15_linux_ext+hfsplus+tmpfs/html/suite/rename/test/adhoc_rename_root-int.trace/index.html#23 ; also on Mac? *)</span>
            (<span class="dt">EISDIR</span>,is_mac_os_x_arch env)]) <span class="co">(* http://fs.dsheets.name/2015-03-16_osx_hfsplus+fusexmp+sshfs/html/suite/rename/test/adhoc_rename_root-int.trace/index.html#23 *)</span>
        <span class="kw">else</span>
          fsm_do_nothing) <span class="co">(* coverage:linux:mac_os_x:irrelevant *)</span>
    | _ -&gt; fsm_do_nothing end)))


  <span class="co">(* check that a directory is not renamed into a subdir of itself *)</span>
  <span class="kw">val</span> fsop_rename_checks_subdir : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_rename_checks_subdir env rsrc rdst = 
      ( 
        <span class="kw">let</span> rps_opt = <span class="kw">match</span> rsrc <span class="kw">with</span> <span class="dt">RN_dir</span> (_, rps) -&gt; <span class="dt">Just</span> rps | _ -&gt; <span class="dt">Nothing</span> end <span class="kw">in</span>
        <span class="kw">let</span> rpd_opt = <span class="kw">match</span> rdst <span class="kw">with</span> 
          | <span class="dt">RN_dir</span> (_, rpd) -&gt; <span class="dt">Just</span> rpd 
          | <span class="dt">RN_file</span> (_, _, _, rpd) -&gt; <span class="dt">Just</span> rpd
          | <span class="dt">RN_none</span> (_, _, rpd) -&gt; <span class="dt">Just</span> rpd
          | <span class="dt">RN_error</span> (e,&lt;|re_rn=<span class="dt">Just</span> (<span class="dt">RN_file</span>(_,_,_,rpd)) |&gt;) -&gt; <span class="dt">Just</span> rpd <span class="co">(* on Linux, this presumably captures rename /tmp/a /tmp/a/f1.txt/ ; FIXME this should only matter on Linux FIXME trace?*)</span>
          | <span class="dt">RN_error</span> (e,_) -&gt; <span class="dt">Nothing</span>
        end <span class="kw">in</span>
        <span class="kw">match</span> (rps_opt, rpd_opt) <span class="kw">with</span>
          | (<span class="dt">Just</span> rps, <span class="dt">Just</span> rpd) -&gt;
                 fsm_cond_raise <span class="dt">EINVAL</span> (realpath_proper_subdir rps rpd) <span class="co">(* posix/rename.md EINVAL:1 ; similar to tr/7 *)</span>
          | _ -&gt; fsm_do_nothing
        end
      )

  <span class="kw">val</span> fsop_rename_checks_parentdirs : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_rename_checks_parentdirs env rsrc rdst = fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; (
    ( <span class="co">(* ensure we can get the parent of rsrc *)</span>
      (<span class="kw">match</span> rsrc <span class="kw">with</span> 
        | <span class="dt">RN_dir</span> (d0_ref, _) -&gt; (
               <span class="co">(* Hack: This should be impossible because we assume that we can get the parent of every directory</span>
<span class="co">                  except root. We can&#39;t rename the root dir, because the subdir check would fail. However, we don&#39;t</span>
<span class="co">                  enforce that there are no disconnected dirs. So, as a hack, let&#39;s raise EINVAL as in the subdir check. *)</span>
               fsm_cond_raise <span class="dt">EINVAL</span> (isNothing (env.env_ops.fops_get_parent s0 d0_ref))
          )
        | _ -&gt; fsm_do_nothing
      end)
    ) |||
      <span class="co">(* ensure we can get the parent of rdst *)</span>
      (<span class="kw">match</span> rdst <span class="kw">with</span> 
        | <span class="dt">RN_dir</span> (d0_ref, _) -&gt; (
             <span class="co">(* Hack: This should be impossible because we assume that we can get the parent of every directory</span>
<span class="co">                except root. We can&#39;t rename to root dir, as we can only renaming an existing dir to a directory and</span>
<span class="co">                because the root is non-empty. However, we don&#39;t enforce that there are no disconnected dirs. So, as a hack, </span>
<span class="co">                 let&#39;s raise a proper error. *)</span>
               fsm_cond_raises [(<span class="dt">ENOTEMPTY</span>, isNothing (env.env_ops.fops_get_parent s0 d0_ref) &amp;&amp; is_RN_dir rsrc)  <span class="co">(* tr/6 ENOTEMPTY:1 *)</span>;
                            (<span class="dt">EEXIST</span>,    isNothing (env.env_ops.fops_get_parent s0 d0_ref) &amp;&amp; is_RN_dir rsrc)  <span class="co">(* tr/6 ENOTEMPTY:1 *)</span>]      
          )
        | _ -&gt; fsm_do_nothing
       end)
  ))

<span class="ot">#ifdef aspect_perms</span>
  <span class="kw">val</span> fsop_rename_checks_perms : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_rename_checks_perms env rsrc rdst = fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; (
      ( <span class="co">(* write permission for dir of rsrc *)</span>
        <span class="kw">match</span> parent_dir_of_res_name env.env_ops s0 rsrc <span class="kw">with</span>
          | <span class="dt">Nothing</span> -&gt; fsm_do_nothing
          | <span class="dt">Just</span> d0_ref -&gt; fsm_cond_raise <span class="dt">EACCES</span> (not (env.env_prms.cp_has_dir_write_permission s0 d0_ref)) <span class="co">(* posix/rename.md EACCES:2 *)</span>
        end
      ) |||
      ( <span class="co">(* write permission for dir of rdst *)</span>
        <span class="kw">match</span> parent_dir_of_res_name env.env_ops s0 rdst <span class="kw">with</span>
          | <span class="dt">Nothing</span> -&gt; fsm_do_nothing
          | <span class="dt">Just</span> d0_ref -&gt; fsm_cond_raise <span class="dt">EACCES</span> (not (env.env_prms.cp_has_dir_write_permission s0 d0_ref)) <span class="co">(* posix/rename.md EACCES:3 *)</span>
        end
      ) |||
      ( <span class="co">(* restricted delete/rename permission for dir of rsrc ( posix/rename.md EPERM:1 EACCES:6 ) *)</span>
        <span class="kw">if</span> res_name_has_restricted_delete_privilege env s0 rsrc <span class="kw">then</span>
           fsm_do_nothing
        <span class="kw">else</span>
           fsm_raises [<span class="dt">EPERM</span>; <span class="dt">EACCES</span>] <span class="co">(* posix/rename.md EPERM:1 EACCES:6 *)</span>
      ) |||
      ( <span class="co">(* restricted delete/rename permission for dir of rdst ( posix/rename.md EPERM:2 EACCES:7 ) *)</span>
        <span class="kw">if</span> res_name_has_restricted_delete_privilege env s0 rdst <span class="kw">then</span>
           fsm_do_nothing
        <span class="kw">else</span>
           fsm_raises [<span class="dt">EPERM</span>; <span class="dt">EACCES</span>] <span class="co">(* posix/rename.md EPERM:1 EACCES:6 *)</span>
      ) |||
      ( <span class="co">(* write permission for dir rsrc *)</span>
        <span class="kw">match</span> rsrc <span class="kw">with</span>
          | <span class="dt">RN_dir</span>(d0_ref, _) -&gt; fsm_cond_raise <span class="dt">EACCES</span> (not (env.env_prms.cp_has_dir_write_permission s0 d0_ref)) <span class="co">(* posix/rename.md EACCES:4 *)</span>
          | _ -&gt; fsm_do_nothing
        end
      ) |||
      ( <span class="co">(* write permission for dir rdst *)</span>
        <span class="kw">match</span> rdst <span class="kw">with</span>
          | <span class="dt">RN_dir</span>(d0_ref, _) -&gt; fsm_cond_raise <span class="dt">EACCES</span> (not (env.env_prms.cp_has_dir_write_permission s0 d0_ref)) <span class="co">(* posix/rename.md EACCES:5 *)</span>
          | _ -&gt; fsm_do_nothing
        end
      )))
<span class="ot">#endif</span>

  <span class="kw">val</span> fsop_rename_same_rsrc_rdst : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     &#39;impl -&gt;
     <span class="dt">bool</span>
  <span class="kw">let</span> fsop_rename_same_rsrc_rdst env rsrc rdst s0 = (<span class="kw">match</span> (rsrc, rdst) <span class="kw">with</span>
    | (<span class="dt">RN_file</span> (_,_,i0_ref,_), <span class="dt">RN_file</span> (_,_,i1_ref,_)) -&gt; (
        <span class="kw">if</span> ( 
          <span class="co">(* under linux, eg nonempty_dir1/d2/sl_dotdot_f1.txt/ is not the same as itself!; or rather, we want the checks on paths to occur, so we set this test to fail *)</span>
          is_linux_arch env 
          &amp;&amp; ((Resolve<span class="kw">.</span>res_name_is_symlink env.env_ops s0 rsrc &amp;&amp; rn_ends_with_slash rsrc)  <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
              || (Resolve<span class="kw">.</span>res_name_is_symlink env.env_ops s0 rdst &amp;&amp; rn_ends_with_slash rdst)))  <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
        <span class="kw">then</span> 
          <span class="kw">false</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
        <span class="kw">else</span>
          (Resolve<span class="kw">.</span>res_name_is_symlink env.env_ops s0 rsrc &amp;&amp; rn_ends_with_slash rdst)) <span class="co">(* FIXME this isn&#39;t right - surely we should check i0_ref and i1_ref - need to see where this breaks the rename tests *)</span>
    | (<span class="dt">RN_dir</span> (d0_ref,_), <span class="dt">RN_dir</span> (d1_ref,_)) -&gt; 
        (env.env_ops.fops_dir_ref_eq s0 d1_ref d0_ref)
    | _ -&gt; <span class="kw">false</span>
  end)

  <span class="kw">val</span> fsop_rename_checks : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_rename_checks env rsrc rdst = (fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt;
    <span class="kw">if</span> (fsop_rename_same_rsrc_rdst env rsrc rdst s0) <span class="kw">then</span>
      fsm_do_nothing <span class="co">(* posix/rename.md RENAME:3 *)</span>
    <span class="kw">else</span> 
      ( fsop_rename_checks_rsrc_rdst env rsrc rdst 
          |||
        fsop_rename_checks_root env rsrc
          |||
        fsop_rename_checks_subdir env rsrc rdst 
          |||
        fsop_rename_checks_parentdirs env rsrc rdst <span class="co">(* hack to make the invariant that the parent-dirs exist explicit *)</span>
<span class="ot">#ifdef aspect_perms</span>
          |||
        fsop_rename_checks_perms env rsrc rdst
<span class="ot">#endif</span>
      )
  ))

  <span class="kw">val</span> fsop_rename_core : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_rename_core env rsrc rdst = (fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt;
    (<span class="kw">match</span> (rsrc, rdst) <span class="kw">with</span>
    | (<span class="dt">RN_file</span> (d0_ref,nsrc,_,_), <span class="dt">RN_none</span> (d1_ref, ndst, _)) -&gt; 
        <span class="co">(* do the move; there is no file ns_dst *)</span>
        fsm_put_state (env.env_ops.fops_mvfile s0 d0_ref nsrc d1_ref ndst)
    | (<span class="dt">RN_file</span> (d0_ref,nsrc,i0_ref,_), <span class="dt">RN_file</span> (d1_ref,ndst,i1_ref,_)) -&gt; (
        <span class="co">(* do the move; there is a file name ns_dst *)</span>
        <span class="kw">if</span> (env.env_ops.fops_file_ref_eq s0 i1_ref i0_ref) <span class="kw">then</span> 
          fsm_return <span class="dt">RV_none</span>  <span class="co">(* tr/4; posix/rename.md RENAME:3 *)</span>
        <span class="kw">else</span>
          fsm_put_state (env.env_ops.fops_mvfile s0 d0_ref nsrc d1_ref ndst))
    | (<span class="dt">RN_dir</span> (d0_ref,rps), <span class="dt">RN_none</span> (d1_ref,ndst,rpd)) -&gt; 
        <span class="co">(* do the move; there is no file ns_dst *)</span>
        <span class="kw">let</span> p = env.env_ops.fops_get_parent s0 d0_ref <span class="kw">in</span>
        (<span class="kw">match</span> p <span class="kw">with</span> 
           | <span class="dt">Nothing</span> -&gt; (fsm_special <span class="dt">Impossible</span> <span class="st">&quot;src was root; can not happen because subdir would be true&quot;</span>) <span class="co">(* coverage:impossible*)</span>
           | <span class="dt">Just</span>(d0_ref,nsrc) -&gt; (
                fsm_put_state (env.env_ops.fops_mvdir s0 d0_ref nsrc d1_ref ndst)) end)
    | (<span class="dt">RN_dir</span> (d0_ref,_), <span class="dt">RN_dir</span> (d1_ref,_)) -&gt; 
        <span class="co">(* if same dir, return silently *)</span>
        (<span class="kw">if</span> (env.env_ops.fops_dir_ref_eq s0 d1_ref d0_ref) <span class="kw">then</span>
          (fsm_return <span class="dt">RV_none</span>) <span class="co">(* tr/8  posix/rename.md RENAME:3 *)</span>
        <span class="kw">else</span> 
          <span class="kw">let</span> x = env.env_ops.fops_get_parent s0 d0_ref <span class="kw">in</span>
          <span class="kw">let</span> y = env.env_ops.fops_get_parent s0 d1_ref <span class="kw">in</span>
          (<span class="kw">match</span> (x,y) <span class="kw">with</span>
          | (<span class="dt">Nothing</span>,_) -&gt; (fsm_special <span class="dt">Impossible</span> <span class="st">&quot;impossible 1763&quot;</span>)  <span class="co">(* attempt to rename root; captured by subdir check above *)</span> <span class="co">(* coverage:impossible *)</span>
          | (_,<span class="dt">Nothing</span>) -&gt; (
            fsm_special <span class="dt">Impossible</span> <span class="st">&quot;impossible 1765 rename of dir onto root; can not happen because dst must be nonempty&quot;</span>) <span class="co">(* coverage:impossible *)</span>
          | (<span class="dt">Just</span>(d0_ref&#39;,nsrc),<span class="dt">Just</span>(d1_ref&#39;,ndst)) -&gt; (
            fsm_put_state (env.env_ops.fops_mvdir s0 d0_ref&#39; nsrc d1_ref&#39; ndst)) end))
    | _ -&gt; fsm_special <span class="dt">Impossible</span> <span class="st">&quot;error raised before&quot;</span> <span class="co">(* coverage:impossible *)</span>
     end)))



  <span class="kw">val</span> fsop_rename : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_rename env rsrc rdst = (fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; 
    <span class="kw">let</span> (rsrc,rdst) = <span class="kw">if</span> (is_mac_os_x_arch env) <span class="kw">then</span> (mac_os_x_map_rpath env s0 rsrc, mac_os_x_map_rpath env s0 rdst) <span class="kw">else</span> (rsrc,rdst) <span class="kw">in</span>
    (fsop_rename_checks env rsrc rdst &gt;&gt;= (<span class="kw">fun</span> _ -&gt;
         fsop_rename_core env rsrc rdst))))



  <span class="co">(*--------------------------*)</span>
  <span class="co">(* rmdir                    *)</span>
  <span class="co">(*--------------------------*)</span>

<span class="ot">#ifdef aspect_perms</span>
  <span class="kw">val</span> fsop_rmdir_checks_perms: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     &#39;dir_ref -&gt;
     &#39;dir_ref -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_rmdir_checks_perms env d0_ref d1_ref = 
    <span class="co">(* we want to remove d0_ref, which lives in dir d1_ref *)</span>
    fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; 

    (fsm_cond_raise <span class="dt">EACCES</span> (not (env.env_prms.cp_has_dir_write_permission s0 d1_ref)) <span class="co">(* posix/rmdir.md EACCES:2 *)</span>) 
       |||
    (
       <span class="kw">let</span> arch = architecture_of_ty_arch env.env_arch <span class="kw">in</span>
       <span class="kw">let</span> arch_allows_removing_writable = arch.arch_allows_removing_from_protected_dir_if_writeable <span class="kw">in</span>
       <span class="kw">let</span> delete_ok = (env.env_prms.cp_has_dir_restricted_delete_privilege arch_allows_removing_writable s0 d1_ref d0_ref) <span class="kw">in</span>
       <span class="kw">if</span> delete_ok
       <span class="kw">then</span> fsm_do_nothing
       <span class="kw">else</span> fsm_raises [<span class="dt">EPERM</span>; <span class="dt">EACCES</span>] <span class="co">(* posix/rmdir.md EPERM:1 EACCES:3 *)</span>
    ))
<span class="ot">#endif</span>

  <span class="kw">val</span> fsop_rmdir_checks: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_rmdir_checks env rpath = 
    fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; 
    (<span class="kw">match</span> rpath <span class="kw">with</span> 
      | <span class="dt">RN_file</span> _ -&gt; (fsm_raise <span class="dt">ENOTDIR</span>)  <span class="co">(* posix/rmdir.md ENOTDIR:1 *)</span>
      | <span class="dt">RN_none</span> _ -&gt; (fsm_raise <span class="dt">ENOENT</span>)  <span class="co">(* posix/rmdir.md ENOENT:1 *)</span>
      | <span class="dt">RN_error</span> (e,_) -&gt; (fsm_raise e) 
      | <span class="dt">RN_dir</span>(d0_ref,_) -&gt; (
          (<span class="kw">if</span> (not (dir_is_empty env.env_ops s0 d0_ref)) <span class="kw">then</span> fsm_raises [<span class="dt">ENOTEMPTY</span>;<span class="dt">EEXIST</span>] <span class="kw">else</span> fsm_do_nothing) 
            |||
          (<span class="kw">match</span> (env.env_ops.fops_get_parent s0 d0_ref) <span class="kw">with</span>
            | <span class="dt">Nothing</span> -&gt;
               <span class="kw">if</span> (is_linux_arch env || is_mac_os_x_arch env)
               <span class="kw">then</span>
                 (fsm_raise <span class="dt">EBUSY</span>) <span class="co">(* coverage:posix:irrelevant *)</span>
               <span class="kw">else</span>
                 fsm_special <span class="dt">Implementation_defined</span> <span class="co">(* coverage:linux:mac_os_x:irrelevant *)</span>
               <span class="st">&quot;rmdir: attempt to remove root; implementation defined behaviour; may throw EBUSY or remove the root directory; see posix/rmdir.md EBUSY:1&quot;</span> <span class="co">(* FIXME use parameters to isolate implementation-defined behaviour *)</span>
<span class="ot">#ifdef aspect_perms</span>
            | <span class="dt">Just</span> (d1_ref, _) -&gt; fsop_rmdir_checks_perms env d0_ref d1_ref
<span class="ot">#else</span>
            | <span class="dt">Just</span> _ -&gt; fsm_do_nothing
<span class="ot">#endif</span>
          end))
     end))


  <span class="kw">val</span> fsop_rmdir_core: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_rmdir_core env rpath = 
    fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; 
    (<span class="kw">match</span> rpath <span class="kw">with</span> 
      | <span class="dt">RN_dir</span>(d0_ref,_) -&gt; 
         (<span class="kw">match</span> env.env_ops.fops_get_parent s0 d0_ref <span class="kw">with</span>
            | <span class="dt">Nothing</span> -&gt; fsm_special <span class="dt">Impossible</span> <span class="st">&quot;error raised before&quot;</span> <span class="co">(* coverage:impossible *)</span>
            | <span class="dt">Just</span> (d1_ref, n) -&gt;  
                <span class="kw">let</span> s1 = env.env_ops.fops_unlink s0 d1_ref n <span class="kw">in</span>  
                fsm_put_state s1
          end)
      | _ -&gt; fsm_special <span class="dt">Impossible</span> <span class="st">&quot;error raised before&quot;</span> <span class="co">(* coverage:impossible *)</span>
    end))

  <span class="kw">val</span> fsop_rmdir: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_rmdir env rpath = 
    (fsop_rmdir_checks env rpath &gt;&gt;= (<span class="kw">fun</span> _ -&gt;
     fsop_rmdir_core env rpath))



  <span class="co">(*--------------------------*)</span>
  <span class="co">(* stat                     *)</span>
  <span class="co">(*--------------------------*)</span>

  <span class="kw">val</span> fsop_stat_checks : forall &#39;dir_ref &#39;file_ref &#39;impl.
     fs_ops &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_stat_checks ops rn = 
    (<span class="kw">match</span> rn <span class="kw">with</span>
    | <span class="dt">RN_error</span> (e,_) -&gt; (fsm_raise e)
    | <span class="dt">RN_none</span> _ -&gt; (fsm_raise <span class="dt">ENOENT</span>) 
    | _ -&gt; fsm_do_nothing
    end)


  <span class="kw">val</span> fsop_stat_core: forall &#39;dir_ref &#39;file_ref &#39;impl.
     fs_ops &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_stat_core ops rn = (
    fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; (
    (<span class="kw">match</span> rn <span class="kw">with</span>
    | <span class="dt">RN_file</span>(d0_ref,n,i0_ref,rp) -&gt; (fsm_return (<span class="dt">RV_stats</span> (ops.fops_stat_file s0 i0_ref)))
    | <span class="dt">RN_dir</span>(d0_ref,rp) -&gt; (fsm_return (<span class="dt">RV_stats</span> (ops.fops_stat_dir s0 d0_ref)))
    | _ -&gt; fsm_special <span class="dt">Impossible</span> <span class="st">&quot;error raised before&quot;</span> end)))) <span class="co">(* coverage:impossible *)</span>

  <span class="kw">val</span> fsop_stat: forall &#39;dir_ref &#39;file_ref &#39;impl.
     fs_ops &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_stat ops rn = (
    fsop_stat_checks ops rn &gt;&gt;= (<span class="kw">fun</span> _ -&gt;
    fsop_stat_core ops rn))



  <span class="co">(*--------------------------*)</span>
  <span class="co">(* lstat                    *)</span>
  <span class="co">(*--------------------------*)</span>

  <span class="kw">val</span> fsop_lstat: forall &#39;dir_ref &#39;file_ref &#39;impl.
     fs_ops &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_lstat ops rn =
    (fsop_stat_checks ops rn &gt;&gt;=
       (<span class="kw">fun</span> _ -&gt; fsop_stat_core ops rn))


  <span class="co">(*--------------------------*)</span>
  <span class="co">(* truncate                 *)</span>
  <span class="co">(*--------------------------*)</span>

<span class="ot">#ifdef aspect_perms</span>
  <span class="kw">val</span> fsop_truncate_checks_perms: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; <span class="dt">int</span> -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_truncate_checks_perms env rpath len = (fsm_get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
       (<span class="kw">match</span> rpath <span class="kw">with</span> 
         | <span class="dt">RN_file</span>(_,_,i0_ref,_) -&gt; 
             (fsm_cond_raise <span class="dt">EACCES</span> (not (env.env_prms.cp_has_file_write_permission s0 i0_ref))) <span class="co">(* posix/truncate.md EACCES:2 *)</span>
         | _ -&gt; fsm_do_nothing
        end))
<span class="ot">#endif</span>

  <span class="kw">val</span> fsop_truncate_checks: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; <span class="dt">int</span> -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_truncate_checks env rpath len = (    
       (fsm_cond_raise <span class="dt">EINVAL</span> (len &lt; <span class="dv">0</span>)) <span class="co">(* posix/truncate.md EINVAL:1 *)</span>
          |||
       (<span class="kw">match</span> rpath <span class="kw">with</span> 
         | <span class="dt">RN_error</span> (e,_) -&gt; (fsm_raise e)
         | <span class="dt">RN_none</span> _ -&gt; (fsm_raise <span class="dt">ENOENT</span>) <span class="co">(* posix/truncate.md ENOENT:1 *)</span>
         | <span class="dt">RN_dir</span> _ -&gt; (fsm_raise <span class="dt">EISDIR</span>) <span class="co">(* posix/truncate.md EISDIR:1 *)</span>
         | <span class="dt">RN_file</span>(_,_,i0_ref,_) -&gt; fsm_do_nothing
        end)
<span class="ot">#ifdef aspect_perms</span>
    |||
       (fsop_truncate_checks_perms env rpath len)
<span class="ot">#endif</span>
  )
    
  <span class="kw">val</span> fsop_truncate_core: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; <span class="dt">int</span> -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_truncate_core env rpath len = (
    fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt;
    (<span class="kw">match</span> rpath <span class="kw">with</span> 
       | <span class="dt">RN_file</span>(_,_,i0_ref,_) -&gt; <span class="kw">begin</span>
           <span class="kw">let</span> len = natFromInt len <span class="kw">in</span>
           <span class="kw">let</span> (s0, res) = env.env_ops.fops_read s0 i0_ref <span class="kw">in</span>
           <span class="kw">let</span> bs = dest_RV_bytes res <span class="kw">in</span>
           <span class="co">(* create a new array, of length len, with same contents *)</span>
           <span class="kw">let</span> bs&#39; = T_list_array<span class="kw">.</span>resize bs len <span class="kw">in</span>
           <span class="kw">let</span> s0 = env.env_ops.fops_write s0 i0_ref bs&#39; <span class="kw">in</span>
           fsm_put_state s0
         <span class="kw">end</span> 
       | _ -&gt; fsm_special <span class="dt">Impossible</span> <span class="st">&quot;error raised before&quot;</span> <span class="co">(* coverage:impossible *)</span>
     end)))
   

  <span class="kw">val</span> fsop_truncate: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     <span class="dt">int</span> -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_truncate env rpath len = (    
    <span class="kw">let</span> default rpath =
      fsop_truncate_checks env rpath len &gt;&gt;= (<span class="kw">fun</span> _ -&gt;
      fsop_truncate_core env rpath len)
    <span class="kw">in</span>
    (<span class="kw">match</span> (rpath, is_mac_os_x_arch env) <span class="kw">with</span>
     | (<span class="dt">RN_error</span>(<span class="dt">ENOTDIR</span>,&lt;|re_nl=<span class="dt">Just</span> nl;re_rn=<span class="dt">Just</span> fopt|&gt;),<span class="kw">true</span>) -&gt; (
         <span class="co">(* exec_truncate___truncate_nonempty_dir1__d2__sl_dotdot_f1.txt_____0-int.trace for truncate mac os x can resolve nonempty_dir1/d2/sl_dotdot_f1.txt/ to a file FIXME non-posix behaviour *)</span>
        fsm_choice (default fopt) (default rpath))
    | (_,_) -&gt; default rpath end))




  <span class="co">(*--------------------------*)</span>
  <span class="co">(* unlink                   *)</span>
  <span class="co">(*--------------------------*)</span>

<span class="ot">#ifdef aspect_perms</span>
  <span class="kw">val</span> fsop_unlink_checks_perms : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_unlink_checks_perms env rpath = (
    fsm_get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    (<span class="kw">match</span> rpath <span class="kw">with</span> 
    | <span class="dt">RN_file</span>(d0_ref,n,i0_ref,rp) -&gt; (
      <span class="kw">begin</span> <span class="co">(* check permissions *)</span>
        fsm_cond_raise <span class="dt">EACCES</span> (not (env.env_prms.cp_has_dir_write_permission s0 d0_ref)) <span class="co">(* posix/unlink.md EACCES:2 *)</span>
          |||
        (
          <span class="kw">let</span> arch = architecture_of_ty_arch env.env_arch <span class="kw">in</span>
          <span class="kw">let</span> arch_allows_removing_writable = arch.arch_allows_removing_from_protected_dir_if_writeable <span class="kw">in</span>
          <span class="kw">let</span> delete_ok = (env.env_prms.cp_has_file_restricted_delete_privilege arch_allows_removing_writable s0 d0_ref i0_ref) <span class="kw">in</span>
          <span class="kw">if</span> delete_ok
          <span class="kw">then</span> fsm_do_nothing
          <span class="kw">else</span> fsm_raises [<span class="dt">EPERM</span>; <span class="dt">EACCES</span>] <span class="co">(* posix/unlink.md EPERM:2 EACCES:3 *)</span>
        )        
      <span class="kw">end</span>)
    | _ -&gt; fsm_do_nothing
    end))
<span class="ot">#endif</span>

  <span class="kw">val</span> fsop_unlink_checks : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_unlink_checks env rpath = 
    fsm_get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    (<span class="kw">match</span> rpath <span class="kw">with</span> 
      | <span class="dt">RN_error</span>(e,_) -&gt; fsm_raise e
      | <span class="dt">RN_none</span> _ -&gt; (fsm_cond_raises
          [(<span class="dt">ENOENT</span>,<span class="kw">true</span>); <span class="co">(* posix/unlink.md ENOENT:1 *)</span>
           (<span class="dt">ENOTDIR</span>,is_linux_arch env &amp;&amp; rn_ends_with_slash rpath)])  <span class="co">(* FIXME possibly posix/unlink.md ENOTDIR:2 , tr/25 *)</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
      | <span class="dt">RN_dir</span> _ -&gt; (fsm_cond_raises
                       [(<span class="dt">EISDIR</span>,is_linux_arch env);
                        (<span class="dt">EPERM</span>,<span class="kw">true</span>)]) <span class="co">(* posix/unlink.md EPERM:1 *)</span> <span class="co">(* LSB has EISDIR; POSIX requires EPERM; FIXME parameterize *)</span>
      | <span class="dt">RN_file</span>(d0_ref,n,i0_ref,rp) -&gt; (
          fsm_cond_raise <span class="dt">ENOTDIR</span> (is_linux_arch env &amp;&amp; Resolve<span class="kw">.</span>res_name_is_symlink env.env_ops s0 rpath &amp;&amp; rn_ends_with_slash rpath)) <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
    end) 
<span class="ot">#ifdef aspect_perms</span>
      |||
    fsop_unlink_checks_perms env rpath
<span class="ot">#endif</span>

  <span class="kw">val</span> fsop_unlink_core: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_unlink_core env rpath = (
    fsm_get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    (<span class="kw">match</span> rpath <span class="kw">with</span> 
      | <span class="dt">RN_file</span>(d0_ref,n,_,_) -&gt; (
          <span class="kw">let</span> s0 = env.env_ops.fops_unlink s0 d0_ref n <span class="kw">in</span>
          fsm_put_state s0) 
      | _ -&gt; fsm_special <span class="dt">Impossible</span> <span class="st">&quot;error raised before&quot;</span> <span class="co">(* coverage:impossible *)</span>
     end))

  <span class="kw">val</span> fsop_unlink: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_unlink env rpath = (
    <span class="kw">let</span> default rpath = 
      fsop_unlink_checks env rpath &gt;&gt;= (<span class="kw">fun</span> _ -&gt;
          fsop_unlink_core env rpath)
    <span class="kw">in</span>
    (<span class="kw">match</span> (rpath, is_mac_os_x_arch env) <span class="kw">with</span>
     | (<span class="dt">RN_error</span>(<span class="dt">ENOTDIR</span>,&lt;|re_nl=<span class="dt">Just</span> nl;re_rn=<span class="dt">Just</span> fopt|&gt;),<span class="kw">true</span>) -&gt; (
         <span class="co">(* exec_unlink___unlink_nonempty_dir1__sl_f1.txt__-int.trace for unlink mac os x can resolve sl_f1.txt/ to a file FIXME non-posix behaviour *)</span>
         fsm_choice (default fopt) (default rpath))
     | (_,_) -&gt; default rpath end))


  <span class="co">(*--------------------------*)</span>
  <span class="co">(* chmod                    *)</span>
  <span class="co">(*--------------------------*)</span>

<span class="ot">#ifdef aspect_perms</span>
  <span class="kw">val</span> fsop_chmod_checks_perms : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; file_perm -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_chmod_checks_perms env rpath perm = (
    fsm_get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    (<span class="kw">match</span> rpath <span class="kw">with</span> 
    | <span class="dt">RN_file</span>(_,_,i0_ref,_) -&gt; 
        fsm_cond_raise <span class="dt">EPERM</span> (not (env.env_prms.cp_has_file_chmod_permission s0 i0_ref))        
    | <span class="dt">RN_dir</span>(d0_ref, _) -&gt; 
        fsm_cond_raise <span class="dt">EPERM</span> (not (env.env_prms.cp_has_dir_chmod_permission s0 d0_ref))        
    | _ -&gt; fsm_do_nothing
    end))
<span class="ot">#endif</span>

  <span class="kw">val</span> fsop_chmod_checks : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; file_perm -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_chmod_checks env rpath perm = 
    (<span class="kw">match</span> rpath <span class="kw">with</span> 
      | <span class="dt">RN_error</span>(e,_) -&gt; (fsm_raise e)
      | <span class="dt">RN_none</span> _ -&gt; (fsm_raise <span class="dt">ENOENT</span>) <span class="co">(* posix/chmod.md ENOENT:1 *)</span>
      | <span class="dt">RN_dir</span> _ -&gt; fsm_do_nothing
      | <span class="dt">RN_file</span> _ -&gt; fsm_do_nothing
    end) 
<span class="ot">#ifdef aspect_perms</span>
      |||
    fsop_chmod_checks_perms env rpath perm
<span class="ot">#endif</span>

  <span class="kw">val</span> fsop_chmod_core: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; file_perm -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_chmod_core env rpath perm = 
<span class="ot">#ifdef aspect_perms</span>
    fsm_get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    (<span class="kw">match</span> rpath <span class="kw">with</span> 
      | <span class="dt">RN_file</span>(_,_,i0_ref,_) -&gt; (
          <span class="kw">let</span> s1 = env.env_perm_ops.pops_set_perm_file s0 perm i0_ref <span class="kw">in</span>
          fsm_put_state s1)
      | <span class="dt">RN_dir</span>(d0_ref, _) -&gt; (         
          <span class="kw">let</span> s1 = env.env_perm_ops.pops_set_perm_dir s0 perm d0_ref <span class="kw">in</span>
          fsm_put_state s1)
      | _ -&gt; fsm_special <span class="dt">Impossible</span> <span class="st">&quot;error raised before&quot;</span> <span class="co">(* coverage:impossible *)</span>
     end)
<span class="ot">#else</span>
     fsm_do_nothing
<span class="ot">#endif</span>

  <span class="kw">val</span> fsop_chmod: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     file_perm -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_chmod env rpath perm = (
    fsop_chmod_checks env rpath perm &gt;&gt;= (<span class="kw">fun</span> _ -&gt;
    fsop_chmod_core env rpath perm))



  <span class="co">(*--------------------------*)</span>
  <span class="co">(* chown                    *)</span>
  <span class="co">(*--------------------------*)</span>

<span class="ot">#ifdef aspect_perms</span>
  <span class="kw">val</span> fsop_chown_checks_perms : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; uid -&gt; gid -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_chown_checks_perms env rpath u g = (
    fsm_get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    (<span class="kw">match</span> rpath <span class="kw">with</span> 
    | <span class="dt">RN_file</span>(_,_,i0_ref,_) -&gt; 
        fsm_cond_raise <span class="dt">EPERM</span> (not (env.env_prms.cp_has_file_chown_permission s0 i0_ref))        
    | <span class="dt">RN_dir</span>(d0_ref, _) -&gt; 
        fsm_cond_raise <span class="dt">EPERM</span> (not (env.env_prms.cp_has_dir_chown_permission s0 d0_ref))        
    | _ -&gt; fsm_do_nothing
    end))
<span class="ot">#endif</span>

  <span class="kw">val</span> fsop_chown_checks : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; uid -&gt; gid -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_chown_checks env rpath u g = 
    (<span class="kw">match</span> rpath <span class="kw">with</span> 
      | <span class="dt">RN_error</span>(e,_) -&gt; (fsm_raise e)
      | <span class="dt">RN_none</span> _ -&gt; (fsm_raise <span class="dt">ENOENT</span>) <span class="co">(* posix/chown.md ENOENT:1 *)</span>
      | <span class="dt">RN_dir</span> _ -&gt; fsm_do_nothing
      | <span class="dt">RN_file</span> _ -&gt; fsm_do_nothing
    end) 
<span class="ot">#ifdef aspect_perms</span>
      |||
    fsop_chown_checks_perms env rpath u g
<span class="ot">#endif</span>

  <span class="kw">val</span> fsop_chown_core: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; uid -&gt; gid -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_chown_core env rpath u g = 
<span class="ot">#ifdef aspect_perms</span>
    fsm_get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    (<span class="kw">match</span> rpath <span class="kw">with</span> 
      | <span class="dt">RN_file</span>(_,_,i0_ref,_) -&gt; (
          <span class="kw">let</span> s1 = env.env_perm_ops.pops_chown_file s0 (u, g) i0_ref <span class="kw">in</span>
          fsm_put_state s1)
      | <span class="dt">RN_dir</span>(d0_ref, _) -&gt; (         
          <span class="kw">let</span> s1 = env.env_perm_ops.pops_chown_dir s0 (u, g) d0_ref <span class="kw">in</span>
          fsm_put_state s1)
      | _ -&gt; fsm_special <span class="dt">Impossible</span> <span class="st">&quot;error raised before&quot;</span> <span class="co">(* coverage:impossible *)</span>
     end)
<span class="ot">#else</span>
     fsm_do_nothing
<span class="ot">#endif</span>

  <span class="kw">val</span> fsop_chown: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     uid -&gt; gid -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_chown env rpath u g = (
    fsop_chown_checks env rpath u g &gt;&gt;= (<span class="kw">fun</span> _ -&gt;
    fsop_chown_core env rpath u g))


  <span class="co">(*--------------------------*)</span>
  <span class="co">(* pwrite                   *)</span>
  <span class="co">(*--------------------------*)</span>

  <span class="kw">val</span> fsop_pwrite_checks: forall &#39;dir_ref &#39;file_ref &#39;impl.
     fs_ops &#39;dir_ref &#39;file_ref &#39;impl -&gt; entry &#39;dir_ref &#39;file_ref -&gt; ty_bytes -&gt; nat -&gt; off_t -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_pwrite_checks ops entry bs len ofs = (
      (fsm_cond_raise <span class="dt">EINVAL</span> (ofs &lt; <span class="dv">0</span>) <span class="co">(* invariant: offsets can never be &lt; 0 *)</span>)
         |||
      (fsm_cond_raise <span class="dt">EISDIR</span> (is_dir_ref_entry entry) <span class="co">(* coverage:impossible - it is impossible to open a directory with a write flag, so pwrite cannot obtain a directory entry *)</span>
           <span class="co">(* posix does not allow writing to a dir. However, this is not explicit.</span>
<span class="co">              Posix specifies write in terms of file-descriptors.</span>
<span class="co">              It requires that the file descriptor is writeable (posix/write.md EBADF:1). However,</span>
<span class="co">              directories cannot be opened for writing (posix/open.md EISDIR:1). Therefore, we cannot</span>
<span class="co">              write to a directory. *)</span>
      )
  )

  <span class="kw">val</span> fsop_pwrite_core: forall &#39;dir_ref &#39;file_ref &#39;impl.
     fs_ops &#39;dir_ref &#39;file_ref &#39;impl -&gt; entry &#39;dir_ref &#39;file_ref -&gt; ty_bytes -&gt; nat -&gt; off_t -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_pwrite_core ops entry bs len ofs = fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt;
      (<span class="kw">match</span> entry <span class="kw">with</span>
        | <span class="dt">Dir_ref_entry</span> _ -&gt; fsm_special <span class="dt">Impossible</span> <span class="st">&quot;error raised before&quot;</span> <span class="co">(* coverage:impossible *)</span>
        | <span class="dt">File_ref_entry</span> i0_ref -&gt; (
            <span class="kw">let</span> (s1, res) = ops.fops_read s0 i0_ref <span class="kw">in</span>
            <span class="kw">let</span> bs&#39; = dest_RV_bytes res <span class="kw">in</span>

            <span class="co">(* non-deterministically choose the amount of data to write, if</span>
<span class="co">               an interrupt occurs during writing or the file-size reaches</span>
<span class="co">               some limit write might not write all the data given. *)</span>
            (fsm_choose_nat len &gt;&gt;= (<span class="kw">fun</span> len_written -&gt;
              <span class="co">(* want to create a new array from bs&#39; and bs *)</span>
              <span class="kw">let</span> bs&#39;&#39; = T_list_array<span class="kw">.</span>list_array_write (bs,<span class="dv">0</span>,len_written) (bs&#39;,natFromInt ofs) <span class="kw">in</span>
              <span class="kw">let</span> s2 = ops.fops_write s1 i0_ref bs&#39;&#39; <span class="kw">in</span>
              fsm_put_state_return s2 (<span class="dt">RV_num</span> len_written)
            )))
       end))

  <span class="kw">val</span> fsop_pwrite: forall &#39;dir_ref &#39;file_ref &#39;impl.
     fs_ops &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     entry &#39;dir_ref &#39;file_ref -&gt;
     ty_bytes -&gt;
     nat -&gt;
     off_t -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_pwrite ops entry bs len ofs = (
    fsop_pwrite_checks ops entry bs len ofs &gt;&gt;= (<span class="kw">fun</span> _ -&gt;
    fsop_pwrite_core ops entry bs len ofs))



  <span class="co">(*--------------------------*)</span>
  <span class="co">(* pwrite_rn                *)</span>
  <span class="co">(*--------------------------*)</span>

  <span class="co">(* fsop_pwrite_rn is used by the fs level. Similarly to fsop_pread_rn it is not really part of the spec *)</span>

<span class="ot">#ifdef aspect_perms</span>
  <span class="kw">val</span> fsop_pwrite_rn_checks_perms: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; ty_bytes -&gt; nat -&gt; off_t -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_pwrite_rn_checks_perms env (rn:res_name &#39;dir_ref &#39;file_ref) bs len ofs = (fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; <span class="co">(* coverage:unused *)</span>
    (<span class="kw">match</span> rn <span class="kw">with</span> 
      | <span class="dt">RN_file</span> (_,_,i0_ref,_) -&gt; 
          fsm_cond_raise <span class="dt">EACCES</span> (not (env.env_prms.cp_has_file_write_permission s0 i0_ref)) <span class="co">(* guessing here *)</span> <span class="co">(* coverage:unused *)</span>
      | _ -&gt; fsm_do_nothing <span class="co">(* coverage:unused *)</span>
     end)))
<span class="ot">#endif</span>

  <span class="kw">val</span> fsop_pwrite_rn_checks: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; ty_bytes -&gt; nat -&gt; off_t -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_pwrite_rn_checks env (rn:res_name &#39;dir_ref &#39;file_ref) bs len ofs = (
    (fsm_cond_raise <span class="dt">EINVAL</span> (ofs &lt; <span class="dv">0</span>) <span class="co">(* invariant: offsets can never be &lt; 0 *)</span> ) <span class="co">(* coverage:unused *)</span>
      |||
    (<span class="kw">match</span> rn <span class="kw">with</span> 
      | <span class="dt">RN_error</span> (e,_) -&gt; (fsm_raise e) <span class="co">(* coverage:unused *)</span>
      | <span class="dt">RN_none</span> _ -&gt; (fsm_raise <span class="dt">ENOENT</span>) <span class="co">(* coverage:unused *)</span>
      | <span class="dt">RN_dir</span> _ -&gt; (fsm_raise <span class="dt">EISDIR</span>) <span class="co">(* directories cannot be written to, see pre_write for explanation *)</span> <span class="co">(* coverage:unused *)</span>
      | <span class="dt">RN_file</span> (_,_,i0_ref,_) -&gt;
          <span class="co">(* actually, these checks are a subset of the already performed tests, so they could be skipped.</span>
<span class="co">             However for the sake of clarity and anticipating changes in the future, let&#39;s keep them here. *)</span>
          fsop_pwrite_checks env.env_ops ((<span class="dt">File_ref_entry</span> i0_ref):entry &#39;dir_ref &#39;file_ref) bs len ofs <span class="co">(* coverage:unused *)</span>
     end)
<span class="ot">#ifdef aspect_perms</span>
    |||
      (fsop_pwrite_rn_checks_perms env rn bs len ofs)
<span class="ot">#endif</span>
  )

  <span class="kw">val</span> fsop_pwrite_rn_core: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; ty_bytes -&gt; nat -&gt; off_t -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_pwrite_rn_core env (rn:res_name &#39;dir_ref &#39;file_ref) bs len ofs = (fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt; <span class="co">(* coverage:unused *)</span>
    (<span class="kw">match</span> rn <span class="kw">with</span> 
      | <span class="dt">RN_file</span>(d0_ref,n,i0_ref,rp) -&gt; 
          fsop_pwrite_core env.env_ops ((<span class="dt">File_ref_entry</span> i0_ref):entry &#39;dir_ref &#39;file_ref) bs len ofs <span class="co">(* coverage:unused *)</span>
      | _ -&gt; fsm_special <span class="dt">Impossible</span> <span class="st">&quot;error raised before&quot;</span>  <span class="co">(* coverage:unused *)</span>
     end)))


  <span class="kw">val</span> fsop_pwrite_rn: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     ty_bytes -&gt;
     nat -&gt;
     off_t -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_pwrite_rn env (rn:res_name &#39;dir_ref &#39;file_ref) bs len ofs = ( 
    fsop_pwrite_rn_checks env rn bs len ofs &gt;&gt;= (<span class="kw">fun</span> _ -&gt; <span class="co">(* coverage:unused *)</span>
    fsop_pwrite_rn_core env rn bs len ofs) <span class="co">(* coverage:unused *)</span>)



  <span class="co">(*--------------------------*)</span>
  <span class="co">(* symlink                  *)</span>
  <span class="co">(*--------------------------*)</span>

<span class="ot">#ifdef aspect_perms</span>
  <span class="kw">val</span> fsop_symlink_checks_perms: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; ty_bytes -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_symlink_checks_perms env src dst = (fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt;
    ( <span class="kw">match</span> dst <span class="kw">with</span>
        | <span class="dt">RN_none</span>(d0_ref,_,_) -&gt; fsm_cond_raise <span class="dt">EACCES</span> (not (env.env_prms.cp_has_dir_write_permission s0 d0_ref)) <span class="co">(* posix/symlink.md EACCES:1 *)</span>
        | _ -&gt; fsm_do_nothing
      end
    )))
<span class="ot">#endif</span>

  <span class="kw">val</span> fsop_symlink_checks: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; ty_bytes -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_symlink_checks env src dst = (
    ( <span class="kw">match</span> dst <span class="kw">with</span>
        | <span class="dt">RN_error</span> (e,_) -&gt; (fsm_raise e)
        | <span class="dt">RN_dir</span> _ -&gt; (fsm_raise <span class="dt">EEXIST</span>) <span class="co">(* posix/symlink.md EEXISTS:1 *)</span>
        | <span class="dt">RN_file</span> _ -&gt; (fsm_raise <span class="dt">EEXIST</span>) <span class="co">(* posix/symlink.md EEXISTS:1 *)</span>
        | <span class="dt">RN_none</span> _ -&gt; 
          (<span class="kw">if</span> (is_linux_arch env || is_mac_os_x_arch env)  <span class="co">(* mac: symlink xyz /slink_2/ returns ENOENT; FIXME non-posix behaviour? *)</span>
              &amp;&amp; rn_ends_with_slash dst <span class="kw">then</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
              fsm_raise <span class="dt">ENOENT</span> <span class="co">(* adhoc_symlink_tests *)</span> <span class="co">(* coverage:mac_os_x:posix:irrelevant *)</span>
           <span class="kw">else</span>
              fsm_do_nothing)
      end
    ) 
<span class="ot">#ifdef aspect_perms</span>
      |||
    fsop_symlink_checks_perms env src dst
<span class="ot">#endif</span>
  )

  <span class="kw">val</span> fsop_symlink_core: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; ty_bytes -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_symlink_core env src dst = (fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt;
    ( <span class="kw">match</span> dst <span class="kw">with</span>
        | <span class="dt">RN_none</span>(d0_ref,n,_) -&gt; 
            (<span class="kw">let</span> s1 = env.env_ops.fops_symlink s0 d0_ref n src <span class="kw">in</span>
             fsm_put_state s1)
        | _ -&gt; fsm_special <span class="dt">Impossible</span> <span class="st">&quot;error raised before&quot;</span> <span class="co">(* coverage:impossible *)</span>
     end)))
  
  <span class="kw">val</span> fsop_symlink: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     ty_bytes -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_symlink env src dst = (
    fsop_symlink_checks env src dst &gt;&gt;= (<span class="kw">fun</span> _ -&gt;
    fsop_symlink_core env src dst))



  <span class="co">(*--------------------------*)</span>
  <span class="co">(* readlink                 *)</span>
  <span class="co">(*--------------------------*)</span>

  <span class="co">(* Notice, that readlink does not check for any read permission on</span>
<span class="co">     the link itself. readlinkat however does *)</span>
  <span class="kw">val</span> fsop_readlink_checks: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_readlink_checks env src = (fsm_get_state &gt;&gt;= <span class="kw">fun</span> s0 -&gt;
    (<span class="kw">match</span> src <span class="kw">with</span>
      | <span class="dt">RN_error</span> (e,_) -&gt; (fsm_raise e)
      | <span class="dt">RN_dir</span> _ -&gt; (fsm_raise <span class="dt">EINVAL</span>)
      | <span class="dt">RN_none</span> _ -&gt; (fsm_raise <span class="dt">ENOENT</span>)
      | <span class="dt">RN_file</span>(_,_,i0_ref,_) -&gt; (
          <span class="kw">let</span> ss = env.env_ops.fops_stat_file s0 i0_ref <span class="kw">in</span>
          fsm_cond_raise <span class="dt">EINVAL</span> (ss.st_kind &lt;&gt; <span class="dt">S_IFLNK</span>)
        )
     end))

  <span class="kw">val</span> fsop_readlink_core: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; res_name &#39;dir_ref &#39;file_ref -&gt; fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_readlink_core env src = (fsm_get_state &gt;&gt;= (<span class="kw">fun</span> s0 -&gt;
    (<span class="kw">match</span> src <span class="kw">with</span>
      | <span class="dt">RN_file</span>(_,_,i0_ref,_) -&gt; (
          <span class="kw">let</span> bs = env.env_ops.fops_readlink s0 i0_ref <span class="kw">in</span>
          fsm_return (<span class="dt">RV_bytes</span>(bs)))
      | _ -&gt; fsm_special <span class="dt">Impossible</span> <span class="st">&quot;error raised before&quot;</span> <span class="co">(* coverage:impossible *)</span>
    end)))


  <span class="kw">val</span> fsop_readlink: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     fsmonad &#39;impl ret_value
  <span class="kw">let</span> fsop_readlink env src = (
    fsop_readlink_checks env src &gt;&gt;= (<span class="kw">fun</span> _ -&gt;
    fsop_readlink_core env src))

end<span class="co">(* *)</span>


<span class="co">(******************************************************************************)</span>
<span class="co">(* Fs_commands                                                                *)</span>
<span class="co">(*                                                                            *)</span>
<span class="co">(* A kind of interface to Fs_operations.                                      *)</span>
<span class="co">(******************************************************************************)</span>

<span class="ot">module</span> Fs_commands = <span class="kw">struct</span>

  <span class="ot">open</span> Fs_operations

  <span class="co">(* Dummy open statements to ensure Lem produces decent HOL and Isabelle output *)</span>
  <span class="ot">open</span> Fs_types
  <span class="ot">open</span> The_monad

  <span class="kw">let</span> fs_link = fsop_link
  <span class="kw">let</span> fs_mkdir = fsop_mkdir
  <span class="kw">let</span> fs_open_close = fsop_open_close
  <span class="kw">let</span> fs_pread = fsop_pread_rn
  <span class="kw">let</span> fs_pwrite = fsop_pwrite_rn
  <span class="kw">let</span> fs_readlink = fsop_readlink
  <span class="kw">let</span> fs_rename = fsop_rename
  <span class="kw">let</span> fs_rmdir = fsop_rmdir
  <span class="kw">let</span> fs_stat = fsop_stat
  <span class="kw">let</span> fs_lstat = fsop_lstat
  <span class="kw">let</span> fs_symlink = fsop_symlink
  <span class="kw">let</span> fs_truncate = fsop_truncate
  <span class="kw">let</span> fs_unlink = fsop_unlink
  <span class="kw">let</span> fs_chown = fsop_chown
  <span class="kw">let</span> fs_chmod = fsop_chmod
      
<span class="kw">end</span>


<span class="co">(******************************************************************************)</span>
<span class="co">(* Fs transition system                                                       *)</span>
<span class="co">(******************************************************************************)</span>

<span class="ot">module</span> Fs_transition_system = <span class="kw">struct</span>

  <span class="ot">open</span> The_monad
  <span class="ot">open</span> Fs_types
  <span class="ot">open</span> Fs_commands

  <span class="kw">val</span> ty_fs_ext_command_to_fsmonad : forall &#39;dir_ref &#39;file_ref &#39;impl. 
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     ty_fs_ext_command &#39;dir_ref &#39;file_ref -&gt; 
     fsmonad &#39;impl ret_value 
  <span class="kw">let</span> ty_fs_ext_command_to_fsmonad env cmd = <span class="kw">match</span> cmd <span class="kw">with</span> 
      | <span class="dt">FS_OPEN_CLOSE</span> (p,fs,mo)   -&gt; fs_open_close env p fs mo
      | <span class="dt">FS_PREAD</span> (p,len_,ofs)     -&gt; fs_pread env p len_ ofs <span class="co">(* coverage:impossible -the OS_PREAD calls os_read, not this fs command *)</span>
      | <span class="dt">FS_PWRITE</span> (p,bs,len_,ofs) -&gt; fs_pwrite env p bs len_ ofs <span class="co">(* coverage:impossible -the OS_PWRITE calls os_write, not this fs command *)</span>
  <span class="kw">end</span>

  <span class="co">(* [ty_fs_command_to_fsmonad env cmd] returns the</span>
<span class="co">     monad operation for command [cmd] in environment [env]. *)</span>
  <span class="kw">val</span> ty_fs_command_to_fsmonad : forall &#39;dir_ref &#39;file_ref &#39;impl. 
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     ty_fs_command &#39;dir_ref &#39;file_ref -&gt; 
     fsmonad &#39;impl ret_value 
  <span class="kw">let</span> ty_fs_command_to_fsmonad env cmd = <span class="kw">match</span> cmd <span class="kw">with</span> 
      | <span class="dt">FS_LINK</span> (s,d) -&gt; (fs_link env s d)
      | <span class="dt">FS_MKDIR</span> (s,p) -&gt; (fs_mkdir env s p)
      | <span class="dt">FS_READLINK</span> p -&gt; (fs_readlink env p)
      | <span class="dt">FS_RENAME</span> (s,d) -&gt; (fs_rename env s d)
      | <span class="dt">FS_RMDIR</span> p -&gt; (fs_rmdir env p)
      | <span class="dt">FS_STAT</span> p -&gt; (fs_stat env.env_ops p)
      | <span class="dt">FS_LSTAT</span> p -&gt; (fs_lstat env.env_ops p)
      | <span class="dt">FS_SYMLINK</span> (s,d) -&gt; (fs_symlink env s d)
      | <span class="dt">FS_TRUNCATE</span> (p,l) -&gt; (fs_truncate env p l)
      | <span class="dt">FS_UNLINK</span> p -&gt; (fs_unlink env p)
      | <span class="dt">FS_CHMOD</span> (s, p) -&gt; (fs_chmod env s p)
      | <span class="dt">FS_CHOWN</span> (s, u, g) -&gt; (fs_chown env s u g) 
      | <span class="dt">FS_EXTENDED_CMD</span> cmd&#39; -&gt; ty_fs_ext_command_to_fsmonad env cmd&#39;
  end

  <span class="kw">val</span> fs_trans: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     &#39;impl -&gt; 
     ty_fs_command &#39;dir_ref &#39;file_ref -&gt; 
     finset (monad_state &#39;impl ret_value)
  <span class="kw">let</span> fs_trans env s0 cmd = (
    <span class="kw">let</span> m = ty_fs_command_to_fsmonad env cmd <span class="kw">in</span>
    <span class="kw">let</span> rs = run_fsmonad m s0 <span class="kw">in</span>
    rs)
end


<span class="co">(******************************************************************************)</span>
<span class="co">(* Os_operations                                                              *)</span>
<span class="co">(*                                                                            *)</span>
<span class="co">(* This module defines operations at the OS level. These include open,        *)</span>
<span class="co">(* close, read and write, which interact with the OS via file descriptors.    *)</span>
<span class="co">(******************************************************************************)</span>

<span class="ot">module</span> Os_operations = <span class="kw">struct</span>

  <span class="ot">open</span> The_monad
  <span class="ot">open</span> Fs_types
  <span class="ot">open</span> Fs_arch
  <span class="ot">open</span> Fs_operations
<span class="ot">#ifdef aspect_perms</span>
  <span class="ot">open</span> Fs_permissions
<span class="ot">#endif</span>

  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* auxiliary functions           *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* In the following we frequently need to lookup</span>
<span class="co">     the state of a process. This can fail, if the process</span>
<span class="co">     does not exist. Preceding checks guarantee that this </span>
<span class="co">     won&#39;t happen. To simplify the code, we don&#39;t code a</span>
<span class="co">     code distinction all the time, but use this auxiliary</span>
<span class="co">     function that fails hard if something goes wrong. *)</span>
  <span class="kw">val</span> lookup_per_process_state : forall &#39;dir_ref &#39;file_ref &#39;impl.
    ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
    ty_pid -&gt;
    per_process_state &#39;dir_ref
  <span class="kw">let</span> lookup_per_process_state s0 pid =
    <span class="kw">let</span> pps_opt = fmap_lookup s0.oss_pid_table pid <span class="kw">in</span>
    (<span class="kw">match</span> pps_opt <span class="kw">with</span>
     | <span class="dt">Nothing</span> -&gt; failwith <span class="st">&quot;lookup_per_process_state failed&quot;</span> <span class="co">(* coverage:irrelevant *)</span>
     | <span class="dt">Just</span> pps -&gt; pps
    <span class="kw">end</span>)


  <span class="co">(* [lookup_fid_of_fd s0 pid fd] is a convenience function</span>
<span class="co">     that looks up the [fid] and its state for file-descriptor [fd] of</span>
<span class="co">     process [pid] in state [s0]. If no such file-descriptor exists,</span>
<span class="co">     [Nothing] is returned. *)</span>
  <span class="kw">val</span> lookup_fid_of_fd : forall &#39;dir_ref &#39;file_ref &#39;impl.
    ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
    ty_pid -&gt;
    ty_fd -&gt;
    Maybe<span class="kw">.</span>maybe (ty_fid * (fid_state &#39;dir_ref &#39;file_ref))
  <span class="kw">let</span> lookup_fid_of_fd s0 pid fd =
    <span class="kw">let</span> pps = lookup_per_process_state s0 pid <span class="kw">in</span>
    <span class="kw">let</span> fd_st = fmap_lookup pps.pps_fd_table fd <span class="kw">in</span>
    (<span class="kw">match</span> fd_st <span class="kw">with</span> 
     | <span class="dt">Nothing</span> -&gt; <span class="dt">Nothing</span>
     | <span class="dt">Just</span> fd_st -&gt; (
       <span class="co">(* get fid *)</span>
       <span class="kw">let</span> fid = fd_st.fds_fid <span class="kw">in</span>
       <span class="kw">let</span> fid_st = fmap_lookup s0.oss_fid_table fid <span class="kw">in</span>
       (<span class="kw">match</span> fid_st <span class="kw">with</span>
        | <span class="dt">Nothing</span> -&gt; (failwith <span class="st">&quot;impossible: 1601 fds point to fids that are in the oss_fid_table&quot;</span>) <span class="co">(* coverage:impossible *)</span>
        | <span class="dt">Just</span> fid_st -&gt; <span class="dt">Just</span> (fid, fid_st)
       end))
     end)

  <span class="co">(* [get_run_state s0 pid rs] gets the run state of process [pid] in state [s0]. *)</span>
  <span class="kw">val</span> get_run_state : forall &#39;dir_ref &#39;file_ref &#39;impl.
    ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
    ty_pid -&gt;
    ty_pps_pid_run_state
  <span class="kw">let</span> get_run_state s0 pid = (
    <span class="kw">let</span> ppstate = lookup_per_process_state s0 pid <span class="kw">in</span>
    <span class="kw">let</span> rs = ppstate.pps_pid_run_state <span class="kw">in</span>
    rs
  )

  <span class="co">(* [update_run_state s0 pid rs] updates the</span>
<span class="co">     return state of process [pid] in state [s0] to [rs]. *)</span>
  <span class="kw">val</span> update_run_state : forall &#39;dir_ref &#39;file_ref &#39;impl.
    ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
    ty_pid -&gt;
    ty_pps_pid_run_state -&gt;
    ty_os_state &#39;dir_ref &#39;file_ref &#39;impl
  <span class="kw">let</span> update_run_state s0 pid rs = (
    <span class="kw">let</span> ppstate = lookup_per_process_state s0 pid <span class="kw">in</span>
    <span class="kw">let</span> ppstate&#39; = &lt;| ppstate <span class="kw">with</span> pps_pid_run_state = rs |&gt; <span class="kw">in</span>
    &lt;| s0 <span class="kw">with</span> oss_pid_table=(fmap_update s0.oss_pid_table (pid,ppstate&#39;)) |&gt;
  )

  <span class="co">(* [update_pending_return s0 pid ev] updates the</span>
<span class="co">     return state of process [pid] in state [s0] to [PENDING_RETURN(ev)]. *)</span>
  <span class="kw">val</span> update_pending_return : forall &#39;dir_ref &#39;file_ref &#39;impl.
    ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
    ty_pid -&gt;
    error_or_value ret_value -&gt;
    ty_os_state &#39;dir_ref &#39;file_ref &#39;impl
  <span class="kw">let</span> update_pending_return s0 pid ev = 
    update_run_state s0 pid (<span class="dt">PENDING_RETURN</span> ev)


  <span class="co">(* [update_pending_return_and_fs_state s0 pid ev fs_state] updates the</span>
<span class="co">     return state of process [pid] in state [s0] to [PENDING_RETURN(ev)]</span>
<span class="co">     and the file-system state to [fs_state]. *)</span>
  <span class="kw">val</span> update_pending_return_and_fs_state : forall &#39;dir_ref &#39;file_ref &#39;impl.
    ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
    ty_pid -&gt;
    error_or_value ret_value -&gt;
    &#39;impl -&gt;
    ty_os_state &#39;dir_ref &#39;file_ref &#39;impl
  <span class="kw">let</span> update_pending_return_and_fs_state s0 pid ev fs_state = (
    <span class="kw">let</span> ppstate = lookup_per_process_state s0 pid <span class="kw">in</span>
    <span class="kw">let</span> ppstate&#39; = &lt;| ppstate <span class="kw">with</span> pps_pid_run_state = <span class="dt">PENDING_RETURN</span>(ev) |&gt; <span class="kw">in</span>
    &lt;| s0 <span class="kw">with</span> oss_fs_state=fs_state; oss_pid_table=(fmap_update s0.oss_pid_table (pid,ppstate&#39;)) |&gt;
  )


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* create_fd                     *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* [smallest_free_nat p current max] finds the smallest number </span>
<span class="co">     between [current] (including) and [max] (excluding) that satisfied</span>
<span class="co">     [p]. If no such number exists [max] is returned. *)</span>
  <span class="kw">val</span> smallest_free_nat : (nat -&gt; <span class="dt">bool</span>) -&gt; nat -&gt; nat -&gt; nat
  <span class="kw">let</span> <span class="kw">rec</span> smallest_free_nat p current_num max_num = 
    <span class="kw">if</span> (p current_num || (current_num &gt;= max_num)) <span class="kw">then</span> current_num <span class="kw">else</span> (
      smallest_free_nat p (succ current_num) max_num
    )
    

  <span class="co">(* [get_smallest_free_fd pid s0] computes the file-descriptor</span>
<span class="co">     to use is state [s0] for process [pid]. Posix specifies,</span>
<span class="co">     that always the smallest free one is used. *)</span>
  <span class="kw">val</span> get_smallest_free_fd : forall &#39;dir_ref &#39;file_ref &#39;impl.
    ty_pid -&gt; 
    ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
    ty_fd
  <span class="kw">let</span> get_smallest_free_fd pid s0 = ( 
    <span class="kw">let</span> pps = lookup_per_process_state s0 pid <span class="kw">in</span>
    <span class="kw">let</span> fdt = pps.pps_fd_table <span class="kw">in</span>
    <span class="kw">let</span> free_check n = not (fmap_in_dom (<span class="dt">FD</span> n) fdt) <span class="kw">in</span>
    <span class="kw">let</span> new_fd = <span class="dt">FD</span> (smallest_free_nat free_check <span class="dv">0</span> (fmap_size fdt)) <span class="kw">in</span>
    new_fd
  )

  <span class="co">(* [get_free_fid s0] returns a [fid] that is free in state [s0].</span>
<span class="co">     In contrast to fds, we don&#39;t care, which free one is returned.</span>
<span class="co">     So the implementation can be much simpler (max + 1). *)</span>
  <span class="kw">val</span> get_free_fid : forall &#39;dir_ref &#39;file_ref &#39;impl.
    ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt;
    ty_fid
  <span class="kw">let</span> get_free_fid s0 =
    <span class="dt">FID</span> (fmap_fold (
             <span class="kw">fun</span> (<span class="dt">FID</span> k) _ m -&gt;
             <span class="kw">if</span> k &gt;= m 
             <span class="kw">then</span> succ k
             <span class="kw">else</span> m <span class="co">(* coverage:impossible *)</span>
           ) s0.oss_fid_table <span class="dv">0</span>)


  <span class="co">(* [create_fd ops pid entry oflags s0] creates a new file </span>
<span class="co">     descriptor for entry [entry] *)</span>
  <span class="kw">val</span> create_fd : forall &#39;dir_ref &#39;file_ref &#39;impl.
    fs_ops &#39;dir_ref &#39;file_ref &#39;impl -&gt;
    ty_pid -&gt; 
    entry &#39;dir_ref &#39;file_ref -&gt; 
    finset open_flag -&gt; 
    ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
    ty_os_state &#39;dir_ref &#39;file_ref &#39;impl * ty_fd * ty_fid
  <span class="kw">let</span> create_fd ops pid entry oflags s0 = (
    <span class="co">(* get free fd and fid *)</span>
    <span class="kw">let</span> new_fd = get_smallest_free_fd pid s0 <span class="kw">in</span>
    <span class="kw">let</span> new_fid = get_free_fid s0 <span class="kw">in</span>

    <span class="co">(* get initial states for them *)</span>
    <span class="kw">let</span> fd_state = &lt;| fds_fid=new_fid; fds_FD_CLOEXEC=(finset_mem <span class="dt">O_CLOEXEC</span> oflags) |&gt; <span class="kw">in</span>
    <span class="kw">let</span> fid_state = &lt;| fids_offset=<span class="dv">0</span>; fids_entry=entry; fids_oflags=oflags; fids_open_or_closed=<span class="dt">FID_OPEN</span> |&gt; <span class="kw">in</span>

    <span class="co">(* store it *)</span>
    <span class="kw">let</span> pps = lookup_per_process_state s0 pid <span class="kw">in</span>
    <span class="kw">let</span> pps = &lt;| pps <span class="kw">with</span> pps_fd_table=(fmap_update pps.pps_fd_table (new_fd,fd_state)) |&gt; <span class="kw">in</span>
    <span class="kw">let</span> s0 = &lt;| s0 <span class="kw">with</span> oss_pid_table=(fmap_update s0.oss_pid_table (pid,pps)) |&gt; <span class="kw">in</span>
    <span class="kw">let</span> s0 = &lt;| s0 <span class="kw">with</span> oss_fid_table=(fmap_update s0.oss_fid_table (new_fid,fid_state)) |&gt; <span class="kw">in</span>
    (s0,new_fd,new_fid))


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* create_dh                     *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* [get_smallest_free_dh s0] gets a free dir-handle</span>
<span class="co">     is state [s0]. Posix does not specify, what dir-handles are</span>
<span class="co">     or which ones are used. For Posix, it is a pointer to a dir-structure.</span>
<span class="co">     However, for our model, we want some predictability, since we</span>
<span class="co">     want use dir-handles in our testing-traces. Therefore, we</span>
<span class="co">     always return the smallest free one. *)</span>
  <span class="kw">val</span> get_smallest_free_dh : forall &#39;dir_ref &#39;file_ref &#39;impl.
    ty_pid -&gt; 
    ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
    ty_dh
  <span class="kw">let</span> get_smallest_free_dh pid s0 = ( 
    <span class="kw">let</span> pps = lookup_per_process_state s0 pid <span class="kw">in</span>
    <span class="kw">let</span> dht = pps.pps_dh_table <span class="kw">in</span>
    <span class="kw">let</span> free_check n = not (fmap_in_dom (<span class="dt">DH</span> n) dht) <span class="kw">in</span>
    <span class="kw">let</span> new_dh = <span class="dt">DH</span> (smallest_free_nat free_check <span class="dv">1</span> (fmap_size dht + <span class="dv">1</span>)) <span class="kw">in</span>
    new_dh
  )


  <span class="co">(** [rewind_dh ops dhs fs0] rewinds directory handle state [dhs] in fs-state [fs0]. </span>
<span class="co">      It returns the updated dir-handle and fs-states. *)</span>
  <span class="kw">val</span> rewind_dhs : forall &#39;dir_ref &#39;file_ref &#39;impl.
    fs_ops &#39;dir_ref &#39;file_ref &#39;impl -&gt;
    dh_state &#39;dir_ref -&gt;
    &#39;impl -&gt; 
    (dh_state &#39;dir_ref * &#39;impl)
  <span class="kw">let</span> rewind_dhs ops dhs fs_st = (
    <span class="co">(* reset the observer *)</span>
    <span class="kw">let</span> (fs_st&#39;, _) = ops.fops_observe_dir fs_st dhs.dhs_observe_handle <span class="kw">in</span>

    <span class="co">(* reset the dh_state *)</span>
    <span class="kw">let</span> (fs_st&#39;&#39;, current_entries) = ops.fops_readdir fs_st&#39; dhs.dhs_dir_ref <span class="kw">in</span>
    <span class="kw">let</span> dhs&#39; = &lt;| dhs <span class="kw">with</span> dhs_must_report = <span class="st">&quot;.&quot;</span>::<span class="st">&quot;..&quot;</span>::current_entries; dhs_may_report = [] |&gt; <span class="kw">in</span>
    (dhs&#39;,fs_st&#39;&#39;)
  )

  <span class="co">(* [create_dh ops pid d0_ref s0] creates a new directory</span>
<span class="co">     handle for directory d0_ref *)</span>
  <span class="kw">val</span> create_dh : forall &#39;dir_ref &#39;file_ref &#39;impl.
    fs_ops &#39;dir_ref &#39;file_ref &#39;impl -&gt;
    ty_pid -&gt; 
    &#39;dir_ref -&gt;
    ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
    ty_os_state &#39;dir_ref &#39;file_ref &#39;impl * ty_dh
  <span class="kw">let</span> create_dh ops pid d0_ref s0 = (
    <span class="co">(* get free dh *)</span>
    <span class="kw">let</span> new_dh = get_smallest_free_dh pid s0 <span class="kw">in</span>

    <span class="co">(* start observing the directory *)</span>
    <span class="kw">let</span> (fs_st&#39;, oh) = ops.fops_observe_dir_register s0.oss_fs_state d0_ref <span class="kw">in</span>

    <span class="co">(* get initial states for them *)</span>
    <span class="kw">let</span> (dh_st, fs_st&#39;&#39;) = rewind_dhs ops 
        (&lt;| dhs_dir_ref = d0_ref; dhs_observe_handle = oh;
            dhs_must_report = []; dhs_may_report = [] |&gt;) fs_st&#39; <span class="kw">in</span>
    
    <span class="co">(* store it *)</span>
    <span class="kw">let</span> pps = lookup_per_process_state s0 pid <span class="kw">in</span>
    <span class="kw">let</span> pps = &lt;| pps <span class="kw">with</span> pps_dh_table=(fmap_update pps.pps_dh_table (new_dh,dh_st)) |&gt; <span class="kw">in</span>
    <span class="kw">let</span> s0 = &lt;| s0 <span class="kw">with</span> oss_pid_table=(fmap_update s0.oss_pid_table (pid,pps)); oss_fs_state = fs_st&#39; |&gt; <span class="kw">in</span>
    (s0,new_dh))


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* os_close                      *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* [os_close env pid fd s0] closed file-descriptor [fd] or process [pid] in state [s0]. *)</span>  

  <span class="co">(* FIXME os_close is a complete hack currently - just to get open tests to go through *)</span>
  <span class="kw">val</span> os_close: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     ty_pid -&gt; 
     ty_fd -&gt;
     ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     finset (os_state_or_special &#39;dir_ref &#39;file_ref &#39;impl)
  <span class="kw">let</span> os_close env pid fd s0 = (
    <span class="kw">let</span> ppstate = lookup_per_process_state s0 pid <span class="kw">in</span>
    <span class="co">(* check that fd is valid *)</span>
    <span class="kw">match</span> fmap_lookup ppstate.pps_fd_table fd <span class="kw">with</span> 
    | <span class="dt">Nothing</span> -&gt; (
      <span class="kw">let</span> ppstate = &lt;| ppstate <span class="kw">with</span> pps_pid_run_state=<span class="dt">PENDING_RETURN</span>(<span class="dt">Error</span> <span class="dt">EBADF</span>) |&gt; <span class="kw">in</span> 
      <span class="kw">let</span> s0 = &lt;| s0 <span class="kw">with</span> oss_pid_table=(fmap_update s0.oss_pid_table (pid,ppstate)) |&gt; <span class="kw">in</span>
      finset_singleton (<span class="dt">OS_normal</span> s0)) <span class="co">(* we assume ppstate has not been altered before being passed in *)</span>
    | <span class="dt">Just</span> fds -&gt; ( 
      <span class="kw">let</span> ppstate = &lt;| ppstate <span class="kw">with</span> pps_pid_run_state=<span class="dt">PENDING_RETURN</span>(<span class="dt">Value</span> <span class="dt">RV_none</span>) |&gt; <span class="kw">in</span> 
      <span class="kw">let</span> new_fdt = fmap_remove (ppstate.pps_fd_table) fd <span class="kw">in</span>
      <span class="kw">let</span> ppstate = &lt;| ppstate <span class="kw">with</span> pps_fd_table=new_fdt |&gt; <span class="kw">in</span>
      <span class="kw">let</span> s0 = &lt;| s0 <span class="kw">with</span> oss_pid_table=(fmap_update s0.oss_pid_table (pid,ppstate)) |&gt; <span class="kw">in</span>
      finset_singleton (<span class="dt">OS_normal</span> s0)) end)


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* os_open                       *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">val</span> os_open: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     ty_pid -&gt; 
     res_name &#39;dir_ref &#39;file_ref -&gt; 
     int_open_flags -&gt;
     maybe file_perm -&gt;
     ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     finset (os_state_or_special &#39;dir_ref &#39;file_ref &#39;impl)
  <span class="kw">let</span> os_open env pid rpath oflag mode_opt s0 = (
    <span class="co">(* run fs-level open *)</span>
    <span class="kw">let</span> rs = <span class="kw">begin</span>
      <span class="kw">let</span> fs0 = s0.oss_fs_state <span class="kw">in</span>
      <span class="kw">let</span> f0 = fsop_open env rpath oflag mode_opt <span class="kw">in</span>
      run_fsmonad f0 fs0
    <span class="kw">end</span> <span class="kw">in</span>

    <span class="co">(* For each resulting monad_state, we need to construct</span>
<span class="co">       an os-state *)</span>
    <span class="kw">let</span> process_fs_result st = (<span class="kw">match</span> st <span class="kw">with</span>
      | <span class="dt">Special_state</span>(ss,msg) -&gt; <span class="co">(* just forward special results *)</span> (<span class="dt">OS_special</span>(ss,msg)) <span class="co">(* coverage:linux:irrelevant *)</span>
      | <span class="dt">Error_state</span> (fs_st, e) -&gt; 
          <span class="co">(* if an error occured, just forward the error and fs_state (which should not have been changed, though) *)</span>
          <span class="dt">OS_normal</span> (update_pending_return_and_fs_state s0 pid (<span class="dt">Error</span> e) fs_st)
      | <span class="dt">Normal_state</span> (fs_st, (entry,oflags)) -&gt; (<span class="kw">begin</span>
          <span class="co">(* for a normal result, create a corresponding fd and return it *)</span>

          <span class="co">(* put fs_state in things into the os_state *)</span>
          <span class="kw">let</span> s0 = &lt;| s0 <span class="kw">with</span> oss_fs_state=fs_st |&gt; <span class="kw">in</span>

          <span class="co">(* create fd, open fid, handle O_CLOEXEC *)</span>
          <span class="kw">let</span> (s0,fd,fid) = create_fd env.env_ops pid entry oflags s0 <span class="kw">in</span>

          <span class="co">(* return value - an int corresponding to the fd *)</span>
          <span class="kw">let</span> ppstate = lookup_per_process_state s0 pid <span class="kw">in</span>
          <span class="kw">let</span> ev = <span class="dt">Value</span> (<span class="dt">RV_num</span> (dest_FD fd)) <span class="kw">in</span>
          <span class="kw">let</span> ppstate&#39; = &lt;| ppstate <span class="kw">with</span> pps_pid_run_state = <span class="dt">PENDING_RETURN</span>(ev) |&gt; <span class="kw">in</span>
          <span class="kw">let</span> s0 = &lt;| s0 <span class="kw">with</span> oss_pid_table=(fmap_update s0.oss_pid_table (pid,ppstate&#39;)) |&gt; <span class="kw">in</span>
          (<span class="dt">OS_normal</span> s0)
        <span class="kw">end</span>)
    end) <span class="kw">in</span>

    finset_image process_fs_result rs)


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* os_read                       *)</span>
  <span class="co">(*-------------------------------*)</span>

      <span class="co">(* todo: - indicates that the flag is not applicable</span>

<span class="co">      ACCMODE</span>
<span class="co">      X O_APPEND</span>
<span class="co">      X O_CLOEXEC</span>
<span class="co">      X O_CREAT</span>
<span class="co">      -O_DSYNC</span>
<span class="co">      -O_NOCTTY</span>
<span class="co">      -O_NONBLOCK &quot;the O_NONBLOCK flag shall not cause an error, but it is unspecified whether the file status flags will include the O_NONBLOCK flag&quot;</span>
<span class="co">      -O_RSYNC</span>
<span class="co">      -O_SYNC</span>
<span class="co">      X O_TRUNC</span>
<span class="co">      -O_TTY_INIT *)</span>

  <span class="kw">val</span> os_read: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     ty_pid -&gt; 
     ty_fd -&gt; 
     size_t -&gt;
     maybe off_t -&gt;
     ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     finset (os_state_or_special &#39;dir_ref &#39;file_ref &#39;impl)
  <span class="kw">let</span> os_read env pid fd sz ofsopt s0 = 
    <span class="co">(* lookup the fd and fid we want to read from *)</span>
    (<span class="kw">match</span> lookup_fid_of_fd s0 pid fd <span class="kw">with</span> 
     | <span class="dt">Nothing</span> -&gt; <span class="co">(* if it does not exist, raise EBADF *)</span> 
         finset_singleton (<span class="dt">OS_normal</span> (update_pending_return s0 pid (<span class="dt">Error</span> <span class="dt">EBADF</span>)))  <span class="co">(* posix/read.md EBADF:1 *)</span>
     | <span class="dt">Just</span> (fid, fid_st) -&gt; (
        <span class="co">(* check that fid is open for reading *)</span>
        <span class="kw">let</span> oflags = fid_st.fids_oflags <span class="kw">in</span>
        <span class="kw">if</span> not (finset_mem <span class="dt">O_RDONLY</span> oflags || finset_mem <span class="dt">O_RDWR</span> oflags) <span class="kw">then</span>
          finset_singleton (<span class="dt">OS_normal</span> (update_pending_return s0 pid (<span class="dt">Error</span> <span class="dt">EBADF</span>)))  <span class="co">(* posix/read.md EBADF:1 *)</span>
        <span class="kw">else</span> (<span class="kw">begin</span>
          <span class="co">(* we have a fd, which we are allowed to read from, so </span>
<span class="co">             execute the fs-read operation *)</span>
          <span class="kw">let</span> rs = (<span class="kw">begin</span>
            <span class="kw">let</span> ofs = (<span class="kw">match</span> ofsopt <span class="kw">with</span> | <span class="dt">Nothing</span> -&gt; intFromNat fid_st.fids_offset | <span class="dt">Just</span> ofs -&gt; ofs <span class="kw">end</span>) <span class="kw">in</span>
            <span class="kw">let</span> read_op = fsop_pread env fid_st.fids_entry (sz:nat) ofs <span class="kw">in</span>
            run_fsmonad read_op s0.oss_fs_state 
          <span class="kw">end</span>) <span class="kw">in</span>

          <span class="co">(* For each resulting monad_state, we need to construct</span>
<span class="co">             an os-state *)</span>
          <span class="kw">let</span> process_fs_result st = (<span class="kw">match</span> st <span class="kw">with</span>
           | <span class="dt">Special_state</span>(ss,msg) -&gt; <span class="co">(* just forward special results *)</span> (<span class="dt">OS_special</span>(ss,msg)) <span class="co">(* coverage:impossible -this cannot be reached since we do not have architectures with the field arch_allows_dir set to true (only with this set to true we could have a special state returned by pread and forwarded by os_read) *)</span>
           | <span class="dt">Error_state</span> (fs_st, e) -&gt; <span class="co">(* just forward errors,  *)</span>
                <span class="dt">OS_normal</span> (update_pending_return_and_fs_state s0 pid (<span class="dt">Error</span> e) fs_st)
           | <span class="dt">Normal_state</span>(fs_st, <span class="dt">RV_bytes</span> bs) -&gt; <span class="co">(* a successful read *)</span> (<span class="kw">begin</span>
               <span class="co">(* forward results *)</span>
               <span class="kw">let</span> s0 = update_pending_return_and_fs_state s0 pid (<span class="dt">Value</span> (<span class="dt">RV_bytes</span> bs)) fs_st <span class="kw">in</span>

               <span class="co">(* update fids_offset with bytes read, but only if we model read, i.e. no offset was given *)</span>
               <span class="kw">let</span> fid_st = (<span class="kw">match</span> ofsopt <span class="kw">with</span> | <span class="dt">Just</span> _ -&gt; fid_st | <span class="dt">Nothing</span> -&gt;
                  &lt;| fid_st <span class="kw">with</span> fids_offset=(fid_st.fids_offset+(T_list_array<span class="kw">.</span>dim bs)) |&gt; <span class="kw">end</span>) <span class="kw">in</span>
               <span class="kw">let</span> s0 = &lt;| s0 <span class="kw">with</span> oss_fid_table=(fmap_update s0.oss_fid_table (fid,fid_st)) |&gt; <span class="kw">in</span>
               <span class="dt">OS_normal</span> s0
             end)
           | <span class="dt">Normal_state</span>(fs_st, _) -&gt; (failwith <span class="st">&quot;os_read: impossible, value from fsop_read is RV_bytes&quot;</span>) <span class="co">(* coverage:impossible *)</span>
          end) <span class="kw">in</span>

          finset_image process_fs_result rs
        end))
      end)


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* os_write                      *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">val</span> os_write: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     ty_pid -&gt; 
     ty_fd -&gt; 
     ty_bytes -&gt;
     size_t -&gt;
     maybe off_t -&gt; 
     ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     finset (os_state_or_special &#39;dir_ref &#39;file_ref &#39;impl)
  <span class="kw">let</span> os_write env pid fd bs sz ofsopt s0 = 
    <span class="co">(* lookup the fd and fid we want to write to *)</span>
    (<span class="kw">match</span> lookup_fid_of_fd s0 pid fd <span class="kw">with</span> 
     | <span class="dt">Nothing</span> -&gt; <span class="co">(* if it does not exist, raise EBADF *)</span> 
         finset_singleton (<span class="dt">OS_normal</span> (update_pending_return s0 pid (<span class="dt">Error</span> <span class="dt">EBADF</span>)))  <span class="co">(* posix/write.md EBADF:1 *)</span>
     | <span class="dt">Just</span> (fid, fid_st) -&gt; (
        <span class="co">(* check that fid is open for writing *)</span>
        <span class="kw">let</span> oflags = fid_st.fids_oflags <span class="kw">in</span>
        <span class="kw">if</span> not (finset_mem <span class="dt">O_WRONLY</span> oflags || finset_mem <span class="dt">O_RDWR</span> oflags) <span class="kw">then</span>
          finset_singleton (<span class="dt">OS_normal</span> (update_pending_return s0 pid (<span class="dt">Error</span> <span class="dt">EBADF</span>)))  <span class="co">(* posix/write.md EBADF:1 *)</span>
        <span class="kw">else</span> <span class="co">(* handle pwrite with append and negative offset *)</span>
             <span class="kw">if</span> (finset_mem <span class="dt">O_APPEND</span> oflags &amp;&amp; (<span class="kw">match</span> ofsopt <span class="kw">with</span> | <span class="dt">Just</span> ofs -&gt; ofs &lt; <span class="dv">0</span> | <span class="dt">Nothing</span> -&gt; <span class="kw">false</span> end)) <span class="kw">then</span>
          finset_singleton (<span class="dt">OS_normal</span> (update_pending_return s0 pid (<span class="dt">Error</span> <span class="dt">EINVAL</span>)))
        <span class="kw">else</span> (
          <span class="co">(* compute offset *)</span>
          <span class="kw">let</span> ofs = (<span class="co">(* handle O_APPEND *)</span>
            <span class="kw">if</span> not (finset_mem <span class="dt">O_APPEND</span> oflags) <span class="kw">then</span> 
              (<span class="kw">match</span> ofsopt <span class="kw">with</span> | <span class="dt">Just</span> ofs -&gt; ofs | <span class="dt">Nothing</span> -&gt; intFromNat fid_st.fids_offset end)
            <span class="kw">else</span> <span class="co">(* jump to very end of file *)</span> 
              (<span class="kw">match</span> fid_st.fids_entry <span class="kw">with</span> 
                | <span class="dt">Dir_ref_entry</span> _ -&gt; intFromNat fid_st.fids_offset  <span class="co">(* will fail anyhow, so value unimportant *)</span> <span class="co">(* coverage:impossible - this spec does not support opening directories with a write flag, so this case is never reached *)</span>
                | <span class="dt">File_ref_entry</span> i0_ref -&gt; (intFromNat (file_get_size env.env_ops s0.oss_fs_state i0_ref))
               end))
          <span class="kw">in</span>

          <span class="co">(* execute fs-level operation *)</span>
          <span class="kw">let</span> rs = (
            <span class="kw">let</span> write_op = fsop_pwrite env.env_ops fid_st.fids_entry bs sz ofs <span class="kw">in</span>
            run_fsmonad write_op s0.oss_fs_state 
          ) <span class="kw">in</span>

          <span class="co">(* For each resulting monad_state, we need to construct</span>
<span class="co">             an os-state *)</span>
          <span class="kw">let</span> process_fs_result st = (<span class="kw">match</span> st <span class="kw">with</span>
           | <span class="dt">Special_state</span>(ss,msg) -&gt; <span class="co">(* just forward special results *)</span> (<span class="dt">OS_special</span>(ss,msg)) <span class="co">(* coverage:impossible - it is impossible to return a special state from fsop_pwrite *)</span>
           | <span class="dt">Error_state</span> (fs_st, e) -&gt; <span class="co">(* just forward errors *)</span>
                <span class="dt">OS_normal</span> (update_pending_return_and_fs_state s0 pid (<span class="dt">Error</span> e) fs_st)
           | <span class="dt">Normal_state</span>(fs_st, <span class="dt">RV_num</span> len_written) -&gt; <span class="co">(* a successful write *)</span> (<span class="kw">begin</span>
               <span class="co">(* forward results *)</span>
               <span class="kw">let</span> s0 = update_pending_return_and_fs_state s0 pid (<span class="dt">Value</span> (<span class="dt">RV_num</span> len_written)) fs_st <span class="kw">in</span>

               <span class="co">(* update fids_offset with bytes written, but only if we model write, i.e. no offset was given *)</span>
               <span class="kw">let</span> fid_st = (<span class="kw">match</span> ofsopt <span class="kw">with</span> | <span class="dt">Just</span> _ -&gt; fid_st | <span class="dt">Nothing</span> -&gt;
                 &lt;| fid_st <span class="kw">with</span> fids_offset=((natFromInt ofs)+len_written) |&gt; <span class="kw">end</span>) <span class="kw">in</span>
               <span class="kw">let</span> s0 = &lt;| s0 <span class="kw">with</span> oss_fid_table=(fmap_update s0.oss_fid_table (fid,fid_st)) |&gt; <span class="kw">in</span>
               <span class="dt">OS_normal</span> s0
             end)
           | <span class="dt">Normal_state</span>(fs_st, _) -&gt; (failwith <span class="st">&quot;os_write: impossible, value from fsop_write is RV_num&quot;</span>) <span class="co">(* coverage:impossible *)</span>
          end) <span class="kw">in</span>

          finset_image process_fs_result rs
        ))
      end)


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* os_lseek                      *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">val</span> os_lseek : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     ty_pid -&gt; 
     ty_fd -&gt; 
     off_t -&gt;
     int_seek_command -&gt;
     ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     finset (os_state_or_special &#39;dir_ref &#39;file_ref &#39;impl)
  <span class="kw">let</span> os_lseek env pid fd (ofs:off_t) (int_command : int_seek_command) s0 = (
    <span class="co">(* check fid *)</span>
    <span class="kw">let</span> fid_eov = (
      <span class="co">(* check that fd is a valid fd *)</span>
      <span class="kw">match</span> (lookup_fid_of_fd s0 pid fd) <span class="kw">with</span> 
        | <span class="dt">Nothing</span> -&gt; <span class="dt">Error</span> <span class="dt">EBADF</span>  <span class="co">(* posix/lseek.md EBADF:1 *)</span>
        | <span class="dt">Just</span> (fid, fid_st) -&gt; <span class="dt">Value</span> (fid, fid_st)
      end
    ) <span class="kw">in</span>

    <span class="co">(* check int_command *)</span>
    <span class="kw">let</span> seek_c_eov = (<span class="kw">begin</span>
      <span class="kw">let</span> arch = architecture_of_ty_arch env.env_arch <span class="kw">in</span>
      (<span class="kw">match</span> arch.arch_seek_command_of_int int_command <span class="kw">with</span>
        | <span class="dt">Nothing</span> -&gt; <span class="dt">Error</span> <span class="dt">EINVAL</span>  <span class="co">(* posix/lseek.md EINVAL:1 *)</span>
        | <span class="dt">Just</span> seek_c -&gt; <span class="dt">Value</span> seek_c
       <span class="kw">end</span>)
    end) <span class="kw">in</span>

    <span class="co">(* raise errors of fd and int_command *)</span>
    (<span class="kw">match</span> (fid_eov, seek_c_eov) <span class="kw">with</span>
      | (<span class="dt">Error</span> e1, <span class="dt">Error</span> e2) -&gt;
           finset_from_list [<span class="dt">OS_normal</span> (update_pending_return s0 pid (<span class="dt">Error</span> e1)); 
                             <span class="dt">OS_normal</span> (update_pending_return s0 pid (<span class="dt">Error</span> e2))]
      | (<span class="dt">Error</span> e1, <span class="dt">Value</span> _) -&gt;
           finset_singleton (<span class="dt">OS_normal</span> (update_pending_return s0 pid (<span class="dt">Error</span> e1)))
      | (<span class="dt">Value</span> _, <span class="dt">Error</span> e2) -&gt;
           finset_singleton (<span class="dt">OS_normal</span> (update_pending_return s0 pid (<span class="dt">Error</span> e2)))
      | (<span class="dt">Value</span> (fid, fid_st), <span class="dt">Value</span> seek_c) -&gt; (<span class="kw">begin</span>
        <span class="kw">if</span> ((seek_c = <span class="dt">SEEK_DATA</span>) || (seek_c = <span class="dt">SEEK_HOLE</span>)) <span class="kw">then</span>
           finset_singleton (<span class="dt">OS_special</span> (<span class="dt">FIXME</span>, <span class="st">&quot;lseek: SEEK_DATA and SEEK_HOLE are unsupported by this spec&quot;</span>)) <span class="co">(* coverage:mac_os_x:posix:irrelevant -there is no int code for SEEK_DATA and SEEK_HOLE so seek_c_eov returns always EINVAL and this match case is never entered *)</span>
        <span class="kw">else</span> (
          <span class="co">(* checks successful, we can execute lseek *)</span>

          <span class="co">(* compute new offset *)</span>
          <span class="kw">let</span> (new_ofs_o_e : error_or_value off_t) = (<span class="kw">match</span> seek_c <span class="kw">with</span>
            | <span class="dt">SEEK_SET</span> -&gt;  <span class="dt">Value</span> ofs
            | <span class="dt">SEEK_CUR</span> -&gt; <span class="dt">Value</span> ((intFromNat fid_st.fids_offset) + ofs)
            | <span class="dt">SEEK_END</span> -&gt; (<span class="kw">match</span> fid_st.fids_entry <span class="kw">with</span> 
                | <span class="dt">Dir_ref_entry</span> _ -&gt; <span class="dt">Error</span> <span class="dt">EOVERFLOW</span>
                | <span class="dt">File_ref_entry</span> i0_ref -&gt; <span class="dt">Value</span> ((intFromNat (file_get_size env.env_ops s0.oss_fs_state i0_ref)) + ofs)
              <span class="kw">end</span>)       
            | <span class="dt">SEEK_DATA</span> -&gt; failwith <span class="st">&quot;impossible: checked before&quot;</span> <span class="co">(* coverage:impossible *)</span>
            | <span class="dt">SEEK_HOLE</span> -&gt; failwith <span class="st">&quot;impossible: checked before&quot;</span> <span class="co">(* coverage:impossible *)</span>
          end) <span class="kw">in</span>
          (<span class="kw">match</span> new_ofs_o_e <span class="kw">with</span>
            | <span class="dt">Error</span> e -&gt; finset_singleton (<span class="dt">OS_normal</span> (update_pending_return s0 pid (<span class="dt">Error</span> e)))
            | <span class="dt">Value</span> new_ofs -&gt; (
              <span class="kw">if</span> (new_ofs &lt; <span class="dv">0</span>) <span class="kw">then</span>
                finset_singleton (<span class="dt">OS_normal</span> (update_pending_return s0 pid (<span class="dt">Error</span> <span class="dt">EINVAL</span>))) <span class="co">(* posix/lseek.md EINVAL:2 *)</span>
              <span class="kw">else</span> <span class="kw">begin</span> <span class="co">(* put new offset in data-structure and return new state *)</span>
                <span class="kw">let</span> new_ofs_nat = natFromInt new_ofs <span class="kw">in</span>
                <span class="kw">let</span> s1 = update_pending_return s0 pid (<span class="dt">Value</span> (<span class="dt">RV_num</span> new_ofs_nat)) <span class="kw">in</span>
                <span class="kw">let</span> fid_st = &lt;| fid_st <span class="kw">with</span> fids_offset=new_ofs_nat |&gt; <span class="kw">in</span>
                <span class="kw">let</span> s2 = &lt;| s1 <span class="kw">with</span> oss_fid_table=(fmap_update s0.oss_fid_table (fid,fid_st)) |&gt; <span class="kw">in</span>
                finset_singleton (<span class="dt">OS_normal</span> s2)           
              <span class="kw">end</span>)
          end))
        end)
      end)
    )


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* os_add_user_to_group          *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">val</span> os_add_user_to_group: forall &#39;dir_ref &#39;file_ref &#39;impl.
     ty_pid -&gt;
     uid -&gt; gid -&gt;
     ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     finset (os_state_or_special &#39;dir_ref &#39;file_ref &#39;impl)
  <span class="kw">let</span> os_add_user_to_group pid uid gid s0 = (
<span class="ot">#ifdef aspect_perms</span>
    <span class="kw">let</span> s0 = add_uid_to_gid s0 uid gid <span class="kw">in</span> 
<span class="ot">#endif</span>
    <span class="kw">let</span> s0 = update_pending_return s0 pid (<span class="dt">Value</span> (<span class="dt">RV_none</span>)) <span class="kw">in</span>
    finset_singleton (<span class="dt">OS_normal</span> s0)
  )


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* os_umask                      *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">val</span> os_umask: forall &#39;dir_ref &#39;file_ref &#39;impl.
     ty_pid -&gt;
     file_perm -&gt;
     ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     finset (os_state_or_special &#39;dir_ref &#39;file_ref &#39;impl)
  <span class="kw">let</span> os_umask pid new_mask s0 = (
    <span class="kw">let</span> ppstate = lookup_per_process_state s0 pid <span class="kw">in</span>
    <span class="kw">let</span> old_mask = ppstate.pps_file_creation_mask <span class="kw">in</span>
    <span class="kw">let</span> ppstate&#39; = &lt;| ppstate <span class="kw">with</span> pps_file_creation_mask = new_mask;
                                   pps_pid_run_state = <span class="dt">PENDING_RETURN</span>(<span class="dt">Value</span>(<span class="dt">RV_file_perm</span> old_mask)) |&gt; <span class="kw">in</span>
    <span class="kw">let</span> s0&#39; = &lt;| s0 <span class="kw">with</span> oss_pid_table=(fmap_update s0.oss_pid_table (pid,ppstate&#39;)) |&gt; <span class="kw">in</span>
    finset_singleton (<span class="dt">OS_normal</span> s0&#39;)
  )


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* os_chdir                      *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">val</span> os_chdir: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     ty_pid -&gt;
     res_name &#39;dir_ref &#39;file_ref -&gt;
     ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     finset (os_state_or_special &#39;dir_ref &#39;file_ref &#39;impl)
  <span class="kw">let</span> os_chdir env pid path s0 = (
    <span class="kw">let</span> (cwd&#39;_opt, ret)  = <span class="kw">match</span> path <span class="kw">with</span>
        | <span class="dt">RN_error</span>(e,_) -&gt; (<span class="dt">Nothing</span>, <span class="dt">Error</span> e)
        | <span class="dt">RN_none</span> _ -&gt; (<span class="dt">Nothing</span>, <span class="dt">Error</span> <span class="dt">ENOENT</span>) 
        | <span class="dt">RN_file</span> _ -&gt; (<span class="dt">Nothing</span>, <span class="dt">Error</span> <span class="dt">ENOTDIR</span>)
        | <span class="dt">RN_dir</span>(d0_ref, _) -&gt; (        
<span class="ot">#ifdef aspect_perms</span>
            <span class="kw">let</span> perm_checks = env.env_prms.cp_has_dir_search_permission s0.oss_fs_state d0_ref <span class="kw">in</span>
<span class="ot">#else</span>
            <span class="kw">let</span> perm_checks = <span class="kw">true</span> <span class="kw">in</span>
<span class="ot">#endif</span>
            <span class="kw">if</span> perm_checks <span class="kw">then</span>
              (<span class="dt">Just</span> d0_ref, <span class="dt">Value</span> <span class="dt">RV_none</span>)
            <span class="kw">else</span>
              (<span class="dt">Nothing</span>, <span class="dt">Error</span> <span class="dt">EACCES</span>)
          )
    end <span class="kw">in</span>

    <span class="kw">let</span> ppstate = lookup_per_process_state s0 pid <span class="kw">in</span>
    <span class="kw">let</span> new_cwd = fromMaybe ppstate.pps_cwd cwd&#39;_opt <span class="kw">in</span>
    <span class="kw">let</span> ppstate&#39; = &lt;| ppstate <span class="kw">with</span> pps_cwd = new_cwd;
                                   pps_pid_run_state = <span class="dt">PENDING_RETURN</span>(ret) |&gt; <span class="kw">in</span>
    <span class="kw">let</span> s0&#39; = &lt;| s0 <span class="kw">with</span> oss_pid_table=(fmap_update s0.oss_pid_table (pid,ppstate&#39;)) |&gt; <span class="kw">in</span>
    finset_singleton (<span class="dt">OS_normal</span> s0&#39;)
  )


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* os_opendir                    *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">val</span> os_opendir: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     ty_pid -&gt; 
     res_name &#39;dir_ref &#39;file_ref -&gt; 
     ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     finset (os_state_or_special &#39;dir_ref &#39;file_ref &#39;impl)
  <span class="kw">let</span> os_opendir env pid rpath s0 = (
    <span class="co">(* run fs-level open *)</span>
    <span class="kw">let</span> rs = <span class="kw">begin</span>
      <span class="kw">let</span> fs0 = s0.oss_fs_state <span class="kw">in</span>
      <span class="kw">let</span> f0 = fsop_opendir env rpath <span class="kw">in</span>
      run_fsmonad f0 fs0
    <span class="kw">end</span> <span class="kw">in</span>

    <span class="co">(* For each resulting monad_state, we need to construct</span>
<span class="co">       an os-state *)</span>
    <span class="kw">let</span> process_fs_result st = (<span class="kw">match</span> st <span class="kw">with</span>
      | <span class="dt">Special_state</span>(ss,msg) -&gt; <span class="co">(* just forward special results *)</span> (<span class="dt">OS_special</span>(ss,msg)) <span class="co">(* coverage:linux:irrelevant *)</span>
      | <span class="dt">Error_state</span> (fs_st, e) -&gt; <span class="co">(* just forward errors *)</span>
           <span class="dt">OS_normal</span> (update_pending_return_and_fs_state s0 pid (<span class="dt">Error</span> e) fs_st)
      | <span class="dt">Normal_state</span> (fs_st, d0_ref) -&gt; (<span class="kw">begin</span>
          <span class="co">(* for a normal result, create a corresponding dir-handle and return it *)</span>

          <span class="co">(* put fs_state in things into the os_state *)</span>
          <span class="kw">let</span> s0 = &lt;| s0 <span class="kw">with</span> oss_fs_state=fs_st |&gt; <span class="kw">in</span>

          <span class="co">(* create fd, open fid, handle O_CLOEXEC *)</span>
          <span class="kw">let</span> (s0,dh) = create_dh env.env_ops pid d0_ref s0 <span class="kw">in</span>

          <span class="co">(* return value - an int corresponding to the fd *)</span>
          <span class="dt">OS_normal</span> (update_pending_return s0 pid (<span class="dt">Value</span> (<span class="dt">RV_num</span> (dest_DH dh))))
        <span class="kw">end</span>)
    end) <span class="kw">in</span>

    finset_image process_fs_result rs)



  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* os_readdir                    *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">val</span> os_readdir: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     ty_pid -&gt; 
     ty_dh -&gt; 
     ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     finset (os_state_or_special &#39;dir_ref &#39;file_ref &#39;impl)
  <span class="kw">let</span> os_readdir env pid dh s0 = 
    <span class="co">(* lookup the dh and fid we want to read from *)</span>
    <span class="kw">let</span> pps = lookup_per_process_state s0 pid <span class="kw">in</span>
    
    (<span class="kw">match</span> fmap_lookup pps.pps_dh_table dh <span class="kw">with</span> 
     | <span class="dt">Nothing</span> -&gt; <span class="co">(* if it does not exist, raise EBADF *)</span> 
         finset_singleton (<span class="dt">OS_normal</span> (update_pending_return s0 pid (<span class="dt">Error</span> <span class="dt">EBADF</span>)))  <span class="co">(* posix/readdir.md EBADF:1 *)</span>
     | <span class="dt">Just</span> dh_st -&gt; (
         <span class="co">(* get the changes to the directory since last readdir *)</span>
         <span class="kw">let</span> (fs_st&#39;, changes) = env.env_ops.fops_observe_dir s0.oss_fs_state dh_st.dhs_observe_handle <span class="kw">in</span>
         <span class="kw">let</span> s1 = &lt;| s0 <span class="kw">with</span> oss_fs_state = fs_st&#39; |&gt; <span class="kw">in</span>

         <span class="co">(* incorparate the changes into the current state *)</span>
         <span class="kw">let</span> apply_change dhs ode = (<span class="kw">match</span> ode <span class="kw">with</span>
           | <span class="dt">OD_added</span> n -&gt; 
               <span class="co">(* If file n was newly added add it to the list that might be reported on. </span>
<span class="co">                  Do this, even if the file is in there already or definitely needs reporting.</span>
<span class="co">                  This is important in case of multiple delete / add events when a file actually</span>
<span class="co">                  might be reported several times. *)</span>
               &lt;| dhs <span class="kw">with</span> dhs_may_report = n :: dhs.dhs_may_report |&gt;
           | <span class="dt">OD_removed</span> n -&gt;
               <span class="co">(* if [n] needed to be reported, weaken that need into a maybe report *)</span>
               <span class="kw">if</span> (List<span class="kw">.</span>elem n dhs.dhs_must_report) <span class="kw">then</span>
                  &lt;| dhs <span class="kw">with</span> dhs_must_report = List<span class="kw">.</span>delete n dhs.dhs_must_report;
                              dhs_may_report = n :: dhs.dhs_may_report |&gt;
               <span class="kw">else</span> dhs
         end ) <span class="kw">in</span>
         <span class="kw">let</span> dh_st&#39; = List<span class="kw">.</span>foldl apply_change dh_st changes <span class="kw">in</span>

         <span class="co">(* prepare a list of all possible return values / notice none is added later *)</span>
         <span class="kw">let</span> ret_names = removeDuplicates (dh_st&#39;.dhs_must_report ++ dh_st&#39;.dhs_may_report) <span class="kw">in</span>
         <span class="kw">let</span> ret_state_from_name n = (
           <span class="co">(* we need to remove the name we are returning from the list *)</span>
           <span class="kw">let</span> dh_st&#39;&#39; = <span class="kw">if</span> (List<span class="kw">.</span>elem n dh_st&#39;.dhs_must_report) <span class="kw">then</span>
               &lt;| dh_st&#39; <span class="kw">with</span> dhs_must_report = List<span class="kw">.</span>delete n dh_st&#39;.dhs_must_report |&gt;
             <span class="kw">else</span> 
               &lt;| dh_st&#39; <span class="kw">with</span> dhs_may_report = List<span class="kw">.</span>delete n dh_st&#39;.dhs_may_report |&gt;
           <span class="kw">in</span>
           <span class="kw">let</span> pps&#39; = &lt;| pps <span class="kw">with</span> pps_dh_table=(fmap_update pps.pps_dh_table (dh,dh_st&#39;&#39;)) |&gt; <span class="kw">in</span>
           <span class="kw">let</span> s2 = &lt;| s1 <span class="kw">with</span> oss_pid_table=(fmap_update s0.oss_pid_table (pid,pps&#39;)) |&gt; <span class="kw">in</span>
           <span class="dt">OS_normal</span> (update_pending_return s2 pid (<span class="dt">Value</span> (<span class="dt">RV_bytes</span> (T_list_array<span class="kw">.</span>of_string n))))
         ) <span class="kw">in</span>
         <span class="kw">let</span> ret_name_states = List<span class="kw">.</span>map ret_state_from_name ret_names <span class="kw">in</span>

         <span class="co">(* if there is nothing left we definitely have to report, add RV_none *)</span>
         <span class="kw">let</span> ret_none_state = (
           <span class="co">(* If we return None, we could set some flag that from now on, only None is returned.</span>
<span class="co">              But I don&#39;t think this is enforced behaviour, although this is most likely what</span>
<span class="co">              happens in a real implementation *)</span>
           <span class="kw">let</span> pps&#39; = &lt;| pps <span class="kw">with</span> pps_dh_table=(fmap_update pps.pps_dh_table (dh,dh_st&#39;)) |&gt; <span class="kw">in</span>
           <span class="kw">let</span> s2 = &lt;| s0 <span class="kw">with</span> oss_pid_table=(fmap_update s0.oss_pid_table (pid,pps&#39;)) |&gt; <span class="kw">in</span>
           <span class="dt">OS_normal</span> (update_pending_return s1 pid (<span class="dt">Value</span> <span class="dt">RV_none</span>))
         ) <span class="kw">in</span>


         <span class="co">(* do the return *)</span>
         <span class="kw">let</span> ret_states = <span class="kw">if</span> (List<span class="kw">.</span>null dh_st&#39;.dhs_must_report) <span class="kw">then</span> ret_none_state :: ret_name_states <span class="kw">else</span> ret_name_states <span class="kw">in</span>
         finset_from_list ret_states
     )
     end)


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* os_closedir                   *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">val</span> os_closedir: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     ty_pid -&gt; 
     ty_dh -&gt; 
     ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     finset (os_state_or_special &#39;dir_ref &#39;file_ref &#39;impl)
  <span class="kw">let</span> os_closedir env pid dh s0 = 
    <span class="co">(* lookup the dh and fid we want to read from *)</span>
    <span class="kw">let</span> pps = lookup_per_process_state s0 pid <span class="kw">in</span>
    
    (<span class="kw">match</span> fmap_lookup pps.pps_dh_table dh <span class="kw">with</span> 
     | <span class="dt">Nothing</span> -&gt; <span class="co">(* if it does not exist, raise EBADF *)</span> 
         finset_singleton (<span class="dt">OS_normal</span> (update_pending_return s0 pid (<span class="dt">Error</span> <span class="dt">EBADF</span>)))  <span class="co">(* posix/closedir.md EBADF:1 *)</span>
     | <span class="dt">Just</span> dh_st -&gt; (
         <span class="co">(* unregister the observe_handle *)</span>
         <span class="kw">let</span> fs_st&#39; = env.env_ops.fops_observe_dir_unregister s0.oss_fs_state dh_st.dhs_observe_handle <span class="kw">in</span>

         <span class="co">(* update the state s0  *)</span>
         <span class="kw">let</span> pps&#39; = &lt;| pps <span class="kw">with</span> pps_pid_run_state=<span class="dt">PENDING_RETURN</span> (<span class="dt">Value</span> <span class="dt">RV_none</span>); 
                                pps_dh_table=(fmap_remove pps.pps_dh_table dh) |&gt; <span class="kw">in</span>
         <span class="kw">let</span> s1 = &lt;| s0 <span class="kw">with</span> oss_pid_table=(fmap_update s0.oss_pid_table (pid,pps&#39;)); oss_fs_state = fs_st&#39; |&gt; <span class="kw">in</span>

         finset_singleton (<span class="dt">OS_normal</span> s1)
     )
     end)


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* os_rewinddir                  *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">val</span> os_rewinddir: forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     ty_pid -&gt; 
     ty_dh -&gt; 
     ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     finset (os_state_or_special &#39;dir_ref &#39;file_ref &#39;impl)
  <span class="kw">let</span> os_rewinddir env pid dh s0 = 
    <span class="co">(* lookup the dh and fid we want to read from *)</span>
    <span class="kw">let</span> pps = lookup_per_process_state s0 pid <span class="kw">in</span>
    
    (<span class="kw">match</span> fmap_lookup pps.pps_dh_table dh <span class="kw">with</span> 
     | <span class="dt">Nothing</span> -&gt; <span class="co">(* if it does not exist, raise EBADF *)</span> 
         finset_singleton (<span class="dt">OS_normal</span> (update_pending_return s0 pid (<span class="dt">Error</span> <span class="dt">EBADF</span>)))  <span class="co">(* guessing here *)</span>
     | <span class="dt">Just</span> dh_st -&gt; (
         <span class="co">(* reset the observe handle *)</span>
         <span class="kw">let</span> (dh_st&#39;, fs_st&#39;) = rewind_dhs env.env_ops dh_st s0.oss_fs_state <span class="kw">in</span>

         <span class="co">(* update the state s0  *)</span>
         <span class="kw">let</span> pps&#39; = &lt;| pps <span class="kw">with</span> pps_pid_run_state=<span class="dt">PENDING_RETURN</span> (<span class="dt">Value</span> <span class="dt">RV_none</span>); 
                                pps_dh_table=(fmap_update pps.pps_dh_table (dh, dh_st&#39;)) |&gt; <span class="kw">in</span>
         <span class="kw">let</span> s1 = &lt;| s0 <span class="kw">with</span> oss_pid_table=(fmap_update s0.oss_pid_table (pid,pps&#39;)); oss_fs_state = fs_st&#39; |&gt; <span class="kw">in</span>

         finset_singleton (<span class="dt">OS_normal</span> s1)
     )
     end)

  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* os_determinise                *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* For some operations like read and write are non-deterministic, but it would</span>
<span class="co">     in some situations be nice to pick a peticular result. In the case of write</span>
<span class="co">     for example ensure that all of the data is written. The following function</span>
<span class="co">     achieves this in a general way. </span>
<span class="co">     [os_determinise select_fun ss] tries to pick only one state from state set </span>
<span class="co">     [ss] using [rv_less] to choose which one. If the state set contains</span>
<span class="co">     states that are </span>

<span class="co">     - special or </span>
<span class="co">     - aren&#39;t in run state PENDING_RETURN or</span>
<span class="co">     - are not about to return a value,</span>

<span class="co">     the full set is returned. Otherwise one of these states is picked and</span>
<span class="co">     and a singleton set is returned. [rv_cmp] is used to determine,</span>
<span class="co">     which state is picked. [rv_less] encodes a partial order on return-values. </span>
<span class="co">     A state that returns a maximum according to [rv_less] is picked. *)</span> 
  <span class="kw">val</span> os_determinise : forall &#39;dir_ref &#39;file_ref &#39;impl.
     (ret_value -&gt; ret_value -&gt; <span class="dt">bool</span>) -&gt;
     ty_pid -&gt; 
     finset (os_state_or_special &#39;dir_ref &#39;file_ref &#39;impl) -&gt;
     finset (os_state_or_special &#39;dir_ref &#39;file_ref &#39;impl)
  <span class="kw">let</span> os_determinise rv_less pid ss = <span class="kw">begin</span>
     <span class="kw">let</span> extract_rv sos = (<span class="kw">match</span> sos <span class="kw">with</span>
       | <span class="dt">OS_special</span> _ -&gt; <span class="dt">Nothing</span> <span class="co">(* coverage:impossible -we would need to receive a special state from os_read and os_write, only funcitons that use determinise, and they cannot be reached (view os_write and os_read) *)</span>
       | <span class="dt">OS_normal</span> s -&gt; (<span class="kw">match</span> (get_run_state s pid) <span class="kw">with</span>
          | <span class="dt">PENDING_RETURN</span> (<span class="dt">Value</span> v) -&gt; <span class="dt">Just</span> v
          | _ -&gt; <span class="dt">Nothing</span>
         <span class="kw">end</span>)
     end) <span class="kw">in</span>
     <span class="kw">if</span> ((finset_is_empty ss) || (finset_any (<span class="kw">fun</span> sos -&gt; isNothing (extract_rv sos)) ss)) <span class="kw">then</span>
       <span class="co">(* we have a set of states we can&#39;t determinise; so do nothing with it *)</span>
       ss
     <span class="kw">else</span> (
       <span class="co">(* The set is not empty and all states have a value pending to be returned. </span>
<span class="co">          So select the best one. *)</span>
       <span class="kw">let</span> sl = list_from_finset ss <span class="kw">in</span>

       <span class="kw">let</span> picked_s = foldl1 (<span class="kw">fun</span> s1 s2 -&gt; (
         <span class="kw">match</span> (extract_rv s1, extract_rv s2) <span class="kw">with</span>
          | (<span class="dt">Just</span> rv1, <span class="dt">Just</span> rv2) -&gt;
             <span class="kw">if</span> (rv_less rv1 rv2)
             <span class="kw">then</span> s2
             <span class="kw">else</span> s1 <span class="co">(* coverage:impossible -using fsm_choose_nat in both os_read and os_write we end up creating return values (fsm_choose_nat len_max) in increasing order *)</span>
          | _ -&gt; <span class="co">(* should not happen as tested before, but degenerate gracefully *)</span> s1 <span class="co">(* coverage:impossible *)</span>
         end)) sl <span class="kw">in</span>

       <span class="co">(* return a singleton set of the picked state *)</span>
       finset_singleton picked_s
     )
  end

  <span class="co">(* The comparison function for the read and write functions. It maximises the</span>
<span class="co">     read/written data. *)</span>
  <span class="kw">val</span> os_determinise_less_read_write : ret_value -&gt; ret_value -&gt; <span class="dt">bool</span>
  <span class="kw">let</span> os_determinise_less_read_write rv1 rv2 = (<span class="kw">match</span> (rv1, rv2) <span class="kw">with</span>
    | (<span class="dt">RV_num</span> n1, <span class="dt">RV_num</span> n2) -&gt; (n1 &lt; n2)
    | (<span class="dt">RV_bytes</span> bs1, <span class="dt">RV_bytes</span> bs2) -&gt; 
        (T_list_array<span class="kw">.</span>dim bs1 &lt; T_list_array<span class="kw">.</span>dim bs2)
    | _ -&gt; <span class="co">(* should not happen for read and write *)</span> <span class="kw">false</span> <span class="co">(* coverage:impossible *)</span>
  end)
    
end


<span class="co">(******************************************************************************)</span>
<span class="co">(* Os_transition system                                                       *)</span>
<span class="co">(*                                                                            *)</span>
<span class="co">(* The model of transitions at the operating system level is:                 *)</span>
<span class="co">(*   - A call gets made with OS_CALL cmd                                      *)</span>
<span class="co">(*   - The process gets moved to a blocked state                              *)</span>
<span class="co">(*   - Further steps process the call                                         *)</span>
<span class="co">(*   - A return transition occurs with OS_RETURN;                             *)</span>
<span class="co">(*     at this point, the process is unblocked                                *)</span>
<span class="co">(******************************************************************************)</span>

<span class="ot">module</span> Os_transition_system = <span class="kw">struct</span>

  <span class="ot">open</span> Fs_types
  <span class="ot">open</span> Fs_arch
  <span class="ot">open</span> Resolve <span class="co">(* for process_path *)</span>
  <span class="ot">open</span> Fs_transition_system
<span class="ot">#ifdef aspect_perms</span>
  <span class="ot">open</span> Fs_permissions
<span class="ot">#endif</span>
  <span class="ot">open</span> Os_operations


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* os_trans_pid                  *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* run fs-level commands *)</span>
  <span class="kw">val</span> os_run_fs_command : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     ty_pid -&gt; 
     ty_fs_command &#39;dir_ref &#39;file_ref -&gt;
     ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     finset (os_state_or_special &#39;dir_ref &#39;file_ref &#39;impl)
  <span class="kw">let</span> os_run_fs_command env pid cmd s0 = <span class="kw">begin</span>
    <span class="kw">let</span> rs = fs_trans env s0.oss_fs_state cmd <span class="kw">in</span>

    <span class="kw">let</span> monad_state_to_os_state (ms : monad_state &#39;impl ret_value) = (<span class="kw">match</span> ms <span class="kw">with</span>
      | <span class="dt">Normal_state</span>(fs_st,v) -&gt; 
          <span class="dt">OS_normal</span> (update_pending_return_and_fs_state s0 pid (<span class="dt">Value</span> v) fs_st)
      | <span class="dt">Error_state</span>(fs_st,e) -&gt; 
          <span class="dt">OS_normal</span> (update_pending_return_and_fs_state s0 pid (<span class="dt">Error</span> e) fs_st)
      | <span class="dt">Special_state</span>(spcial,s) -&gt; ( <span class="dt">OS_special</span>(spcial,s))
    <span class="kw">end</span>) <span class="kw">in</span>
    finset_image monad_state_to_os_state rs

  <span class="kw">end</span>

  <span class="co">(* run an OS-level_command *)</span>
  <span class="kw">val</span> os_run_os_command : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     ty_pid -&gt; 
     ty_os_command -&gt;
     ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     finset (os_state_or_special &#39;dir_ref &#39;file_ref &#39;impl)
  <span class="kw">let</span> os_run_os_command env pid cmd s0 = <span class="kw">begin</span>
    <span class="kw">let</span> ppstate = lookup_per_process_state s0 pid <span class="kw">in</span>
    <span class="kw">let</span> pp path = (
      process_path env s0.oss_fs_state ppstate.pps_cwd cmd path
    ) <span class="kw">in</span>

    <span class="kw">let</span> run_fs_cmd fs_cmd = os_run_fs_command env pid fs_cmd s0 <span class="kw">in</span>

    <span class="co">(* determinise output of read or write commands *)</span>
    <span class="kw">let</span> det_rw ss = os_determinise os_determinise_less_read_write pid ss <span class="kw">in</span>

    <span class="kw">let</span> run_os_cmd (cmd : ty_os_command) = (
      <span class="kw">match</span> cmd <span class="kw">with</span>
      <span class="co">(* real os-commands *)</span>
      | <span class="dt">OS_CLOSE</span> fd                 -&gt; (os_close env pid fd s0)
      | <span class="dt">OS_OPEN</span> (p,fs,mo)           -&gt; (os_open env pid (pp p) fs mo s0) 
      | <span class="dt">OS_UMASK</span> p                  -&gt; (os_umask pid p s0)
      | <span class="dt">OS_CHDIR</span> s                  -&gt; (os_chdir env pid (pp s) s0)
      | <span class="dt">OS_LSEEK</span> (fd,ofs,c)         -&gt; (os_lseek env pid fd ofs c s0) 
      | <span class="dt">OS_OPENDIR</span> p                -&gt; (os_opendir env pid (pp p) s0)
      | <span class="dt">OS_READDIR</span> dh               -&gt; (os_readdir env pid dh s0)
      | <span class="dt">OS_CLOSEDIR</span> dh              -&gt; (os_closedir env pid dh s0)
      | <span class="dt">OS_REWINDDIR</span> dh             -&gt; (os_rewinddir env pid dh s0) 

      <span class="co">(* read and write commands *)</span>
      | <span class="dt">OS_PREAD</span> (fd,sz,ofs)                           -&gt;        (os_read env pid fd sz (<span class="dt">Just</span> ofs) s0)
      | <span class="dt">OS_EXTENDED_CMD</span> (<span class="dt">OS_DET_PREAD</span> (fd,sz,ofs))     -&gt; det_rw (os_read env pid fd sz (<span class="dt">Just</span> ofs) s0)
      | <span class="dt">OS_READ</span> (fd,sz)                                -&gt;        (os_read env pid fd sz <span class="dt">Nothing</span> s0) 
      | <span class="dt">OS_EXTENDED_CMD</span> (<span class="dt">OS_DET_READ</span> (fd,sz))          -&gt; det_rw (os_read env pid fd sz <span class="dt">Nothing</span> s0) 
      | <span class="dt">OS_PWRITE</span> (fd,bs,sz,ofs)                       -&gt;        (os_write env pid fd bs sz (<span class="dt">Just</span> ofs) s0)
      | <span class="dt">OS_EXTENDED_CMD</span> (<span class="dt">OS_DET_PWRITE</span> (fd,bs,sz,ofs)) -&gt; det_rw (os_write env pid fd bs sz (<span class="dt">Just</span> ofs) s0)
      | <span class="dt">OS_WRITE</span> (fd,bs,sz)                            -&gt;        (os_write env pid fd bs sz <span class="dt">Nothing</span> s0)
      | <span class="dt">OS_EXTENDED_CMD</span> (<span class="dt">OS_DET_WRITE</span> (fd,bs,sz))      -&gt; det_rw (os_write env pid fd bs sz <span class="dt">Nothing</span> s0)

      <span class="co">(* extended commands *)</span>
      | <span class="dt">OS_EXTENDED_CMD</span> (<span class="dt">OS_ADD_USER_TO_GROUP</span> (u, g)) -&gt; os_add_user_to_group pid u g s0
      | <span class="dt">OS_EXTENDED_CMD</span> (<span class="dt">OS_OPEN_CLOSE</span> (p,fs,p&#39;))     -&gt; run_fs_cmd (<span class="dt">FS_EXTENDED_CMD</span> (<span class="dt">FS_OPEN_CLOSE</span>(pp p, fs, p&#39;)))

      <span class="co">(* direct mapping to fs-commands *)</span>
      | <span class="dt">OS_LINK</span> (s,d)      -&gt; (run_fs_cmd (<span class="dt">FS_LINK</span>(pp s, pp d)))
      | <span class="dt">OS_MKDIR</span> (s,p)     -&gt; (run_fs_cmd (<span class="dt">FS_MKDIR</span>(pp s, p)))
      | <span class="dt">OS_READLINK</span> p      -&gt; (run_fs_cmd (<span class="dt">FS_READLINK</span>(pp p)))
      | <span class="dt">OS_RENAME</span> (s,d)    -&gt; (run_fs_cmd (<span class="dt">FS_RENAME</span>(pp s, pp d)))
      | <span class="dt">OS_RMDIR</span> p         -&gt; (run_fs_cmd (<span class="dt">FS_RMDIR</span>(pp p)))
      | <span class="dt">OS_STAT</span> p          -&gt; (run_fs_cmd (<span class="dt">FS_STAT</span>(pp p)))
      | <span class="dt">OS_LSTAT</span> p         -&gt; (run_fs_cmd (<span class="dt">FS_LSTAT</span>(pp p)))
      | <span class="dt">OS_SYMLINK</span> (s,d)   -&gt; (run_fs_cmd (<span class="dt">FS_SYMLINK</span>(bytes_of_cstring s, pp d)))
      | <span class="dt">OS_TRUNCATE</span> (p,l)  -&gt; (run_fs_cmd (<span class="dt">FS_TRUNCATE</span>(pp p,l)))
      | <span class="dt">OS_UNLINK</span> p        -&gt; (run_fs_cmd (<span class="dt">FS_UNLINK</span>(pp p)))
      | <span class="dt">OS_CHMOD</span> (s, p)    -&gt; (run_fs_cmd (<span class="dt">FS_CHMOD</span> (pp s, p)))
      | <span class="dt">OS_CHOWN</span> (s, u, g) -&gt; (run_fs_cmd (<span class="dt">FS_CHOWN</span> (pp s, u, g)))
    <span class="kw">end</span>) <span class="kw">in</span>

    run_os_cmd cmd
<span class="co">(*    (match cmd with </span>
<span class="co">      | OS_POSIX_CMD cmd&#39;           -&gt; run_os_cmd false cmd&#39;</span>
<span class="co">      | OS_DETERMINISTIC_CMD cmd&#39;   -&gt; run_os_cmd true cmd&#39;</span>
<span class="co">     end) *)</span>
  end



  <span class="co">(* [update_env_permissions_for_pid s0 pid env] changes the permission record</span>
<span class="co">     field [env_prms] in [env] to be appropriate for running commands for process</span>
<span class="co">     [pid] in state [s0]. *)</span>
  <span class="kw">val</span> update_env_permissions_for_pid : forall &#39;dir_ref &#39;file_ref &#39;impl.
     ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     ty_pid -&gt;
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     environment &#39;dir_ref &#39;file_ref &#39;impl
  <span class="kw">let</span> update_env_permissions_for_pid s0 pid env = (
<span class="ot">#ifdef aspect_perms</span>
    <span class="kw">let</span> ppstate = lookup_per_process_state s0 pid <span class="kw">in</span>
    <span class="kw">let</span> uid = ppstate.pps_effective_uid <span class="kw">in</span>
    <span class="kw">let</span> gid = ppstate.pps_effective_gid <span class="kw">in</span>
    <span class="kw">let</span> prms =
      <span class="kw">if</span> (env.env_perm_ops.pops_uid_is_superuser s0.oss_fs_state uid)
      <span class="kw">then</span> superuser_permissions env.env_ops uid gid ppstate.pps_file_creation_mask <span class="co">(* coverage:fixme - this will be solved once we run some traces with the --root *)</span>
      <span class="kw">else</span> uid_permissions env (is_uid_in_gid s0) uid gid ppstate.pps_file_creation_mask
    <span class="kw">in</span>
    &lt;| env <span class="kw">with</span> env_prms = prms |&gt;
<span class="ot">#else</span>
    env
<span class="ot">#endif</span>
  )

  <span class="co">(* [os_trans_pid_core] is the core of [os_trans_pid] it is run, if the process is</span>
<span class="co">     blocked and a tau-transition occurs. It is the operation that actually runs the</span>
<span class="co">     OS-commands *)</span>        
  <span class="kw">val</span> os_trans_pid_core : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     ty_pid -&gt; 
     ty_os_command -&gt;
     finset (os_state_or_special &#39;dir_ref &#39;file_ref &#39;impl)
  <span class="kw">let</span> os_trans_pid_core env s0 pid cmd = (
    <span class="co">(* check that none of the paths in the command starts with exactly two slashes *)</span>
    <span class="kw">let</span> unsupported_double_slash = (
      <span class="kw">let</span> archi = architecture_of_ty_arch env.env_arch <span class="kw">in</span>
      ((List<span class="kw">.</span>any path_starts_with_exactly_two_slashes (paths_of_ty_os_command cmd)) 
      &amp;&amp; not(archi.arch_abs_path_slash_slash))
    ) <span class="kw">in</span>
    <span class="kw">if</span> unsupported_double_slash <span class="kw">then</span> 
      finset_singleton (<span class="dt">OS_special</span>(<span class="dt">Implementation_defined</span>,<span class="st">&quot;path starts with exactly two slashes&quot;</span>)) <span class="co">(* coverage:impossible - no supported architecture has arch_abs_path_slash_slash field set to false *)</span>
    <span class="kw">else</span> (
      <span class="co">(* update environment for process FIXME this really needs to be</span>
<span class="co">         fixed - the environment should be fixed for a trace, but</span>
<span class="co">         unfortunately the per-process permissions are accessed from the</span>
<span class="co">         environment (!); better to access the per-process permissions</span>
<span class="co">         from the per-process state *)</span>
      <span class="kw">let</span> env = update_env_permissions_for_pid s0 pid env <span class="kw">in</span>
     
      <span class="co">(* do the real work *)</span>
      os_run_os_command env pid cmd s0
    )
  )

    
  <span class="kw">val</span> os_trans_pid : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     ty_pid -&gt; 
     os_label -&gt;
     finset (os_state_or_special &#39;dir_ref &#39;file_ref &#39;impl)
  <span class="kw">let</span> os_trans_pid env s0 (pid:ty_pid) cmd = (
    <span class="kw">let</span> ppstate = lookup_per_process_state s0 pid <span class="kw">in</span>
    <span class="kw">match</span> (ppstate.pps_pid_run_state,cmd) <span class="kw">with</span> 
      | (<span class="dt">RUNNING</span>,(<span class="dt">OS_CALL</span>(pid&#39;,cmd))) -&gt; 
          <span class="kw">if</span> (pid&#39; &lt;&gt; pid) <span class="kw">then</span> 
            finset_empty ()
          <span class="kw">else</span> (
            finset_singleton (<span class="dt">OS_normal</span> (update_run_state s0 pid (<span class="dt">BLOCKED_CALL</span> cmd)))
          )
      | (<span class="dt">BLOCKED_CALL</span>(cmd),<span class="dt">OS_TAU</span>) -&gt; (os_trans_pid_core env s0 pid cmd)
      | (<span class="dt">PENDING_RETURN</span>(ev),(<span class="dt">OS_RETURN</span>(pid&#39;,ev&#39;))) -&gt; (
          <span class="kw">let</span> success = finset_singleton (<span class="dt">OS_normal</span> (update_run_state s0 pid <span class="dt">RUNNING</span>)) <span class="kw">in</span>
          <span class="kw">let</span> failure = finset_empty () <span class="kw">in</span>
          <span class="co">(* if the label is for pid&#39;, then we cannot do a transition for process pid *)</span>
          <span class="kw">if</span> (pid&#39; &lt;&gt; pid) <span class="kw">then</span> 
            failure
          <span class="kw">else</span> (
            <span class="kw">if</span> (ev&#39; = ev) <span class="kw">then</span> 
              success
            <span class="kw">else</span> (
              <span class="co">(* we would typically not allow a transition; however,</span>
<span class="co">                 sometimes we are very nondeterministic (eg size of a</span>
<span class="co">                 stat&#39;ed directory), in which case we allow the</span>
<span class="co">                 transition *)</span>
              <span class="kw">match</span> (ev,ev&#39;) <span class="kw">with</span>
              | (<span class="dt">Value</span>(<span class="dt">RV_stats</span> s),<span class="dt">Value</span>(<span class="dt">RV_stats</span> s&#39;)) -&gt; ( 
                  <span class="co">(* for a file, we are not interested in st_dev, st_ino (FIXME), st_rdev *)</span>
                  <span class="kw">let</span> mask_file s = (&lt;| s <span class="kw">with</span> st_dev=<span class="dv">0</span>; st_rdev=<span class="dv">0</span>; st_ino=(<span class="dt">Inode</span> <span class="dv">0</span>) |&gt;) <span class="kw">in</span>
                  (<span class="kw">match</span> s.st_kind <span class="kw">with</span>
                  | <span class="dt">S_IFREG</span> -&gt; (
                    <span class="kw">if</span> mask_file s = mask_file s&#39; <span class="kw">then</span>
                      success  <span class="co">(* allow the transition if the only differences are things we are not interested in *)</span>
                    <span class="kw">else</span>
                      failure)
                  | <span class="dt">S_IFLNK</span> -&gt; (
                    <span class="kw">if</span> mask_file s = mask_file s&#39; <span class="kw">then</span>
                      success  <span class="co">(* allow the transition if the only differences are things we are not interested in *)</span>
                    <span class="kw">else</span>
                      failure)
                  | <span class="dt">S_IFDIR</span> -&gt; (
                      <span class="kw">let</span> mask_dir s = &lt;| (mask_file s) <span class="kw">with</span> st_size=<span class="dv">0</span> |&gt; <span class="kw">in</span>
                      <span class="kw">if</span> mask_dir s = mask_dir s&#39; <span class="kw">then</span> 
                        success
                      <span class="kw">else</span>
                        failure)
                  | _ -&gt; failure end))
              | (_,_) -&gt; failure end)))
      | (_,_) -&gt; finset_empty ()
    end)



  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* os_trans_pcreate_destroy      *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* a default file-descriptor table that contains dummy file-descriptors for</span>
<span class="co">     stdin, stdout and stderr. This means that the next free FD is 3.</span>
<span class="co">     These are all mapped to [FID 0]. The os_state should have this fid! *)</span>
  <span class="kw">val</span> default_pps_fd_table :  fmap ty_fd fd_state 
  <span class="kw">let</span> default_pps_fd_table = <span class="kw">begin</span>
    <span class="kw">let</span> stdin_etc = [<span class="dt">FD</span> <span class="dv">0</span> <span class="co">(* stdin *)</span>; <span class="dt">FD</span> <span class="dv">1</span> <span class="co">(* stout *)</span>; <span class="dt">FD</span> <span class="dv">2</span> <span class="co">(* stderr *)</span>] <span class="kw">in</span>
    <span class="kw">let</span> dummy_fds = &lt;| fds_fid=(<span class="dt">FID</span> <span class="dv">0</span>); fds_FD_CLOEXEC=<span class="kw">true</span> |&gt; <span class="kw">in</span>
    <span class="kw">let</span> pps_fd_table = List<span class="kw">.</span>foldl (<span class="kw">fun</span> fdt fd -&gt; fmap_update fdt (fd,dummy_fds)) (fmap_empty ()) stdin_etc <span class="kw">in</span>
    pps_fd_table
  <span class="kw">end</span>

  <span class="co">(* create a default per_process_state. The cwd needs</span>
<span class="co">     to be provided explicitly, because directory refs are</span>
<span class="co">     polymorphic. *)</span>
  <span class="kw">val</span> default_pps : forall &#39;dir_ref.
    uid -&gt; gid -&gt; &#39;dir_ref -&gt; per_process_state &#39;dir_ref
  <span class="kw">let</span> default_pps uid gid cwd = &lt;| 
    pps_cwd=cwd; 
    pps_fd_table=default_pps_fd_table; 
    pps_dh_table=fmap_empty (); 
    pps_pid_run_state=<span class="dt">RUNNING</span>;

    <span class="co">(* 022 seems to be the default on most unix systems.</span>
<span class="co">       Since the default perms for dirs is 777 and for files are 666 </span>
<span class="co">       this means permissions rw-r--r-- for files and</span>
<span class="co">       rwxr-x-r-x for dirs. Another sometimes used value is 002, which</span>
<span class="co">       gives write permissions to the group as well by default. *)</span>
    pps_file_creation_mask= <span class="dt">File_perm</span> <span class="bn">0O022</span>;

    pps_effective_uid = uid;
    pps_real_uid = uid;
    pps_saved_uid = uid;
    pps_effective_gid = gid;
    pps_real_gid = gid;
    pps_saved_gid = gid;
  |&gt;

  <span class="kw">val</span> create_pps_for_pid : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     uid -&gt; gid -&gt; &#39;impl -&gt; ty_pid -&gt; per_process_state &#39;dir_ref
  <span class="kw">let</span> create_pps_for_pid env uid gid s0 pid = default_pps uid gid (fromJust (env.env_ops.fops_get_root s0))


  <span class="kw">val</span> os_trans_pcreate_destroy : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     os_label -&gt; 
     finset (os_state_or_special &#39;dir_ref &#39;file_ref &#39;impl)
  <span class="kw">let</span> os_trans_pcreate_destroy env s0 lbl = (
      <span class="kw">match</span> lbl <span class="kw">with</span>
      | <span class="dt">OS_CREATE</span>(pid, uid, gid) -&gt; (
        <span class="kw">if</span> finset_mem pid (fmap_dom s0.oss_pid_table) <span class="kw">then</span> 
          finset_empty ()
        <span class="kw">else</span> (
          <span class="kw">let</span> s0 = &lt;| s0 <span class="kw">with</span> oss_pid_table=(fmap_update s0.oss_pid_table (pid,create_pps_for_pid env uid gid s0.oss_fs_state pid)) |&gt; <span class="kw">in</span>
          finset_singleton (<span class="dt">OS_normal</span> s0)))
      | <span class="dt">OS_DESTROY</span>(pid) -&gt;
        <span class="kw">if</span> not (finset_mem pid (fmap_dom s0.oss_pid_table)) <span class="kw">then</span> 
          finset_empty ()
        <span class="kw">else</span> (
          <span class="kw">let</span> ppstate = fromJust (fmap_lookup s0.oss_pid_table pid) <span class="kw">in</span>
          (<span class="kw">match</span> ppstate.pps_pid_run_state <span class="kw">with</span> 
          | <span class="dt">RUNNING</span> -&gt; (
            <span class="kw">let</span> s0 = &lt;| s0 <span class="kw">with</span> oss_pid_table=(fmap_remove s0.oss_pid_table pid) |&gt; <span class="kw">in</span>
            finset_singleton (<span class="dt">OS_normal</span> s0))
          | _ -&gt; finset_empty () <span class="co">(* we don&#39;t allow processes to be destroyed if they are in kernel *)</span> end))  <span class="co">(* coverage:fixme -we can test this only in a os trace (we need to destroy a process while it is executing) *)</span>
      | _ -&gt; finset_empty () end)


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* os_trans_tau                  *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">val</span> os_trans_tau : forall &#39;dir_ref &#39;file_ref &#39;impl.
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     os_label -&gt; 
     finset (os_state_or_special &#39;dir_ref &#39;file_ref &#39;impl)
  <span class="kw">let</span> os_trans_tau env s0 lbl = (
    <span class="kw">match</span> lbl <span class="kw">with</span> 
    | <span class="dt">OS_TAU</span> -&gt; finset_empty () <span class="co">(* (finset_singleton s0) FIXME for testing we want to limit nondet - Tau steps represent internal actions only *)</span>
    | _ -&gt; finset_empty () end)
            

  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* os_trans                      *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="kw">val</span> os_trans : forall &#39;dir_ref &#39;file_ref &#39;impl.
     ty_os_state &#39;dir_ref &#39;file_ref &#39;impl -&gt; 
     os_label -&gt; 
     finset (os_state_or_special &#39;dir_ref &#39;file_ref &#39;impl)
  <span class="kw">let</span> os_trans s0 lbl = (
    <span class="kw">let</span> env = s0.oss_env <span class="kw">in</span>
    <span class="co">(* process transitions *)</span>
    <span class="kw">let</span> pids = fmap_dom s0.oss_pid_table <span class="kw">in</span>
    <span class="kw">let</span> ss = finset_bigunion_image (<span class="kw">fun</span> pid -&gt; os_trans_pid env s0 pid lbl) pids <span class="kw">in</span>
    <span class="co">(* create/ destroy transitions *)</span>
    <span class="kw">let</span> ss = finset_union ss (os_trans_pcreate_destroy env s0 lbl) <span class="kw">in</span>
    <span class="co">(* tau transitions *)</span>
    <span class="kw">let</span> ss = finset_union ss (os_trans_tau env s0 lbl) <span class="kw">in</span>
    ss)


  <span class="co">(*-------------------------------*)</span>
  <span class="co">(* os_init_state                 *)</span>
  <span class="co">(*-------------------------------*)</span>

  <span class="co">(* convenience initial state with a single process *)</span>
  <span class="kw">val</span> os_init_state : forall &#39;dir_ref &#39;file_ref &#39;impl.
     <span class="dt">bool</span> -&gt; <span class="co">(* no root *)</span>
     environment &#39;dir_ref &#39;file_ref &#39;impl -&gt;
     ty_os_state &#39;dir_ref &#39;file_ref &#39;impl  
  <span class="kw">let</span> os_init_state no_root env = (
    <span class="kw">let</span> fs0 = env.env_ops.fops_get_init_state() <span class="kw">in</span>
    <span class="kw">let</span> root = fromJust(env.env_ops.fops_get_root fs0) <span class="kw">in</span>

    <span class="co">(* dummy fid table used by fds for stdin, stdout, stderr*)</span>
    <span class="kw">let</span> dummy_fid_state = &lt;| 
      fids_offset=<span class="dv">0</span>; 
      fids_entry=<span class="dt">Dir_ref_entry</span> root; 
      fids_oflags=(finset_empty ()); 
      fids_open_or_closed=<span class="dt">FID_OPEN</span> |&gt; 
    <span class="kw">in</span>
    <span class="kw">let</span> fid_table = fmap_update (fmap_empty ()) (<span class="dt">FID</span> <span class="dv">0</span>,dummy_fid_state) <span class="kw">in</span>

    <span class="co">(* dummy per-process state *)</span>
    <span class="kw">let</span> ppstate = (
      <span class="kw">if</span> no_root <span class="kw">then</span>
        <span class="co">(* create process 1 with &quot;normal&quot; user uid and gid &amp;*)</span>
        default_pps (<span class="dt">User_id</span> <span class="dv">1</span>) (<span class="dt">Group_id</span> <span class="dv">1</span>) root
      <span class="kw">else</span> 
        default_pps root_uid root_gid root)
    <span class="kw">in</span>

    <span class="co">(* dummy pid table *)</span>
    <span class="kw">let</span> pid_table = fmap_update (fmap_empty ()) (<span class="dt">Pid</span> <span class="dv">1</span>,ppstate) <span class="kw">in</span>
    <span class="kw">let</span> s0 = &lt;|
      oss_pid_table=pid_table;
      oss_fid_table=fid_table;
      oss_group_table=fmap_empty();
      oss_fs_state=fs0;
      oss_env=env
    |&gt;
    <span class="kw">in</span>
    s0)


  <span class="co">(** allowed_results_for_pid is a convenience function used by the testing code *)</span>
  <span class="co">(* FIXME not clear what this means when we are nondet on eg size of</span>
<span class="co">   a directory; it should be understood that this is the allowable</span>
<span class="co">   results &quot;up to some notion of equivalence&quot;, where this notion is</span>
<span class="co">   defined eg in os_trans_pid_core *)</span>
  <span class="kw">let</span> allowed_results_for_pid pid s0 = (
    <span class="kw">let</span> pps_opt = fmap_lookup s0.oss_pid_table pid <span class="kw">in</span>
    (<span class="kw">match</span> pps_opt <span class="kw">with</span>
     | <span class="dt">Nothing</span> -&gt; finset_empty ()
     | <span class="dt">Just</span> pps -&gt; (<span class="kw">match</span> pps.pps_pid_run_state <span class="kw">with</span> 
          | <span class="dt">PENDING_RETURN</span>(ev) -&gt; finset_singleton ev
          | _ -&gt; finset_empty () end) end))

end</code></pre>
</body>
</html>
