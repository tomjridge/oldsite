
<html>

<!-- header ---------------------------------------- -->

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8" />
  <meta name="robots" content="all,follow" />

  <meta name="author" content="Tom Ridge" />
  <meta name=viewport content="width=device-width, initial-scale=1">
  <title>Why operational models?</title>
  <link rel="stylesheet" type="text/css" href="tjr_style.css" />


<!-- google tracking ---------------------------------------- -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  // https://developers.google.com/analytics/devguides/collection/analyticsjs/field-reference#siteSpeedSampleRate
  ga('create', 'UA-34388398-1', {'siteSpeedSampleRate': 100});
  ga('send', 'pageview');
</script>

</head>

<body>
<div class='main_body_div'>

<!-- navbar ---------------------------------------- -->

<div class='navbar'>
  <ul>
    <li><a href='index.html'>Home</a></li>
    <li><a href='blog.html'>Blog</a></li>
    <li><a href='category_news.html'>News</a></li>
    <li><a href='filesystems.html'>Filesystems</a></li>
    <li><a href='parsing.html'>Parsing</a></li>
    <li><a href='phd_students.html'>PhD places</a></li>
    <li><a href='publications.html'>Publications</a></li>
    <li><a href='research.html'>Research</a></li>
    <li><a href='software.html'>Software</a></li>
    <li><a href='teaching.html'>Teaching</a></li>
  </ul>
</div>

<!-- main post ---------------------------------------- -->
<div>
  <br/>
  <!-- may not be present -->
  Date: 2015-04-27<br/>
  Categories: <a href='category_research.html'>research</a></br>
  <br/>

  <!-- 
{"date":"2015-04-27","title":"Why operational models?","id":"id:2015-04-27","time":"2015-04-27","cats":["research"]} 
-->
<h1 id="why-operational-models">Why operational models?</h1>
<p>Why give operational specifications and proofs? Why not prefer, say, a program logic?</p>
<p>Most of my work focuses on operational models of programs, and operational proofs about these models. It is much more common to develop program logics and perform proofs in the logic. There are some reasons to prefer operational models and proofs:</p>
<ul>
<li><p>Clear specification: An operational model in terms of a state transition system gives a very clear specification of behaviour. In contrast, the behaviour of programs in a program logic are often given in a way that makes essential use of the syntax of the logic. This can obscure the behaviour.</p></li>
<li>Expressivity, lean startup: Operational proofs in theorem provers such as HOL and Coq allow you to take advantage of the powerful and flexible logic built into the theorem prover (the native logic), rather than constructing a program logic first. Program logics are restricted versions of these native logics. If you want to prove something about a particular system, why go indirectly, by constructing a program logic? Constructing a program logic and proving it sound takes time and effort.
<ul>
<li>Against this, it may be the case that program logics identify common reasoning patterns that reduce the effort for many proofs. But theorem provers also allow such reasoning to be identified in the form of lemmas and tactics.</li>
</ul></li>
<li><p>Program logics are typically ad-hoc. I have seen many more program logics than I have seen non-trivial programs verified using program logics. The reason is that each program logic is restricted in some way, and mostly tied to a small class of examples. When the next example comes along that doesn't fit the class, a new program logic has to be invented. The native logic of a theorem prover is not ad-hoc in the same way, and to the same extent.</p></li>
<li>Reuse: Operational models (particularly labelled transition systems) and proofs are more reusable than programs modelled and specified using program logics. The reason is that state transition systems represent a &quot;lowest common denominator&quot; language for specification. As such, two operational models and proofs can usually be combined relatively easily. Two programs, built in different programming languages, with proofs in different program logics, may be very hard to combine (you have to build a program logic that encompasses the existing logics, and this may be hard).
<ul>
<li>Against this, when using a program logic, it may be clear what the theorems guarantee about the operational behaviour of the program. However, this is not always the case. Ideally (for me) top-level theorem statements in program logics should be clearly translated into equivalents about the operational behaviour.</li>
</ul></li>
</ul>


</div>

<!-- related articles ---------------------------------------- -->
<div>

  
<hr/>

Related posts: </br>

<ul>
<li><a href='2020-05-01_phd_viva_john_whitington.html'>2020-05-01 John Whitington PhD viva</a></li>
<li><a href='2020-02-05_phd_viva_chair.html'>2020-02-05 On the need for PhD viva chairs</a></li>
<li><a href='2020-01-20_sqlite_assumptions.html'>2020-01-20 SQLite assumptions, or how to corrupt an SQLite database</a></li>
<li><a href='2019-12-18_vetss_annual_summary.html'>2019-12-18 VeTSS annual summary</a></li>
<li><a href='2019-08-30_btree_performance.html'>2019-08-30 B-tree random write performance</a></li>
<li><a href='2019-08-21_ml_workshop_kv_store_for_ocaml.html'>2019-08-21 ML'19 Workshop at ICFP: A key-value store for OCaml</a></li>
<li><a href='2018-07-02_funded_phd_places.html'>2018-07-02 Funded PhD places</a></li>
<li><a href='2018-06-14_typed_parsing_dsl.html'>2018-06-14 A typed DSL for parsing</a></li>
<li><a href='2018-05-30_new_fs_motivation.html'>2018-05-30 Potential improvements in filesystem performance</a></li>
<li><a href='2018-05-22_first_python_program_earley.html'>2018-05-22 First Python program: an Earley parser!</a></li>
<li><a href='2018-02-01_path_resolution.html'>2018-02-01 New OCaml library: path resolution</a></li>
<li><a href='2017-09-06_icfp_most_influential.html'>2017-09-06 ICFP most influential paper from 10 years ago</a></li>
<li><a href='2017-03-16_tjr_btree.html'>2017-03-16 tjr-btree: a CoW B-tree library in OCaml</a></li>
<li><a href='2015-04-27_why_operational_models_.html'>2015-04-27 Why operational models?</a></li>
<li><a href='2014-11-26_isabelle_on_64bit_ubuntu_with_32bit_libraries.html'>2014-11-26 Isabelle on 64bit ubuntu with 32bit libraries</a></li>
</ul>


</div>

</div>
</body>

</html>
